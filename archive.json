{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-07-10T01:13:34.254246+00:00",
  "repo": "quicwg/qlog",
  "labels": [
    {
      "name": "design",
      "description": "",
      "color": "1d76db"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "0e8a16"
    },
    {
      "name": "high-level-schema",
      "description": "",
      "color": "7fd836"
    },
    {
      "name": "quic-http3-fields",
      "description": "",
      "color": "d6354a"
    },
    {
      "name": "future-versions",
      "description": "issue will be tackled but not for the current iteration",
      "color": "ea049d"
    },
    {
      "name": "current-version",
      "description": "",
      "color": "08497a"
    },
    {
      "name": "privacy",
      "description": "",
      "color": "C17C17"
    },
    {
      "name": "discuss",
      "description": "needs further discussion",
      "color": "CA53CA"
    },
    {
      "name": "ask-3rd-party",
      "description": "",
      "color": "d93f0b"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU0MjkyODkxNjc=",
      "title": "Allow flexible fields definitions",
      "url": "https://github.com/quicwg/qlog/issues/1",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "high-level-schema"
      ],
      "body": "The fields that are logged for each individual event depend on the context of usage of the format.\r\n\r\nE.g., if you split your logs per connection-id yourself, you do not need to log the connection-id for each event.\r\nHowever, if you do not log only QUIC data, but also ICMP/TCP info (e.g., the in-network measurement use-case), you need an additional field \"protocol-type\".\r\n\r\nProposal:\r\nAllow common fields to be set in each \"trace\" header.\r\n\r\n```\r\n{\r\n     \"common_fields\": [ \"connection_id\": \"0xdeadbeef\", \"protocol-type\": \"QUIC\" ],  \r\n     \"field_headers: [\"timestamp\", \"category\", \"type\", \"trigger\", \"data\"],  \r\n     \"events\": [ ... ]  \r\n}\r\n```\r\n\r\nIf you do not log a field, you just leave it out of both common_fields and field_headers. \r\n",
      "createdAt": "2019-04-04T13:46:52Z",
      "updatedAt": "2019-10-14T09:31:32Z",
      "closedAt": "2019-10-14T09:31:32Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Present in draft-01 by allowing fields in either common_fields or in event_fields.",
          "createdAt": "2019-10-14T09:31:32Z",
          "updatedAt": "2019-10-14T09:31:32Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU0MjkzNTQzMDY=",
      "title": "Streaming format",
      "url": "https://github.com/quicwg/qlog/issues/2",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "high-level-schema"
      ],
      "body": "Plain JSON is not entirely streamable... it requires its fields to be closed properly (by ] and }) at the end.\r\n\r\ne.g.,\r\n```\r\n\"events\": [\r\n           { \"key\": \"val\" }\r\n```\r\nWill fail, but \r\n```\r\n\"events\": [\r\n           { \"key\": \"val\" }\r\n]\r\n```\r\nwill succeed. \r\n\r\nHowever, one could employ a streaming JSON parser (e.g., http://oboejs.com/) and ignore unclosed fields at the end that way. \r\nFor the way the format is currently defined, an implementation would then write the \"header\" of the qlog file, and then it could stream individual events that are just appended to the file. \r\nIf the file isn't properly closed, that's not a problem: the streaming parser user just ignores those errors.\r\nHowever, this breaks compatibility with the built-in parsers in many stdlibs and the browsers themselves.\r\nIt would also be possible to write a simple postprocessing tool that simply appends the necessary \"closing\" characters to a qlog file if it isn't complete, though that adds another step in a pipeline... \r\n\r\nThere are also various JSON-subformats that address this problem (see https://en.wikipedia.org/wiki/JSON_streaming), but they also do not seem to be supported in the standard JSON parsers for many platforms...\r\n\r\n**Given all this, my personal preference is to stay with just the normal JSON format and tools are recommended to use a streaming parser.** \r\n\r\n\r\nExample of how the browser's built-in JSON parser does not support special JSON:\r\n![2019-04-04 17_02_41](https://user-images.githubusercontent.com/2240689/55566226-8df5ff80-56fb-11e9-9a60-ab0fe703cf27.png)\r\n\r\nExample of how a streaming parser (oboe) does handle this properly:\r\n![proof](https://user-images.githubusercontent.com/2240689/55569216-77eb3d80-5701-11e9-86af-2b1a5b79ea2f.png)\r\n\r\n\r\n\r\n",
      "createdAt": "2019-04-04T15:47:41Z",
      "updatedAt": "2020-09-05T16:15:36Z",
      "closedAt": "2020-09-05T16:15:36Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU0Mjk3MTAwNDc=",
      "title": "Aggregated metrics",
      "url": "https://github.com/quicwg/qlog/issues/3",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Example: in-network logger aggregates over a period of time and sends back summarized data in 1 go (e.g., average RTT in past 10s, measured over 10k packets).\r\n\r\nThis can be supported in a variety of ways.\r\n\r\nThe easiest would probably be a new EVENT type that just contains the aggregated metrics.\r\nHowever, this depends on which types of aggregated data you want to pass. \r\n\r\ne.g., saying: median RTT was 50ms over the past 5s and we saw 1k packets in that time is fine\r\n\r\ne.g., saying: median RTT was 50ms across these 5 connections identified by these 4-tuples, is not really adhering to the semantics of the original setup.\r\n\r\nWe need more input from the people doing aggregated use cases to see how this data would be used and which types of metadata is needed to make an informed decision. ",
      "createdAt": "2019-04-05T11:30:41Z",
      "updatedAt": "2020-09-07T13:18:00Z",
      "closedAt": "2020-09-07T13:18:00Z",
      "comments": []
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU0Mjk3MjQzNzc=",
      "title": "Readability vs file size",
      "url": "https://github.com/quicwg/qlog/issues/4",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "We would like to keep the file (semi-) human readable.\r\nThis means more advanced techniques like listing all fields in an ENUM up-front and then referencing to them by index is not optimal.\r\n\r\nHowever, when repeating strings, we might want to limit the length of individual fields. \r\ne.g., TRANS instead of TRANSPORT, APP instead of APPLICATION, RX instead of RECEIVE, etc. \r\n\r\nCurrent numbers (with readable strings):\r\n- qlog version without whitespace is about 4x the size of the binary .qtr file for the quic-trace example file (3.5MB to 823KB)\r\n- qlog version with whitespace is 10.6MB. However, this should matter little, since if manually reviewing large logs, you'll probably use a text editor that can auto-format the json from the version without whitespace\r\n\r\n4x size difference is a lot, but better than the direct .json protobuf transform, which clocks in at 14MB. ",
      "createdAt": "2019-04-05T12:11:32Z",
      "updatedAt": "2020-09-05T16:19:14Z",
      "closedAt": "2020-09-05T16:19:14Z",
      "comments": []
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU0Mjk3MzAwOTY=",
      "title": "Decide upon a language to define the schema definition",
      "url": "https://github.com/quicwg/qlog/issues/5",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "We need to indicate various things, such as field types (int, string, ...), whether fields are required or optional, give example values for fields, etc.\r\n\r\nWe could use normal JSON-schema for this, but this is quite verbose...\r\nWe could also use TypeScript, though this is non-standard...\r\nOther RFCs are known to use their own specific languages for this (i.e., see TLS 1.3's type definitions), but maybe there is something workable already out there. \r\n\r\nCurrently, we use TypeScript format, since this is used in the Quicker prototype qlog implementation directly + is easy enough to parse for newcomers. ",
      "createdAt": "2019-04-05T12:26:48Z",
      "updatedAt": "2020-09-05T16:19:46Z",
      "closedAt": "2020-09-05T16:19:46Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU0Mjk3NzczOTI=",
      "title": "Define the semantics of RX and TX for NETWORK vantage point",
      "url": "https://github.com/quicwg/qlog/issues/6",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "high-level-schema"
      ],
      "body": "For CLIENT and SERVER, the difference between RECEIVE (RX) and TRANSMIT (TX) is obvious. Not so for an in-network observer (or, e.g., a proxy server), where these terms make less sense...\r\n\r\nSome options:\r\n- Type is NETWORK_CLIENT and NETWORK_SERVER (instead of NETWORK)\r\n- add separate \"flow\" field indicating if we use CLIENT or SERVER semantics (currently in the draft)\r\n- add separate metadata field indicating which 5-tuple is the conceptual \"client\" and which is the \"server\" and use RX/TX based on that\r\n- Don't fix this and let the tooling layer figure it out (if packet nr 6 is a client TX and a RX in the NETWORK trace, the network is from the viewpoint of the SERVER)\r\n\r\nBroader discussion: does it make sense to log packets as PACKET_TX and _RX here? how about instead a PACKET event (similar to how wireshark does it). However: this doesn't make sense for (stateful) proxies that do act as both client+server when ~transforming the traffic (e.g., Facebook's load balancer). \r\n",
      "createdAt": "2019-04-05T14:15:11Z",
      "updatedAt": "2019-10-14T09:30:47Z",
      "closedAt": "2019-10-14T09:30:47Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Solved in draft-01 by using separate _sent and _received (or equivalent) events for clarity + using vantage_point and their \"flow\" field.",
          "createdAt": "2019-10-14T09:30:47Z",
          "updatedAt": "2019-10-14T09:30:47Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU0Mjk4MjIyODc=",
      "title": "Use cases for the TRIGGER field ",
      "url": "https://github.com/quicwg/qlog/issues/7",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "high-level-schema"
      ],
      "body": "To have the TRIGGER as a top-level field, there need to be good use-cases and people willing to use this in their tools. \r\n\r\nSince the TRIGGER will only be useful for specific events (e.g., PACKET_RETRANSMIT can be due to several loss-detection related situations) and it's value might in some cases also just be deduced from the context of surrounding log messages, it is debatable it will have much use in practice. \r\n\r\nAn alternate approach could be to log it as part of the DATA field of specific events, instead of as a top-level field. ",
      "createdAt": "2019-04-05T15:48:06Z",
      "updatedAt": "2019-10-14T09:36:11Z",
      "closedAt": "2019-10-14T09:36:11Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Feedback from among others @nibanks indicates that adding the TRIGGER as an optional member of the DATA is probably the better option down the road.\r\n\r\nWe could think about extending that: any event_field could conceptually be added to data. This would be useful for other event_fields as well, that are not the same for all events (which would be in common_fields) but also don't need to be logged for each event (event_fields). Maybe something like dynamic_fields? and then you do data.dynamic to fetch them? (e.g., data.dynamic.trigger). This is nice an flexible, but a potential nightmare to support properly in tooling...",
          "createdAt": "2019-07-31T13:47:10Z",
          "updatedAt": "2019-07-31T13:47:10Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in #23. Triggers are now properties of the data field with hints in the draft as to their values in separate contexts. \r\n\r\nDecided not to do the \"dynamic_fields\" approach for now to keep complexity manageable. ",
          "createdAt": "2019-10-14T09:36:11Z",
          "updatedAt": "2019-10-14T09:36:11Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU0Mjk4Mzg0ODU=",
      "title": "Allow index-based referencing for all event field names",
      "url": "https://github.com/quicwg/qlog/issues/8",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "high-level-schema"
      ],
      "body": "Currently, we have a concept that you can have a \"groups_id\" object in \"common_fields\". \r\nIf you then have a \"group_id\" in your \"events_field\", the value for that with each event is an index into the \"groups_id\" field, to prevent replication of complex fields.\r\n\r\nWe could make this more general, applicable to each field name.\r\nE.g., if you know up-front which CATEGORY values you support, you could do something like:\r\n\r\n```\r\n{\r\n    \"common_fields\": {\r\n        \"group_id\": \"127ecc830d98f9d54a42c4f0842aa87e181a\",\r\n        \"ODCID\": \"127ecc830d98f9d54a42c4f0842aa87e181a\",\r\n        \"CATEGORY\": [\"PACKET_RX\", \"DATA_FRAME_NEW\"]\r\n        \"protocol_type\":  \"QUIC_HTTP3\",\r\n        \"reference_time\": \"1553986553572\"\r\n    },\r\n    \"event_fields\": [\r\n        \"delta_time\",\r\n        \"CATEGORY\",\r\n        \"EVENT_TYPE\",\r\n        \"TRIGGER\",\r\n        \"DATA\"\r\n    ],\r\n    \"events\": [[\r\n            2,\r\n            \"TRANSPORT\",\r\n            0,\r\n            \"LINE\",\r\n            [...]\r\n        ],[\r\n            7,\r\n            \"APPLICATION\",\r\n            1,\r\n            \"GET\",\r\n            [...]\r\n        ],\r\n        ...\r\n    ]\r\n}\r\n```\r\n\r\nWe would then have a general rule:\r\n\r\n> If the field is present as a value of type array in \"common_fields\" AND the field-name is present in \"event_fields\", the value per-event MUST be treated as an index into the \"common_fields\" entry, rather than taken as a direct value. \r\n\r\n(\"groups_id\" would then also be renamed to \"group_id\" in \"common_fields\")\r\n\r\nThis would allow smaller file sizes (and less string writing overhead) for applications that have a static list of e.g., CATEGORY or EVENT_TYPE up front.\r\nDownside 1 is that it complicates the tools reading the file (but only a bit imo).\r\nDownside 2 is that is complicates humans reading the file (so it depends on the use case).\r\n   (either way, it's easy to go from 1 to the other with a simple script)\r\n\r\n-----------------------------------------------------------------------------------\r\n\r\nThis concept could be extended to make it a fully self-describing format.\r\nIn other words, we could also describe the fields in the DATA for known events up-front and replace those entries with in-order arrays of the values instead of key-value object definitions.\r\n\r\nVery high-level concept (probably needs proper description of the fields etc.):\r\n```\r\n\"data_fields\" : {\r\n      \"TRANSPORT+PACKET_SENT\" : [\r\n         \"frame_type\",\r\n         \"packet_number\",\r\n         \"frames\"\r\n     ]\r\n}\r\n...\r\n[ 57, \"TRANSPORT\", \"PACKET_SENT\", \"TRIGGER\", [\"STREAM\", 15, [...]]]\r\n```\r\nTaking this all to the extreme, you could have a fully self-describing format that lists all known events (and potentially some values, similar to QPack's static table) up-top and then each entry just uses indexes + potentially a few raw values. However, I'm personally not of the opinion this added complexity is worth it. \r\n\r\n",
      "createdAt": "2019-04-05T16:27:53Z",
      "updatedAt": "2019-10-14T09:29:52Z",
      "closedAt": "2019-10-14T09:29:52Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the interest of keeping things simple and because there are few situations where this has turned up in the meantime, I've decided for now to only allow this for \"group_id\". Further fields that benefit from this can be added per-instance. \r\n\r\nNote that Chrome's netlog format does this, and it severely compromises the user's ability to understand and grep those files, despite them using .json as a substrate as well.",
          "createdAt": "2019-10-14T09:29:52Z",
          "updatedAt": "2019-10-14T09:29:52Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU0MzA1MDE2ODM=",
      "title": "How descriptive should EVENT_TYPE names be?",
      "url": "https://github.com/quicwg/qlog/issues/9",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "quic-http3-fields"
      ],
      "body": "For example:\r\nPACKET_RECEIVED        vs       1RTT_PACKET_RECEIVED\r\nFRAME_NEW                vs        ACK_FRAME_NEW\r\n\r\nFor the leftmost entries, one would add a \"type\" field to the \"DATA\" value, e.g., \r\n```\r\n{\r\n     \"type\": \"1RTT\"\r\n}\r\n```\r\n\r\nThe shorter form makes that we have a much less large amount of different EVENT_TYPEs, but also makes it a bit harder to parse for human readers + harder to quickly filter for tools. \r\nThe longer form is much more explicit, but requires much more definition up-front and a proliferation of different EVENT_TYPEs.\r\n\r\nWe could also break consistency. i.e., the original qlog used PACKET_RECEIVED with an explicit type in the DATA, but used ACK_FRAME_NEW for individual frames.\r\n\r\nCurrently, we use the short-form, since this is most similar to quic-trace and keeps it consistent if we want to log frames both in their own events and again when sending a packet. \r\n\r\nExtra edge-case: Errors\r\nIf you go for extreme short-form, you would just have a single ERROR EVENT_TYPE for each CATEGORY, and define the error type in the DATA.\r\nHowever, for easier manual debugging, tracking the specific type of error directly in the EVENT_TYPE is arguably easier. Maybe an exception should be made for errors? ",
      "createdAt": "2019-04-08T15:01:36Z",
      "updatedAt": "2019-10-07T19:46:27Z",
      "closedAt": "2019-10-07T19:46:26Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In draft-01, we made the conscious choice to limit the number of events as much as possible and make most event data based on the Frame definitions that already existed for packet_sent and packet_received. Combined with proper naming of properties (e.g., packet_type instead of type) this enables fast parsing while removing the need for separate events for each possible signal.",
          "createdAt": "2019-10-07T19:46:26Z",
          "updatedAt": "2019-10-07T19:46:26Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU0MzA5NTQyMzE=",
      "title": "Numbers in JSON",
      "url": "https://github.com/quicwg/qlog/issues/10",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "quic-http3-fields"
      ],
      "body": "Typically, integers in JavaScript and most JSON implementations are limited to 2^53-1.\r\nThis gives problems, as the VLIE values in the QUIC/H3 specs are 2^62-1.\r\n\r\nTwo options:\r\n- Allow bigger values in the JSON. Tools MUST use a JSON parser that can deal with this and a JavaScript engine that supports BigInt (currently limited to Chromium: https://caniuse.com/#search=bigint)\r\n- Encode all VLIE fields as strings. Tools have to deal with this themselves (most will probably just take the shortcut of assuming actual values will be < 2^53 and just use the JavaScript \"Number\" type). This is best for a wide tooling implementation area in browsers. \r\n\r\nCurrently, the draft uses option 2. \r\n\r\n",
      "createdAt": "2019-04-09T13:00:45Z",
      "updatedAt": "2020-09-05T16:19:32Z",
      "closedAt": "2020-09-05T16:19:32Z",
      "comments": [
        {
          "author": "jlaine",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Firefox and Edge (obviously) also suport BigInt according to caniuse. The only significant outlier is Safari.\r\n\r\nHowever you're right, JSON serialization / parsing isn't there yet:\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Use_within_JSON",
          "createdAt": "2019-08-23T10:57:13Z",
          "updatedAt": "2019-08-23T10:59:25Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "An alternative would be to define a completely different interface.\r\n\r\nJSON is an odd choice because what generally happens here is that you have a stream of events.  Constructing that as a JSON array is awkward as it interacts poorly with typical JSON processing pipelines.  You might use JSON text sequences, but that is an odd line.\r\n\r\nCSV has some nice properties: you define the first column as the event type and remaining fields dependent on the type.  Then each record is delineated by something easy to produce (CRLF) and fields are easily recoverable.  Everything is a string then and you can define processing for number fields.",
          "createdAt": "2019-11-19T04:00:59Z",
          "updatedAt": "2019-11-19T04:00:59Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As pointed out by @marten-seemann, the JSON spec itself does not limit the numbers to 2^53-1, it is just the implementations.\r\n\r\nAs such, for the purposes of the qlog spec, and if we stay with JSON, we can simply require clients to be able to deal with larger numbers in one of several ways (e.g., either detect and discard, detect and notify user, ignore, use parser that can handle up to 64 bit).\r\n\r\nI am thinking of switching to option 1 (from the first post in this issue) for draft-02. \r\n\r\n\r\n",
          "createdAt": "2020-01-19T10:45:33Z",
          "updatedAt": "2020-01-19T10:45:33Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU0MzQ2NzkxMTA=",
      "title": "Allow raw logging of packets and/or frames",
      "url": "https://github.com/quicwg/qlog/issues/11",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "quic-http3-fields"
      ],
      "body": "As mentioned by @kazuho on the mailing list, it would be useful to (re-)introduce the ability to log raw packet and/or frame contents, probably has a hex-encoded string. \r\n\r\nProbably easiest to add an additional field like this:\r\n```\r\n{\r\n    \"stream_type\": \"ACK\",\r\n    \"raw_hex\": \"0892e340dbaa354f800239dddc7be78406fe3726bea050bb8c56ab36\",\r\n    ...\r\n}\r\n```",
      "createdAt": "2019-04-18T09:37:52Z",
      "updatedAt": "2019-10-14T09:27:43Z",
      "closedAt": "2019-10-14T09:27:43Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Thank you for opening the issue.\r\n\r\nCan we also omit the \"stream_type\" attribute, because that would be obvious from the first byte of the binary? So something like just `{\"raw_hex\":\"...\"}` or just the hex string itself.",
          "createdAt": "2019-04-18T23:58:00Z",
          "updatedAt": "2019-04-18T23:58:00Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Omitting the stream_type is indeed possible.\r\nDropping the \"raw_hex\" would require a move to an array (i.e., [ ]) rather than an object (i.e., { }) literal.\r\nThis is something we might want to allow for issue #8 as well, so that might fit. \r\n\r\nJust to be sure what we're talking about:\r\nWe would have a mixed JSON file format with some events (e.g., recovery-related stuff) being logged in full, and the packet/frame level events being logged as binary hex strings for post-processing, right? See the example below.\r\n\r\n```\r\n\"events\": {\r\n    [48, \"TRANSPORT\", \"PACKET_RECEIVED\", \"DEFAULT\", [\"08277abefc43c25eca0892e340dbaa354f800239dddc7be78406fe3726bea050bb8c56ab36\"] ],\r\n    [49, \"TRANSPORT\", \"FRAME_RECEIVED\", \"DEFAULT\", [\"0892e340dbaa354f800239dddc7be78406fe3726bea050bb8c56ab36\"] ],\r\n    [50, \"RECOVERY\", \"METRIC_UPDATE\", \"ACK_RECEIVED\", {\"min_rtt\": 50, \"smoothed_rtt\": 62} ],\r\n}\r\n```\r\nDoes that fit with what you had in mind? (I have now included both full packet and separate frame logs, obviously we could also just do the packet only)\r\n",
          "createdAt": "2019-04-19T09:57:21Z",
          "updatedAt": "2019-04-19T09:58:45Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Lacking further follow-up on this, I've added \"raw\" or \"raw_encrypted\"/\"raw_decrypted\" fields where appropriate to draft-01. I do not want to require tools to deal with situations where only the \"raw\" fields are present (i.e., having to include a full compliant QUIC and H3 parser in each tool), so you'd have to write a separate transformer that takes the raw stuff and transforms it into \"proper qlog\" before putting it in a tool, but I feel it's a good compromise personally.",
          "createdAt": "2019-10-14T09:27:43Z",
          "updatedAt": "2019-10-14T09:27:43Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU0NzE3NzQ4MDQ=",
      "title": "Invalid Assumptions in packet_sent triggers",
      "url": "https://github.com/quicwg/qlog/issues/13",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The `packet_sent`'s `triggers` field makes the assumptions that a packet is sent because a previous packet is being retransmitted. For instance, in winquic a connection has a queue/set of what data needs to be sent. When data is (suspected) lost, the data in the packet is added back to the queue. Similarly for PTO, we mark an outstanding packet as lost, and if we don't have any, queue a PING frame.\r\n\r\nThe send logic just grabs data from the queue/set and builds up packets to be sent. There is no direction relationship between different packets.\r\n\r\nSo, IMO, triggers are the reason data is queued to be sent, not actually sent. What is actually sent will depend on the entire state of the send queue at the time the send logic actually executes.\r\n\r\nFor example, assume you have two outstanding packets that end up getting marked as lost:\r\n\r\n```\r\n  PktNum=1 { STREAM ID=1, Offset=0, Length=100 }\r\n  PktNum=2 { STREAM ID=1, Offset=100, Length=100 }\r\n```\r\n\r\nBoth are marked as lost. Around the same time, the app queues another 100 bytes on stream 1 to be sent. Then another packet ends up getting sent:\r\n\r\n```\r\n  PktNum=55 { STREAM ID=1, Offset=0, Length=300 }\r\n```",
      "createdAt": "2019-07-23T15:45:02Z",
      "updatedAt": "2019-10-07T17:03:31Z",
      "closedAt": "2019-10-07T17:03:31Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "As a follow up, I believe the packet_lost and packet_acknowledged events should be in the transport section. Also, the packet_retransmit should be removed.",
          "createdAt": "2019-07-23T15:48:54Z",
          "updatedAt": "2019-07-23T15:48:54Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU0NzE3Nzk5MTc=",
      "title": "Payload for packet_dropped",
      "url": "https://github.com/quicwg/qlog/issues/14",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "First, it looks like there is no payload for this event. Is that expected? It's a hard problem. Practically, there is only one case in which you drop a packet, post decryption success, and that is because it's a duplicate packet number. Other than that, all other drop events would occur before a packet is decrypted. If it can't be decrypted you don't know the packet number, which would likely be the most interesting payload of this event. So, therefor it likely isn't too useful in having the packet number as payload.\r\n\r\nSo, in absence of including the packet number as payload, it might just be worth having a \"reason\" which is a string. That's what winquic has already at least.",
      "createdAt": "2019-07-23T15:54:46Z",
      "updatedAt": "2019-10-07T17:03:30Z",
      "closedAt": "2019-10-07T17:03:30Z",
      "comments": []
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU0NzI4MTg2NjI=",
      "title": "Specify time units used for ack_delay",
      "url": "https://github.com/quicwg/qlog/issues/15",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "And probably for other non-timestamp time values (like RTT)\r\n\r\nOptions:\r\n- Force people to use the resolution set in the \"configuration\"\r\n- Choose a fixed resolution (always milli or always micro)\r\n- Allow people to indicate resolution inside .data of each event \r\n- Combination: default is milli, add config parameter to specify, allow overrides in the .data, etc.\r\n\r\nThanks @jlaine for reporting.",
      "createdAt": "2019-07-25T11:43:19Z",
      "updatedAt": "2019-10-14T09:24:55Z",
      "closedAt": "2019-10-14T09:24:55Z",
      "comments": [
        {
          "author": "jlaine",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd say the first option \"force people to use the resolution set in configuration\".",
          "createdAt": "2019-08-23T10:54:57Z",
          "updatedAt": "2019-08-23T10:54:57Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by 3c09877 through the \"first option\"",
          "createdAt": "2019-10-14T09:24:55Z",
          "updatedAt": "2019-10-14T09:24:55Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU0NzMwNTQ1NDU=",
      "title": "Support partial logs",
      "url": "https://github.com/quicwg/qlog/issues/16",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@nibanks mentioned that the winquic implementation does logging in a circular buffer. If this runs out of space, the earliest logs (e.g., the ip addresses, initial connection ids, etc. might have been dropped).\r\n\r\nWe can't really force tools to support this, but potentially we can add text in the draft so people know they should take this into account.",
      "createdAt": "2019-07-25T20:26:05Z",
      "updatedAt": "2019-10-14T09:24:28Z",
      "closedAt": "2019-10-14T09:24:28Z",
      "comments": []
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU0NzMwNTg0NzU=",
      "title": "Simplify / fix group_id usage",
      "url": "https://github.com/quicwg/qlog/issues/17",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, the group_id concept is -very- flexible. It can be in common_fields (e.g., 1 trace per connection) but it can also be in event_fields (combining several connections into 1 trace). That already puts quite a burden on tools to support this different approaches.\r\n\r\nThen, another problem comes up if you would have the same group_id across multiple traces (e.g., trace 1 has some events for group_id x, but trace 2 has some group_id x events as well.)\r\n\r\nNote: This concept was mainly added to support the spindump use case (https://github.com/EricssonResearch/spindump), CC @jariarkko. There, a network intermediary logs (aggregated) data on many connections and even protocols. It would be tedious for that setup to split everything out into separate traces. \r\n\r\nPossible solutions I currently see:\r\n- Only allow 1 of the options (e.g., group_id only in common_fields or only in event_fields). I'm not a big fan of this (common only is inflexible, event_fields only has much overhead)(also: common can be seen as a special case of event_fields, so that could be the implementation target)\r\n- Disallow the same group_id across different traces: I think this makes a lot of sense, my preference\r\n- Discard the whole group_id concept alltogether (in practice, this would lead to many different approaches in different tools. basically the same as event_fields only, only no standard way of calling the thing)\r\n\r\nAdditional suggestion: rename group_id to \"luid\" (locally unique identifier)\r\n\r\nThanks to @nibanks for reporting this",
      "createdAt": "2019-07-25T20:35:32Z",
      "updatedAt": "2020-09-05T16:21:06Z",
      "closedAt": "2020-09-05T16:21:06Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking about this some more and having implemented splitting traces on group_id in quicvis, I feel allowing group_ids across traces is still the best way to go. \r\n\r\nIf you're logging on multiple network intermediaries (so multiple vantage points) at once and then merge those logs, you will always have the same group_id split over multiple traces. However, each of those traces SHOULD then represent a different vantage_point. So the real restriction should be: cannot spread events from the same vantage point across different traces within the same qlog file. Put differently: each trace should contain only events from a single vantage point. \r\n\r\nAs such, we might rename group_id to flow_id instead, since that makes the semantics a bit clearer. That would say \"this event belongs to flow with flow_id x, as observed from entity y\".\r\n\r\nI am trying to think of a reason why you would want to combine events from different vantage points into the same trace, but can't seem to find a use case. Either way, that would require changing up how we define vantage_point now, since it's per-trace and not part of common_fields or event_fields. \r\n\r\nAny thoughts @nibanks? ",
          "createdAt": "2019-10-02T12:01:53Z",
          "updatedAt": "2019-10-02T12:01:53Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Are there really people signed up to trace multiple different vantage points and put them all in the same file? I don't know about other companies, but getting logs from more than one machine all into the same file is practically impossible for the Windows scenario. Would it be so bad that the tools need to parse a file per vantage point?\r\n\r\nI want qlog to succeed, but the more complicated it it, the less the chance I see that of becoming a reality. IMO, this is a place where simplicity should win.",
          "createdAt": "2019-10-02T14:05:51Z",
          "updatedAt": "2019-10-02T14:09:23Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1) About the use case of having multiple traces in 1 file, I'm not directly thinking of the Windows scenario or using this in production, but more about use cases such as research, education and case studies. There, it's handy to be able to group everything needed for a single \"context\" in a single file to be shared and interpreted easily. For production, automated gathering or aggregation in separate datastores is certainly also possible. The current setup does not prevent you loading separate files, 1 per vantage point, either.  \r\n\r\n2) I'm not sure how only allowing a single trace from a single vantage point per file would help the original problem that it's difficult for tool developers to deal with group_ids occurring across traces... client and server will still have events with the same group_id (e.g., ODCID)\r\n\r\n As such, I'm not 100% sure what you're proposing? Do you want to do away with the \"traces\" array and replace it with a single \"trace\" per qlog file? Or do you want to do away with group_id at the \"event_fields\" level, requiring each individual trace to only contain events from a single connection?\r\n\r\nIn the latter case, I think that would actually be an obstacle to adoption, since currently several implementers are simply logging all events on the server in a single trace, tagged with ODCID for later splitting. This is generally much simpler than generating a single file (or trace) per connection on the server. \r\n\r\nIf you want to do away with group_id completely, that would leave out a whole bunch of other use cases, e.g., in-network observers like spindump (https://github.com/EricssonResearch/spindump, CC @jariarkko, @ihlar). This might be good enough for the QUIC use case (though barely), but not if qlog would grow to a more flexible format. \r\n\r\nFor draft-01, I've decided to keep the setup as-is, since there are users employing group_ids already (e.g., quant). I did specify the intended uses a bit more and am certainly open to more discussion on this design. Will you be in Singapore, @nibanks?",
          "createdAt": "2019-10-14T08:58:25Z",
          "updatedAt": "2019-10-14T08:58:25Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the `group_id` field was not seeing much use in practice and as discussed above had some issues.\r\n\r\nIt has been considerably simplified for draft02, from f5db7cdc8cd0cf37bfe5f1b0b4c54fc56ffc5f28 onward. ",
          "createdAt": "2020-09-05T16:21:06Z",
          "updatedAt": "2020-09-05T16:21:06Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU0OTAxODExOTk=",
      "title": "Make it possible to tie push_id to stream",
      "url": "https://github.com/quicwg/qlog/issues/19",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks to @jlaine for reporting",
      "createdAt": "2019-09-06T07:46:24Z",
      "updatedAt": "2019-10-09T19:24:59Z",
      "closedAt": "2019-10-09T19:24:58Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Was added as \"associated_push_id\" to http.stream_type_set in dda4374878d6fa3aabe9406bd1f7f8706ac59c80",
          "createdAt": "2019-10-09T19:24:58Z",
          "updatedAt": "2019-10-09T19:24:58Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU0OTMyNjg4Njg=",
      "title": "Better qpack support",
      "url": "https://github.com/quicwg/qlog/issues/20",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some comments from @lpardue on qpack support:\r\n\r\n> but how do you correlate a qpack header block event (or whatever you want to call it) to the header frame that it was carried in? maybe simply that header block event contains a stream_id for correlation\r\n\r\n> other option is add raw_header_block to the HeaderFrame event data\r\n\r\nThough that would still require additional events for encoder/decoder instructions, no?\r\n\r\n> a qpack event that can consist of encoder instructions, decoder instructions and/or header block\r\n\r\nSo this seems the better option then, combined with the stream_id and expectation that the qpack events are logged in the same order as HeaderFrame's... (though not sure how important the ordering is personally).\r\n\r\nOpen questions:\r\n- What about seeing what's in the dynamic table (or initial static table? or is that always the same?)? specific dynamic_table_updated event or... ?\r\n\r\n\r\n",
      "createdAt": "2019-09-13T11:12:21Z",
      "updatedAt": "2019-10-08T14:50:35Z",
      "closedAt": "2019-10-08T14:50:35Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "> What about seeing what's in the dynamic table (or initial static table? or is that always the same?)? specific dynamic_table_updated event or... ?\r\n\r\nSome of this comes around to qlog design ethos - are you logging the message exchange objects or their effects or both (or some, depending on event types and deployment preference)?\r\n",
          "createdAt": "2019-09-13T11:18:25Z",
          "updatedAt": "2019-09-13T11:18:25Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU1MDE0NDY2MDA=",
      "title": "Make event names more consistent",
      "url": "https://github.com/quicwg/qlog/issues/21",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Change event names to the trend of \"metrics_updated\" instead of \"metric_update\".\r\nThis is what we use for \"packet_sent\" and \"packet_received\" etc. and it's nicer to have this everywhere. ",
      "createdAt": "2019-10-02T12:03:27Z",
      "updatedAt": "2019-10-04T10:41:15Z",
      "closedAt": "2019-10-04T10:41:15Z",
      "comments": []
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU1MDIxMzAxNzQ=",
      "title": "Mark events by their importance",
      "url": "https://github.com/quicwg/qlog/issues/22",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Not all events are equally useful in a debugging/tooling scenario.\r\nMark events according to order of usefulness/expectedness.\r\n\r\nFor example:\r\n- Core\r\n- Base\r\n- Extra",
      "createdAt": "2019-10-03T15:15:45Z",
      "updatedAt": "2019-10-04T10:41:15Z",
      "closedAt": "2019-10-04T10:41:15Z",
      "comments": []
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU1MDI1MjU5NTE=",
      "title": "Make triggers behave like mixins",
      "url": "https://github.com/quicwg/qlog/issues/23",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Since no-one is implementing triggers as top-level fields and it was always unclear how to best approach them, we should punt them to optional properties of the \"data\" field instead. This allows their flexibility without their overhead. \r\n\r\nSee also issue #7 ",
      "createdAt": "2019-10-04T09:20:09Z",
      "updatedAt": "2019-10-04T10:41:15Z",
      "closedAt": "2019-10-04T10:41:15Z",
      "comments": []
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU1MDM1NTYyMTM=",
      "title": "Replace specific events with a single encompassing event",
      "url": "https://github.com/quicwg/qlog/issues/24",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We want to reduce the total amount of events as much as possible.\r\n\r\nEspecially specific events for things happening in reaction to the receipt of a specific frame in a packet (e.g., ACK, MAX_DATA, etc.) can be removed, since they can usually be inferred from that frame. Initially we had separate events for these (e.g., \"packet_acknowledged\" or \"flow_control_updated\" but those were rarely used in addition to packet_received events + many implementations do not defer frame handling from reception.\r\n\r\nOne notable exception is @nibank's msquic, which does not log all frames in a received packet, but rather does log only specific events (e.g., packet_acknowledged). One of the reasons is because he feels logging each packet in full does not scale. Another reason for this pattern might be that an implementation does not wish to log all types of frames OR conversely, does not want to log packet-level information at all but only very select frames. \r\n\r\nTo support this use case and still keep a low amount of event types, I will add a \"frame_parsed\" encompassing event. This will log the frame with its associated data, but without the encompassing packet-level data. This prevents re-defining semantics for many events. The downside is that you sometimes might want to log e.g., \"packet_acknowledged\" a long time after frame receipt. In that case, you would pretend you're parsing the frame only then. I feel this is a good trade-off to make here though. ",
      "createdAt": "2019-10-07T16:20:47Z",
      "updatedAt": "2019-10-07T17:03:31Z",
      "closedAt": "2019-10-07T17:03:31Z",
      "comments": []
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU1MDQ1MjcwNDA=",
      "title": "Additional triggers and info for dropped packets",
      "url": "https://github.com/quicwg/qlog/issues/25",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "future-versions"
      ],
      "body": "The current text lists about 8 reasons for dropping packets.\r\nMicrosoft's implementation lists 60+ individual reasons (via @nibanks)\r\n\r\nSome of those:\r\n\r\n> LogDrop(\"Retry sent to server\");\r\nLogDrop(\"Already received server response\");\r\nLogDrop(\"No room for ODCID\");\r\nLogDrop(\"Invalid ODCID\");\r\nLogDrop(\"InitialToken alloc failed\");\r\nLogDrop(\"OrigCID alloc failed\");\r\nLogDrop(\"Max deferred datagram count reached\");\r\nLogDrop(\"Key no longer accepted\");\r\nLogDrop(\"SH packet during version negotiation\");\r\nLogDrop(\"Too short for HP\");\r\nLogDrop(\"Packet number too big\");\r\nLogDrop(\"Payload length less than encryption tag\");\r\nLogDrop(\"Generate new packet keys\");\r\nLogDrop(\"Decryption failure\");\r\nLogDrop(\"Invalid SH Reserved bits values\");\r\nLogDrop(\"Invalid LH Reserved bits values\");\r\nLogDrop(\"Duplicate packet number\");\r\nLogDrop(\"Key no longer accepted (batch)\");\r\nLogDrop(\"Failed to compute HP mask\");\r\nLogDrop(\"Different remote address\");\r\nLogDrop(\"Too small for Packet->Invariant\");\r\nLogDrop(\"LH no room for DestCID\");\r\nLogDrop(\"Zero length DestCID\");\r\nLogDrop(\"LH no room for SourceCID\");\r\nLogDrop(\"SH no room for DestCID\");\r\nLogDrop(\"DestCID don't match\");\r\nLogDrop(\"SourceCID don't match\");\r\nLogDrop(\"Greater than allowed max CID length\");\r\nLogDropWithValue(\"Invalid client/server packet type\", Packet->LH->Type);\r\nLogDrop(\"Invalid LH FixedBit bits values\");\r\nLogDrop(\"Long header has invalid token length\");\r\nLogDropWithValue(\"Long header has token length larger than buffer length\", TokenLengthVarInt);\r\nLogDrop(\"Long header has invalid payload length\");\r\nLogDropWithValue(\"Long header has length larger than buffer length\", LengthVarInt);\r\nLogDropWithValue(\"Long Header doesn't have enough room for packet number\",\r\nLogDrop(\"Invalid SH FixedBit bits values\");\r\nLogDrop(\"Non-initial packet not matched with a Connection\");\r\nLogDrop(\"Retry received after initial\");\r\n\r\nI feel that we don't need to list things in this level of detail in the qlog spec (the \"trigger\" field allows any text anyway). However, maybe some guidance text on this would be helpful and maybe a few more suggested triggers would be interesting. \r\n\r\n\r\n",
      "createdAt": "2019-10-09T09:29:23Z",
      "updatedAt": "2023-02-13T09:21:34Z",
      "closedAt": "2023-02-13T09:21:34Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Wonder how many reasons Microsoft has for dropping in packets in 2022. Any input @nibanks? What are your top 20 used reasons?\r\n\r\nI think we need to be judiscious with minimizing scope in the qlog document. Unless the triggers are common and self explanatory, we'll just risk confounding people with options or tying ourselves in knots with text to explain them. \r\n\r\nOur escape valve is that this is free form text and probably not commonly used for anything special. Being frugal in the base spec is an advantage.",
          "createdAt": "2022-09-07T23:11:40Z",
          "updatedAt": "2022-09-07T23:11:40Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "fwiw, this is what quic-go has: https://github.com/lucas-clemente/quic-go/blob/62b82789c0cc8a9acf48ee516ce2dd303253f395/logging/types.go#L36-L59\r\n\r\nIt seems like many of @nibanks' reasons are just variations of a generic \"header parse error\", and could be logged as details to that event.",
          "createdAt": "2022-09-08T11:34:53Z",
          "updatedAt": "2022-09-08T11:34:53Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "In my experience, if you're debugging an incident, you need to know the exact line of code, the exact reason why a drop happened, because you need to figure out how to fix it right then. If you only log enough to narrow the scope down to a dozen different code places, that doesn't help.\r\n\r\nI don't care if there is one field for all the info, or two, with one of them being the \"detailed_info\" or something, but all the details need to be captured to make it useful.",
          "createdAt": "2022-09-08T12:12:07Z",
          "updatedAt": "2022-09-08T12:12:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I agree deployments would want the ability to log to that level.\r\n\r\nLet's look at HTTP status codes for example. Proxies can fail requests with high level 4xx or 5xx status codes and then use the proxy-status header to include additional data https://datatracker.ietf.org/doc/html/rfc9209; namely the `error` parameter.  HTTP also has problem details https://www.ietf.org/archive/id/draft-ietf-httpapi-rfc7807bis-04.html. \r\n\r\nThis is effectively a 3 layer model of coarseness - limited top level, broader mid level, very specific low layer. Each of these layers is also well structured, which makes interoperability easier - I.e. grepping out specific cases for alerting or investigation.\r\n\r\nTo map to qlog we could have a limited set of top-level triggers, an optional error type, and a field for detailed info. The last field is likely to be text but in theory you could indicate the format of that text for interop. E.g., if I want to encode JSON in event and singal that to consumers explicitly, using a media type could help. But is suspect `text` is probably enough for a lot of folks.",
          "createdAt": "2022-09-08T12:47:33Z",
          "updatedAt": "2022-09-08T12:47:33Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "just adding a datapoint in favor for being as specific as possible about the reason a packet got dropped on the floor\r\nin MVFST we have about 40 different reasons  and as @nibanks says they are useful to identify the specific line of code that drops the packet\r\n https://github.com/facebookincubator/mvfst/blob/main/quic/state/QuicTransportStatsCallback.h#L30-L73 \r\n \r\nThat being said encoding this information with a generic \"Packet Dropped\" event and an optional free-form reason/detailed_info field seems like the best course of action to me since it's not up to qlog specs to define which errors are useful and which ones are less useful.",
          "createdAt": "2022-09-08T14:54:56Z",
          "updatedAt": "2022-09-08T15:02:26Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looking at this, I would agree keeping the list in qlog itself quite short and providing a generic field where implementations can add any type of freeform info they desire. \r\n\r\nFor this, we need 2 things:\r\n\r\n1. Decide WHICH of these current triggers on `packet_dropped` we want to keep (or do we want to rename/exchange some maybe?). Probably best coming from someone with a large deployment (@LPardue @nibanks @lnicco): \r\n\r\n```\r\n        \"key_unavailable\" /\r\n        \"unknown_connection_id\" /\r\n        \"header_parse_error\" /\r\n        \"payload_decrypt_error\" /\r\n        \"protocol_violation\" /\r\n        \"dos_prevention\" /\r\n        \"unsupported_version\" /\r\n        \"unexpected_packet\" /\r\n        \"unexpected_source_connection_id\" /\r\n        \"unexpected_version\" /\r\n        \"duplicate\" /\r\n        \"invalid_initial\"\r\n```\r\n\r\n2. Add a `details` field to the event. I have it as a JSON object instead of a `text` but I don't mind either way. \r\n\r\n```\r\nTransportPacketDropped = {\r\n    ; primarily packet_type should be filled here,\r\n    ; as other fields might not be parseable\r\n    ? header: PacketHeader\r\n\r\n    ? raw: RawInfo\r\n    ? datagram_id: uint32\r\n\r\n    ? details: {* text => any}\r\n\r\n    ; list of leftover triggers here:\r\n    ; ...\r\n}\r\n```\r\n\r\nI'd put the \"error type\" in the `details` field as well then @LPardue, feeling that the `trigger` can act as an \"error category\" indicator. ",
          "createdAt": "2022-09-28T13:41:28Z",
          "updatedAt": "2022-09-28T13:56:15Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Looking at our (currently 79) drop reasons in MsQuic, I think the following top-level categories would be reasonable:\r\n\r\n- Internal Error (not initialized, OOM, etc.)\r\n- Rejected (internal limits reached, ddos protection, unwilling to track more paths, duplicate)\r\n- Unsupported (unknown/unsupported version)\r\n- Invalid Packet (packet parsing/validation failed)\r\n- Connection Unknown (CID doesn't match)\r\n- Decryption Failure (decrypt failed or key unavailable)",
          "createdAt": "2022-09-28T14:16:31Z",
          "updatedAt": "2022-09-28T14:16:31Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I like Nicks categories. All I might add is a \"General\" category for anything else, where details can be added or not at operator discretion",
          "createdAt": "2022-09-28T16:50:02Z",
          "updatedAt": "2022-09-28T16:50:02Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU1MDcwOTMyMTQ=",
      "title": "well-known URI might include an extension",
      "url": "https://github.com/quicwg/qlog/issues/26",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, we just use the ODCID directly as an identifier, without a \".qlog\" extension. \r\nIt might be interesting to include the extension, but I don't really have a good view on the pros and cons. ",
      "createdAt": "2019-10-15T08:38:34Z",
      "updatedAt": "2020-09-01T19:13:48Z",
      "closedAt": "2020-09-01T19:13:48Z",
      "comments": []
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU1MDcxMDcwNzU=",
      "title": "0-RTT is a bit ambiguous in -01",
      "url": "https://github.com/quicwg/qlog/issues/27",
      "state": "OPEN",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "design",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "using transport.parameters_set there are two parameters to signal 0-RTT:\r\n- resumption_allowed\r\n- early_data_enabled\r\n\r\nAs pointed out by @jlaine, these are a bit ambiguous, as 0-RTT can either be used for the current connection or enabled for a future connection.\r\n\r\nSolution 1:\r\n- Rename parameters to resumption_accepted and early_data_accepted\r\n- Add new events: session_ticket_sent/received (with early_data_enabled?:boolean member)\r\n\r\nSolution 2:\r\n- Rename parameters to resumption_accepted and early_data_accepted\r\n- Add new parameters: resumption_offered and early_data_offered",
      "createdAt": "2019-10-15T09:03:47Z",
      "updatedAt": "2024-10-21T09:15:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure I agree that there's an ambiguity here, as TLS 1.3 clearly defines how the `early_data` extension is used. However, we currently can't log when 0-RTT is accepted / rejected (although you _could_ infer that by observing what values TLS sends).\r\nMaybe we should have separate events that indicate if resumption (with or without 0-RTT) was offered (on the client side), and on the server side, if it was accepted or rejected (for rejections, the reason might be interesting to log).",
          "createdAt": "2021-10-04T14:27:01Z",
          "updatedAt": "2021-10-04T14:27:01Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Revisiting this issue. I still believe that splitting up the event is the right thing to do: `parameters_set` should **only** be used for QUIC transport parameters. We should probably have a field to indicate where these parameters came from (i.e. newly received vs. restored).\r\n\r\nThis means that we'll need to define new events for TLS session resumption / 0-RTT. As I suggested 3 years ago, this could be achieved with a `resumption_offered` and a `resumption_accepted` / `resumption_rejected` event.",
          "createdAt": "2024-10-21T09:15:20Z",
          "updatedAt": "2024-10-21T09:15:20Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU1MDkwNTI3Mzg=",
      "title": "Lacking a way to indicate ALPN list for client",
      "url": "https://github.com/quicwg/qlog/issues/28",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "Currently, we can log a list of supported ALPN values for the server in \"server_listening\" and log the finally selected ALPN in \"parameters_set\". However, we lack a way to log the list of ALPN values the client supports (and offers the server).\r\n\r\nOptions:\r\n- add `alpn_values?: Array<string> // ALPN values offered by the client / received by the server. Use parameters_set to log the actually selected alp` to \"connection_started\"\r\n- make \"alpn\" in \"parameters_set\" an array instead of a string\r\n\r\nI personally prefer the 1st option, since the second doesn't match the semantics of \"set\" (since it would be emitted twice) and logging the negotiation options should be optional in a \"Base\" (while the final value is in a \"Core\" event).\r\n\r\nCC @jlaine ",
      "createdAt": "2019-10-18T12:35:44Z",
      "updatedAt": "2020-11-03T11:51:22Z",
      "closedAt": "2020-11-03T11:51:21Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "The first option is fine. It is nice to distinguish between proposal and results.\r\nI could see for example:\r\n```\r\n\"alpn_values\": [ \"h3-27\", \"hq-27\", \"h3-25\", \"hq-25\" ],\r\n```\r\nAnd later:\r\n```\r\n\"alpn\": \"h3-27\",\r\n```\r\nBut there a few issues. For example, what happens if the qlog entry contains both `alpn_values` and `alpn`?",
          "createdAt": "2020-03-08T04:31:02Z",
          "updatedAt": "2020-03-08T04:33:46Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I would prefer something like `proposed_alpn` instead of `alpn_values`, to emphasize that this is a proposal. This also has a nice way to solve the `proposed_alpn` vs `alpn` issues. For example, if a server logs:\r\n```\r\n\"proposed_alpn\": [ \"h3-27\", \"hq-27\", \"h3-25\", \"hq-25\" ],\r\n\"alpn\": \"h3-27\",\r\n```\r\nThat can be clear understood as \"the client proposed these 4 values, and the server selected the 1sr one\"\r\n",
          "createdAt": "2020-03-08T04:34:50Z",
          "updatedAt": "2020-03-08T04:35:24Z"
        },
        {
          "author": "jlaine",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the idea of strictly distinguishing offer values and the negotiated one. Alternative possible names (no strong feelings about this):\r\n\r\n```\r\n\"alpn_offer\": [\"a\", \"b\", \"c\"]\r\n\"alpn_answer\": \"a\"\r\n```",
          "createdAt": "2020-03-08T11:13:13Z",
          "updatedAt": "2020-03-08T11:13:28Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added a separate `alpn_information` event for this. Not sure this is the best approach overall, but will see. Discussion on this continues in #85. ",
          "createdAt": "2020-11-03T11:51:21Z",
          "updatedAt": "2020-11-03T11:51:21Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU1MjAzNTE4MjY=",
      "title": "Utf-8",
      "url": "https://github.com/quicwg/qlog/issues/29",
      "state": "CLOSED",
      "author": "mocsy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Draft 01 doesn't specify character encoding, but the ts files work with utf-8, don't they?\r\nI propose to standardize that choice as well.",
      "createdAt": "2019-11-09T07:35:27Z",
      "updatedAt": "2020-09-05T16:12:20Z",
      "closedAt": "2020-09-05T16:12:20Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Excellent point, I agree the encoding should be defined. ",
          "createdAt": "2019-11-09T07:38:34Z",
          "updatedAt": "2019-11-09T07:38:34Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU1MjQ4MjY3Nzg=",
      "title": "consider moving to a binary format",
      "url": "https://github.com/quicwg/qlog/issues/30",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I just started working on implementing qlog in quic-go. Maybe it's because I'm still fairly unfamiliar with qlog, but I feel like encoding things in JSON leads to some awkward hacks. Examples of these are:\r\n* A lot of numbers are encoded as strings, e.g. stream offset or packet numbers. I assume this is because JSON doesn't properly handle uint64s (or does it?).\r\n* IP addresses are encoded as strings. If that means they're supposed to be encoded in the human-readable encoding (with . and :), that's ambiguous for IPv6 addresses. Really, IP addresses should be a byte array.\r\n* (Raw) packet data is supposed to be hex encoded, which greatly increases the log size.\r\n* Some fields are defined as enums, whereas other fields that just have a few options are encoded as strings. Examples are the `stream_side` (\"sending\" or \"receiving\") and `stream_type` (\"unidirectional\" or \"bidirectional\"), which are both string fields.\r\n\r\nI'm not sure if I like trick to save bytes on the `events` by first defining the `event_fields` and then using a list instead of an object to encode the `events`. To me, this feels more like a hack to work around the shortcomings of JSON, namely the repetition of the field labels when using objects.\r\nAs far as I can see, a binary encoding scheme would be able to provide a type-safe representation here without repeating the field labels (and blowing up the file size), as long as it's possible to define some `common_fields` for a connection.\r\n\r\nA protobuf-based logging format (This is just a suggestion. Protobufs are the thing I'm most familiar with, maybe there are better choices out there.) would resolve the encoding ambiguities I listed above, because we'd be able to make use of a strong typing system, which would allow us to completely eliminate the use of `string`s (except for places where things actually are strings, e.g. CONNECTION_CLOSE reason phrases). Furthermore, it would greatly simplify implementing qlog: Just fill in the corresponding fields in the Protobuf messages, call `Marshal()`, and you're done. No need to manually define dozens of logging structs and make sure they're correctly serialized into qlog's flavor of JSON.",
      "createdAt": "2019-11-19T07:30:57Z",
      "updatedAt": "2020-09-05T16:22:44Z",
      "closedAt": "2020-09-05T16:22:44Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Talking about this with @nibanks, he would primarily like this for larger traces (he has logs of several 100s of megabytes) and for integration with other tools (like https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-analyzer).\r\n\r\nHe suggests https://diamon.org/ctf/ as one possible format (though, at first glance, this doesn't have a JavaScript parser somewhere). ",
          "createdAt": "2020-01-07T16:05:08Z",
          "updatedAt": "2020-01-07T16:05:08Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "There is related experience with DNS log formats. In particular, look at the CBOR encoding of DNS logs proposed in RFC 8618, https://datatracker.ietf.org/doc/rfc8618/. They started from PCAP, but there was a practical issue with managing huge PCAP files. The first attempt was to just try compress the binary, but they ended up with a more structured approach. The logical syntax follows the \"natural\" repetitions in the data, managing to get for example DNS names encoded just once, and then represented by indices in the tables of names. Then they encode the \"syntactically organized\" data in CBOR (binary JSON), and they apply compression on top of that.\r\n\r\nThe main value of the logical syntax comes when processing logs. For example, I observed a factor 50 performance gain between doing DNS statistics directly on the PCAP and doing the same statistics on the logical CBOR data, due to both reduced IO with shorter data, and more compact code following logical references.\r\n\r\nI suspect there is something similar hiding in the Quic traces.",
          "createdAt": "2020-02-26T01:05:34Z",
          "updatedAt": "2020-02-26T01:05:34Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema that's some very interesting stuff that I wasn't aware of yet, thanks!",
          "createdAt": "2020-02-26T09:51:43Z",
          "updatedAt": "2020-02-26T09:51:43Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Talking about it some more with @nibanks, he states:\r\n\r\n> I'd prefer something that is light-weight and doesn't depend on yet another thing (protobuf). Or something that exists and is light weight to implement a parser for from scratch\r\n\r\n@LPardue did some initial tests with CBOR and found the file size gains not to really outweigh compressed JSON. \r\n\r\nI am currently experimenting with a few binary scheme options to get a first feel for potential file size and (de)serialization gains. That should give us some additional data to work from. ",
          "createdAt": "2020-03-17T15:24:30Z",
          "updatedAt": "2020-03-17T15:24:30Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "To be clear I am no CBOR expert. All I did for my serializing code was substitute out serde_json for serde_cbor and compare the resulting output. CBOR shaved off 10% of identity encoding, gzipped-json shaved off about 40%.\r\n\r\nAFAIK It is possible to profile CBOR to be more efficient (e.g. https://tools.ietf.org/html/draft-raza-ace-cbor-certificates-04) but that is beyond my skillset.\r\n",
          "createdAt": "2020-03-17T23:06:52Z",
          "updatedAt": "2020-03-17T23:06:52Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I am quite familiar with the work on using CBOR to record DNS traces in RFC 8618. The captures were originally in PCAP, but PCAP gets very large files. They looked at a set of variations:\r\n\r\n|  Format      | File size | Comp. | Comp. size |   RSS | User time |\r\n| --------- | --------- | ----- | ---------- | ----- | --------- |\r\n| PCAP        |    661.87 | snzip |     212.48 |  2696 |      1.26 |\r\n|             |           | lz4   |     181.58 |  6336 |      1.35 |\r\n|             |           | gzip  |     153.46 |  1428 |     18.20 |\r\n|             |           | zstd  |      87.07 |  3544 |      4.27 |\r\n|             |           | xz    |      49.09 | 97416 |    160.79 |\r\n|             |           |       |            |       |           |\r\n| JSON simple |   4113.92 | snzip |     603.78 |  2656 |      5.72 |\r\n|             |           | lz4   |     386.42 |  5636 |      5.25 |\r\n|             |           | gzip  |     271.11 |  1492 |     73.00 |\r\n|             |           | zstd  |     133.43 |  3284 |      8.68 |\r\n|             |           | xz    |      51.98 | 97412 |    600.74 |\r\n|             |           |       |            |       |           |\r\n| Avro simple |    640.45 | snzip |     148.98 |  2656 |      0.90 |\r\n|             |           | lz4   |     111.92 |  5828 |      0.99 |\r\n|             |           | gzip  |     103.07 |  1540 |     11.52 |\r\n|             |           | zstd  |      49.08 |  3524 |      2.50 |\r\n|             |           | xz    |      22.87 | 97308 |     90.34 |\r\n|             |           |       |            |       |           |\r\n| CBOR simple |    764.82 | snzip |     164.57 |  2664 |      1.11 |\r\n|             |           | lz4   |     120.98 |  5892 |      1.13 |\r\n|             |           | gzip  |     110.61 |  1428 |     12.88 |\r\n|             |           | zstd  |      54.14 |  3224 |      2.77 |\r\n|             |           | xz    |      23.43 | 97276 |    111.48 |\r\n|             |           |       |            |       |           |\r\n| PBuf simple |    749.51 | snzip |     167.16 |  2660 |      1.08 |\r\n|             |           | lz4   |     123.09 |  5824 |      1.14 |\r\n|             |           | gzip  |     112.05 |  1424 |     12.75 |\r\n|             |           | zstd  |      53.39 |  3388 |      2.76 |\r\n|             |           | xz    |      23.99 | 97348 |    106.47 |\r\n|             |           |       |            |       |           |\r\n| JSON block  |    519.77 | snzip |     106.12 |  2812 |      0.93 |\r\n|             |           | lz4   |     104.34 |  6080 |      0.97 |\r\n|             |           | gzip  |      57.97 |  1604 |     12.70 |\r\n|             |           | zstd  |      61.51 |  3396 |      3.45 |\r\n|             |           | xz    |      27.67 | 97524 |    169.10 |\r\n|             |           |       |            |       |           |\r\n| Avro block  |     60.45 | snzip |      48.38 |  2688 |      0.20 |\r\n|             |           | lz4   |      48.78 |  8540 |      0.22 |\r\n|             |           | gzip  |      39.62 |  1576 |      2.92 |\r\n|             |           | zstd  |      29.63 |  3612 |      1.25 |\r\n|             |           | xz    |      18.28 | 97564 |     25.81 |\r\n|             |           |       |            |       |           |\r\n| CBOR block  |     75.25 | snzip |      53.27 |  2684 |      0.24 |\r\n|             |           | lz4   |      51.88 |  8008 |      0.28 |\r\n|             |           | gzip  |      41.17 |  1548 |      4.36 |\r\n|             |           | zstd  |      30.61 |  3476 |      1.48 |\r\n|             |           | xz    |      18.15 | 97556 |     38.78 |\r\n|             |           |       |            |       |           |\r\n| PBuf block  |     67.98 | snzip |      51.10 |  2636 |      0.24 |\r\n|             |           | lz4   |      52.39 |  8304 |      0.24 |\r\n|             |           | gzip  |      40.19 |  1520 |      3.63 |\r\n|             |           | zstd  |      31.61 |  3576 |      1.40 |\r\n|             |           | xz    |      17.94 | 97440 |     33.99 |\r\n\r\nYou can see that there are some differences between various algorithms. JSON clearly gets bigger sizes there than the binary alternatives, even after compression. But the biggest differences come from switching from what they call \"simple\" to what they call \"block\".\r\n\r\nThe simple alternative is pretty similar to the current Qlog. Each DNS transaction is represented by a corresponding record in JSON, CBOR, Avro or protobuf. In contrast, the \"block\" format starts by building tables of objects seen in multiple records: table of DNS names, table to record values, etc. Then the individual PCAP records are represented by \"block records\" which instead of listing DNS names simply list the index of the name in the table of names. You can think of that as a \"logical compression\", and it does reduces the size of the recording by a factor 10x. After that, they can still apply compression.\r\n\r\nThe real beauty of the block format comes when processing the data in back end programs. Compare:\r\n```\r\nuncompress < pcap.xz | process-pcap\r\n```\r\nTo:\r\n```\r\nuncompress < cbor.xz | process-cbor\r\n```\r\nIn the cbor alternative, there are about 10 times fewer data piped into the analysis program than in the pcap alternative. That's a much lower IO load. On top of that, since the cbor data is structured in blocks, parsing and processing is much easier, resulting in a much lower CPU load. In a project that I was involved with, replacing process-pcap by process-cbor made us run 40 times faster!\r\n\r\nAlso note that there are no practical differences between the various binary alternatives. yes, +- 10% here or there, but compared to a factor 40 that's really in the noise.",
          "createdAt": "2020-03-18T00:58:46Z",
          "updatedAt": "2020-03-18T00:58:46Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks a lot for that @huitema. Doing something similar to the \"block format\" would be trivial for qlog as well. However, it mismatches with how I thought general purpose compression works in my head... don't those algorithms also build that type of lookup-table on the fly? I will test with manual block formats as well and see what that gives.\r\n\r\nAnother interesting ref from @martinthomson https://tools.ietf.org/html/draft-mattsson-tls-cbor-cert-compress-00",
          "createdAt": "2020-03-18T11:10:58Z",
          "updatedAt": "2020-03-18T11:10:58Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So I've been doing some tests of my own to figure out the best approach to this for qlog.\r\n\r\nI've created converter scripts (see https://github.com/quiclog/pcap2qlog/tree/binary/src/converters) that use a lookup table/dictionary instead of repeating values, one that cbor encodes the files and a (rudimentary) protobuf schema. The dictionary is currently fully dynamic and stored inside the resulting file, but this can obviously be improved by having a static shared dictionary with a dynamic part for just the field values (much like QPACK and Chrome's NetLog). \r\n\r\nI've then also looked at various compression schemes (https://github.com/quiclog/pcap2qlog/blob/binary/src/scripts/comparisons/compare.sh) (xz, gzip, brotli, zstd, lz4), focusing mainly on the schemes most often seen on the web for on-the-fly compression (gzip 6 and brotli 4).\r\n\r\nFull results can be found at https://gist.github.com/rmarx/49bb14f83157d9fe59fb40e7c05b1f3f, a bit nicer representation in the following image (sizes for traces in which a 500MB or 100MB file were downloaded from the lsquic public endpoint). The blue value is the reference point for the percentages, green is the \"best in class\" for that row:\r\n\r\n![2020-04-22 11_27_11-results xlsx - Excel](https://user-images.githubusercontent.com/2240689/79965403-410ed380-848c-11ea-9d66-b1a90bd4bc72.png)\r\n\r\n\r\nMain takeaways for me:\r\n1. protobuf is the smallest, but not by a huge margin compared to dictionary+cbor, especially not when compression is used.\r\n2. compression alone saves massively, even on the original JSON file or direct CBOR version of that\r\n3. protobuf without compression is still quite large (23% of original), so I'd reckon you'd always use compression for storage/transmission anyway? \r\n\r\nNext to these tests, we also ran a survey among QUIC experts (implementers and researchers), on which we got replies from 28 participants (thanks everyone!). Part of the survey was to ask how important they felt features like \"fast (de)serialization, small file size, flexibility (e.g., easily add new event types), grep-ability\" were. The full results will be posted soon (are part of a publication we're preparing), but the gist of it is:\r\n\r\n![2020-04-22 11_37_40-QUIC and HTTP_3 Debugging Survey - March 2020 - Google Forms](https://user-images.githubusercontent.com/2240689/79966456-c050d700-848d-11ea-9113-d9c2a230d8ab.png)\r\n\r\nMy interpretation:\r\n1. Flexibility is the major selling point across the board. I personally believe moving to something like protobuf sort of robs us from that (much more difficult to add new event types as you have to update the schema)\r\n2. Most don't care too much about (de)serialization performance\r\n3. Small file size was regarded as important, but again not as much as flexibility. \r\n4. grep-ability was also considered an important feature by many\r\n5. easy integration is also a major point and this would be easier with something like protobuf\r\n\r\nFinally, we also talked to Facebook (cc @mjoras), who have been deploying qlog at scale, logging over 30 billion qlog events per day. Compared to their earlier binary format, qlog is about 2-3x larger and takes 50% longer to serialize. Yet, this is quite manageable on the server side, where they log full-string JSON events to a centralized service. On the client, they do find the file-size to be prohibitive to upload granular full qlogs (containing all events they'd like). Yet, Matt was also adamant that they'd rather keep the flexibility of the JSON format than move to a more inflexible binary one. They were considering utilizing compression and writing a custom JSON (de)serializer, optimized for qlog, to help deal with some of the overhead. \r\n\r\n----------------------------------\r\n\r\nSo, presented with those results, my standpoint today is still to keep using JSON as the basis for qlog. I would propose to add the \"dictionary\" setup to the spec though, as an optional optimized mode and also recommend tools to support that (not sure about a default static dictionary at this point though). Furthermore, I'd recommend using cbor if file size is important. \r\n\r\nCompanies that do need more optimizations can write their own protobuf (or equivalent) schema (which I've shown is possible) and then write a post-processor to go to proper JSON qlog for shared tooling. \r\n\r\nStill, feedback on all this is more than welcome of course! @marten-seemann, @martinthomson, @huitema, @LPardue, @nibanks, @mjoras\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-04-22T09:50:22Z",
          "updatedAt": "2020-04-22T09:50:22Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "If we use cbor, does that mean that we can get rid of the `event_fields`? Having implemented a both an encoder as well as a parsing tool, this complicated things quite a bit for me (over just encoding an event as a normal JSON object).",
          "createdAt": "2020-04-22T09:56:02Z",
          "updatedAt": "2020-04-22T09:56:02Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With the latest commit linked above (https://github.com/quiclog/internet-drafts/commit/eb59e69aa0f92031d8a2377575b7328429440061), I feel this issue has been resolved.\r\n\r\nqlog has not moved to a binary format by default, but is now much easier to serialize as one/to define a binary schema for. Some of the reasoning behind that has also been included in the qlog document. ",
          "createdAt": "2020-09-05T16:22:44Z",
          "updatedAt": "2020-09-05T16:22:44Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU1MzA1NzkzNjI=",
      "title": "Typo in path response frame definition",
      "url": "https://github.com/quicwg/qlog/issues/31",
      "state": "CLOSED",
      "author": "mpiraux",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "```\r\n### PathResponseFrame\r\n\r\n~~~\r\nclass PathResponseFrame{\r\n  frame_type:string = \"patch_response\";\r\n\r\n  data?:string;\r\n}\r\n~~~\r\n```\r\n\r\n`patch_response` should be `path_response`.",
      "createdAt": "2019-11-30T13:30:20Z",
      "updatedAt": "2020-09-07T13:29:02Z",
      "closedAt": "2020-09-07T13:29:02Z",
      "comments": []
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWU1NDYzMzIyODQ=",
      "title": "Mention JSON earlier",
      "url": "https://github.com/quicwg/qlog/issues/32",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The fact that qlog is in JSON format is not mentioned until section 3.3.4 of the main logging schema draft.  This should be stated earlier: before any JSON examples are given.",
      "createdAt": "2020-01-07T15:02:10Z",
      "updatedAt": "2020-09-05T16:04:17Z",
      "closedAt": "2020-09-05T16:04:17Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in f5db7cdc8cd0cf37bfe5f1b0b4c54fc56ffc5f28",
          "createdAt": "2020-09-05T16:04:17Z",
          "updatedAt": "2020-09-05T16:04:17Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWU1NDYzMzM5OTQ=",
      "title": "Well-known URI: uppercase or lowercase",
      "url": "https://github.com/quicwg/qlog/issues/33",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Whether ODCID in the well-known URI is uppercase or lowercase should be specified.",
      "createdAt": "2020-01-07T15:05:21Z",
      "updatedAt": "2020-09-01T19:13:38Z",
      "closedAt": "2020-09-01T19:13:38Z",
      "comments": []
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU1NDk5MDA3MzI=",
      "title": "Consolidate repeated padding frames?",
      "url": "https://github.com/quicwg/qlog/issues/34",
      "state": "CLOSED",
      "author": "agrover",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Padding frames contain no information, but when eyeballing a qlog for the start of a connection, they swamp more interesting things.\r\n\r\nIt's a bit of a cheat, given that qlog otherwise is 1:1 between packet contents and logging, but I was wondering if a more compact representation of repeated padding frames might be nice.\r\n\r\nThis is less about qlog file size -- I'm assuming repeated padding entries in json would compress amazingly -- more about human readability.\r\n\r\nI see pros and cons, but wanted to raise it as an issue. Cheers.",
      "createdAt": "2020-01-15T00:45:26Z",
      "updatedAt": "2020-09-07T13:28:39Z",
      "closedAt": "2020-09-07T13:28:39Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm very confused at the moment, because I was sure I had already added this to the editor's draft for version -02, but... apparently not? \r\n\r\nSo yes, I definitely think this is a good idea. At one point, Facebook was logging 1 padding frame for each byte of padding and that was horrendous. \r\n\r\nI thought about just adding a \"length\" field to the padding frame, indicating the amount of bytes padded. Would you agree that's the correct approach? \r\n\r\n",
          "createdAt": "2020-01-15T07:29:55Z",
          "updatedAt": "2020-01-15T07:29:55Z"
        },
        {
          "author": "hawkinsw",
          "authorAssociation": "NONE",
          "body": "> I'm very confused at the moment, because I was sure I had already added this to the editor's draft for version -02, but... apparently not?\r\n> \r\n> So yes, I definitely think this is a good idea. At one point, Facebook was logging 1 padding frame for each byte of padding and that was horrendous.\r\n> \r\n> I thought about just adding a \"length\" field to the padding frame, indicating the amount of bytes padded. Would you agree that's the correct approach?\r\n\r\nThat sounds like a pretty good idea to me. It also seems to \"mirror\" the approach that Wireshark takes?\r\n![Screenshot from 2020-01-15 03-52-38](https://user-images.githubusercontent.com/8715530/72419310-911e2180-374a-11ea-8520-1b8f99a34a12.png)\r\n",
          "createdAt": "2020-01-15T08:53:33Z",
          "updatedAt": "2020-01-15T08:53:33Z"
        },
        {
          "author": "agrover",
          "authorAssociation": "NONE",
          "body": "> I thought about just adding a \"length\" field to the padding frame, indicating the amount of bytes padded. Would you agree that's the correct approach?\r\n\r\nSounds good to me!",
          "createdAt": "2020-01-16T18:48:52Z",
          "updatedAt": "2020-01-16T18:48:52Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU1NTE3NTE3NjI=",
      "title": "Add guidance to server developers",
      "url": "https://github.com/quicwg/qlog/issues/35",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "future-versions"
      ],
      "body": "@marten-seemann asked how to best approach logging from a server's perspective, given that things like version negotiation and stateless retry are not inherently tied to a single connection. We should add some informative guidance on how to best approach this to the spec, depending on how much state you're willing to keep around \r\n\r\nSome options:\r\n\r\n1. low state: keep a separate qlog file for the entire server. This logs vneg, retry, etc.. Then, when a connection is truly accepted, start a new .qlog for the individual connection, containing all events thereafter. The server.qlog can then also contain an event signalling the acceptance of a new connection for later cross-linking between the files.\r\n2. low state: keep a single huge qlog file for everything, using the \"group_id\" field to allow later de-multiplexing into separate connections (I believe quant does this atm)\r\n3. stateful: if you already track vneg/retry and link them up with the final connection, you can output them in the per-connection qlog file as well\r\n\r\nMaybe also shortly talk about some of the trade-offs in each option. Also talk about how to approach server-level events like server_listening and packet_dropped in separate scenarios. ",
      "createdAt": "2020-01-18T10:33:53Z",
      "updatedAt": "2023-03-02T10:00:27Z",
      "closedAt": "2023-03-02T10:00:27Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I lean on the side of minimally and clearly identifying the challenges and maybe signpost some features and leave it up to implementers to figure out how to address this. They can always push back later in the specification lifecycle is something is deemed missing.",
          "createdAt": "2022-09-07T23:15:40Z",
          "updatedAt": "2022-09-07T23:15:40Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWU1NTE3NTUxNTg=",
      "title": "Require specific encoding for string fields",
      "url": "https://github.com/quicwg/qlog/issues/36",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For example, NewTokenFrame doesn't really need a length field if the encoding of the token is specified (e.g., if it is hex-encoded, byte-length is 2x token.length).\r\n\r\nWe already indicate hex-encoding at other places in the text (e.g., for version), maybe it's a good idea to enforce this across the board (then also specificy whether it should have 0x prefix or not etc. + examples).\r\n\r\nThanks to @marten-seemann for reporting",
      "createdAt": "2020-01-18T11:08:45Z",
      "updatedAt": "2020-09-05T16:23:16Z",
      "closedAt": "2020-09-05T16:23:16Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "This also applies to the NEW_CONNECTION_ID frame.",
          "createdAt": "2020-01-18T14:43:29Z",
          "updatedAt": "2020-01-18T14:43:29Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Could this be as easy as saying that all byte-values are hex-encoding (omitting the 0x) somewhere in the introduction? Then this would apply to connection IDs, Retry tokens, NEW_TOKEN tokens, stateless reset tokens, etc.",
          "createdAt": "2020-07-08T09:01:57Z",
          "updatedAt": "2020-07-08T09:01:57Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU1NTE3NTc4MjA=",
      "title": "missing HANDSHAKE_DONE frame",
      "url": "https://github.com/quicwg/qlog/issues/37",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-01-18T11:35:17Z",
      "updatedAt": "2020-01-18T15:31:42Z",
      "closedAt": "2020-01-18T15:31:42Z",
      "comments": []
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU1NTE3ODA4OTQ=",
      "title": "Be more consistent in numbers vs strings for (potentially) large numbers (varints)",
      "url": "https://github.com/quicwg/qlog/issues/39",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Now, we only make varints strings if it's likely they will go over 2^53 (JSON's / JavaScript's number limit). \r\n\r\nFor example, this means error codes are just numbers, even though they are varints, as it's unlikely to see a very large error code. However, for fields that are greased (e.g., see https://github.com/quicwg/base-drafts/pull/3360) they could be larger and a number no longer suffices.\r\n\r\nSee also dcil and scil in PacketHeader, which could be numbers but are now strings.\r\n\r\nMore in general: maybe it's best to simply allow both for all number fields and have the tools figure it out? ",
      "createdAt": "2020-01-18T15:07:33Z",
      "updatedAt": "2020-09-07T13:19:00Z",
      "closedAt": "2020-09-07T13:19:00Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "For me it would be very unnatural to treat Quic integers (varint encoded) as strings instead of numbers. Not impossible of course, one could always add quotes. But very unnatural.\r\n",
          "createdAt": "2020-02-26T00:54:29Z",
          "updatedAt": "2020-02-26T00:54:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "An approach some people are using for extension experimentation IS to pick large values for frame type, settings, stream types, etc. ",
          "createdAt": "2020-05-25T13:03:08Z",
          "updatedAt": "2020-05-25T13:03:08Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@LPardue people do pick large numbers for experimentation, but the numbers are typically 2 bytes:\r\n```\r\nFrame types:\r\n    ack_frequency = 0xAF,\r\n    time_stamp = 757\r\nTP:\r\n    test_large_chello = 3127,\r\n    enable_loss_bit_old = 0x1055,\r\n    enable_loss_bit = 0x1057,\r\n    min_ack_delay = 0xDE1A,\r\n    enable_time_stamp = 0x7157\r\n```\r\nEven if we add another byte for versioning, traditional JSON will work just fine.",
          "createdAt": "2020-05-25T14:39:55Z",
          "updatedAt": "2020-05-25T14:39:55Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The plan is to switch away from JSON/TypeScript notation in the draft and use explicit type annotations (e.g., uint32, uint64, etc.).\r\n\r\nThen I'd add something stating that, if using a JSON format, you should decide yourself between a) encoding 64-bit values as strings or b) hope they won't be larger than 2^53 and log them as numbers. Tools would be strongly advised to support both string and number variants of these fields. ",
          "createdAt": "2020-05-25T15:02:24Z",
          "updatedAt": "2020-05-25T15:03:02Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "and PRIORITY_UPDATE is using `0x1CCB8BBF1F0700` :)\r\n\r\nIt will be more difficult to make a general purpose library that can do what Robin suggests on the serialization side. It might also make it hard on the deserialization side in my specific implementation. \r\n\r\nThat said, I really dislike the arbitrary schema inconstencies that exist today. So on balance I look forward to the proposed approach.",
          "createdAt": "2020-05-25T15:19:41Z",
          "updatedAt": "2020-05-25T15:19:41Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If only we knew someone from the H3 Priorities team that could help mitigate that weirdly large Frame identifier... ",
          "createdAt": "2020-05-25T15:25:30Z",
          "updatedAt": "2020-05-25T15:25:30Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU1NTE4Njk2MDE=",
      "title": "packet_size doesn't belong in the PacketHeader, but PacketType does",
      "url": "https://github.com/quicwg/qlog/issues/40",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "In my interpretation, the `PacketHeader` is a QUIC packet header. Therefore, it should contain the QUIC packet type.\r\nHowever, the `packet_size` (as opposed to the `payload_length`, which is the length of the QUIC payload e.g. in a coalesced packet), is a property of the UDP packet, and therefore should a property of the `packet_sent` / `packet_received` event.",
      "createdAt": "2020-01-19T05:27:36Z",
      "updatedAt": "2020-11-02T16:57:19Z",
      "closedAt": "2020-11-02T16:57:19Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While I -think- I agree with the general sentiment, this is a major departure from the current setup as implemented in most qlog setups. Additionally, many qvis visualizations actively use these fields.\r\n\r\nI propose to keep the issue and PR open until when I can update qvis to deal with this change, so that I don't forget to do just that. Definitely before draft-02 lands of course.\r\n\r\nAdditionally, `packet_size` is intended to mean the entire size of the QUIC packet (header + payload), not the UDP datagram size (which can span multiple coalesced QUIC packets as you indicate). I felt the separate packet_size was needed to get an estimate of the header size, since that can differ quite a bit depending on the chosen encodings, pn-length etc. That does bring up the question if we need a `datagram_size/length` outside of the `datagram_*` events as well (though I personally would say not).",
          "createdAt": "2020-01-19T10:31:18Z",
          "updatedAt": "2020-01-19T10:31:18Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I initially moved `packet_size` to `packet_sent` and `packet_received`, which was the simplest solution. \r\n\r\nHowever, when considering other issues around indicating packet and frame sizing, I ended up deciding to go for a generalized solution by using a shared RawInfo struct. This means that packet lengths are now logged as `packet_sent:raw.length` instead of `packet_sent:packet_size`. This isn't as clear, I agree, but it is consistent with how we log lengths for other things in qlog, which was more important for me at this time. Given that implementers have to move the packet_size field out of PacketHeader anyway, it shouldn't matter too much if they move it to `raw.length` I'd expect. ",
          "createdAt": "2020-11-02T16:57:19Z",
          "updatedAt": "2020-11-02T16:57:19Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU1NTE5MDYyODU=",
      "title": "Think about usage in proxies",
      "url": "https://github.com/quicwg/qlog/issues/42",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "future-versions"
      ],
      "body": "If qlog is used on a proxy, the question becomes what vantage_point it should use for its traces, since it's now simultaneously accepting and opening connections, and thus behaves as both a client and a server.\r\n\r\nOne approach would be to have (two) separate traces with separate vantage_points, but if there is a 1-to-1 mapping between client -> proxy -> origin connections, it -might- make sense to log everything into one trace (though I would need to reflect more on this). \r\n\r\nIn this latter case, it might make sense to add a \"role\" or \"vantage_point\" indication to events like `connection_started`.\r\n\r\nThanks to @hawkinsw for reporting.\r\nMaybe @LPardue has some comments, given his experience with the proxy-ing use case? ",
      "createdAt": "2020-01-19T11:08:11Z",
      "updatedAt": "2022-09-29T14:01:30Z",
      "closedAt": "2022-09-29T14:01:30Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I'd lean on the side of do-nothing right now. Why? Because rfc 9000 doesn't even mention proxies.\r\n\r\nWe could try to build a design around how HTTP proxying works. In HTTP, proxies are both a server and a client. But trying to be overly helpful here in qlog risks snowballing due to various forms of proxy and how they are deployed. E.g., a common deployment strategy is to chain proxies with different connection characteristics that carry HTTP semantics. You can quickly turn what sounds like a simple 1:1 pipeline into a many:1 or 1:many. Typically this sort of thing can be dealt with via distributed tracing, which depends on a common identifier being propagated around and used to stich back together things. \r\n\r\nProxing with QUIC using MASQUE approaches is prevalent. I'd personally like to do something better there. But primarily a proxy is converting a QUIC stream into a TCP or UDP transport, which are outside our focus right now. If your're tunneling QUIC via CONNECT, what actually tends to happen is that the client produces two `client` role logs, and the server produces just one `server` role log.\r\n\r\nIn closing, I'd want to hear real proxy operator pain points or solutions for qlog. Otherwise we'd be designing in a vacuum, or designing something that is not of any real use.\r\n",
          "createdAt": "2022-09-07T23:31:01Z",
          "updatedAt": "2022-09-07T23:31:01Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @LPardue that this should live in a qlog extension. Maybe CONNECT-UDP would be a good candidate to define such an extension, once the qlog RFC is on its way.",
          "createdAt": "2022-09-08T07:18:09Z",
          "updatedAt": "2022-09-08T07:18:09Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed with both to close with no action for now.\r\nI'd say since e.g., Cloudflare is using qlog in this proxied setting already, it's probably somewhat possible to employ it usefully today and can be extended to be more ergonomic later. ",
          "createdAt": "2022-09-29T14:01:29Z",
          "updatedAt": "2022-09-29T14:01:29Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU1NTI3ODIwOTc=",
      "title": "Add connection_closed or connection_dropped event",
      "url": "https://github.com/quicwg/qlog/issues/43",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "Currently, we rely on packet_* with a CONNECTION_CLOSE frame, but that's not always enough. E.g., the server can decide to drop a connection after a long timeout without sending a CONNECTION_CLOSE. Or, we might want additional information of when a connection is effectively dropped completely (according to @marten-seemann: is supposed to happen 3 PTOs after it is retired)\r\n\r\nMaybe a connection_closed event with a trigger field suffices? Should this be importance Base or Extra?",
      "createdAt": "2020-01-21T10:23:18Z",
      "updatedAt": "2020-11-02T20:14:21Z",
      "closedAt": "2020-11-02T20:14:21Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So I'm currently breaking my head on this one as there are a lot of aspects to closing connections in QUIC:\r\n\r\n1. there are three different states: closing, draining, actually closed\r\n2. there are many different reasons for \"closing\": idle timeout/handshake timeout, \"immediate close\", stateless reset, no overlapping versions, ...\r\n3. within immediate close, there are different error spaces: connection errors, application errors (which don't always reflect the actual internal error properly)\r\n\r\nCurrently (see draft02 branch), these things are kind of spread out across three different events:\r\n- connectivity:connection_state_updated\r\n- generic:connection_error\r\n- generic:application_error\r\n\r\nCombining this into a single `connection_closed` event with all that flexibility would thus lead to some serious duplication across the board..., not to mention a very complex event\r\n\r\nHowever, looking at https://github.com/lucas-clemente/quic-go/pull/2501/files, which seems the main use case for @marten-seemann at least, all he really cares about is logging a free-form string \"reason\" for a connection_closed event, as well as having a separate event type so it's easy to query just the `connection_closed`, instead of having to sift through `connection_state_updated`. \r\n\r\nSo, my proposal would be to add `connection_closed` as a quite high-level event, mainly useful for manual interpretation, referring to the other existing events if the need arises to log more fine-grained info. \r\n\r\nThus, the proposed design of `connection_closed` for draft-02:\r\n\r\n```\r\n{\r\n        owner?:\"local\"|\"remote\",\r\n\r\n        connection_error_code?:uint32,\r\n        application_error_code?:uint32,\r\n     \r\n        reason?:string\r\n}\r\n\r\nTriggers:\r\n* clean\r\n* handshake_timeout\r\n* idle_timeout\r\n* error // basically the \"immediate close\" case\r\n* stateless_reset\r\n* version_mismatch\r\n```\r\n(reminder, in qlog, each event has an implicit trigger field, which can contain any string value, so other triggers would be valid here as well)\r\n\r\nI'm not particularly happy with this design, but it's better than others I could come up with.\r\n\r\nDoes this suit your use case @marten-seemann? Can you let me know by tomorrow evening (2nd November)? Thanks! \r\n\r\n",
          "createdAt": "2020-11-01T15:39:58Z",
          "updatedAt": "2020-11-01T15:39:58Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Why do we need `generic:connection_error` and a `generic:application_error`?",
          "createdAt": "2020-11-02T08:07:26Z",
          "updatedAt": "2020-11-02T08:07:26Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merged connection_error and application_error with connection_closed, as that indeed makes more sense here. \r\n\r\nClosing for now, open to revisiting this for draft-03. ",
          "createdAt": "2020-11-02T20:14:21Z",
          "updatedAt": "2020-11-02T20:14:21Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWU1NTI3ODM1MDc=",
      "title": "Revise design of dual-endpoint events",
      "url": "https://github.com/quicwg/qlog/issues/44",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "current-version"
      ],
      "body": "Currently, we have some events that are used both for indicating changes in the local as well as the remote endpoint. An example is parameters_set, which logs both connection params we set locally, as the ones we get from the other side. parameters_set uses an \"owner\" field to disambiguate between these two cases. \r\n\r\nHowever, other events with similar purpose, like connection_id_updated, use another approach (src_ vs dst_ prefixes). We should decide on a singular consistent approach (currently leaning towards \"owner\" field myself, as it is the most flexible)",
      "createdAt": "2020-01-21T10:25:48Z",
      "updatedAt": "2024-02-19T08:55:06Z",
      "closedAt": "2024-02-19T08:55:06Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Is this still relevant?",
          "createdAt": "2022-09-07T23:31:49Z",
          "updatedAt": "2022-09-07T23:31:49Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given that there have been no further complaints/remarks on this and imo the split approach is clear enough, closing without action for now. ",
          "createdAt": "2024-02-19T08:55:06Z",
          "updatedAt": "2024-02-19T08:55:06Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU1NTI3ODQ2MDM=",
      "title": "Reduce importance of connection_id_updated",
      "url": "https://github.com/quicwg/qlog/issues/45",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, it is a Core event.\r\nHowever, as pointed out by @marten-seemann, not all implementations track when the remote endpoint changes their CID (e.g., looks when they first receive a packet with a new CID). In those cases, they might decide to take the log filesize hit by just logging the CID for each incoming PacketHeader.\r\n\r\nAs such, the connection_id_updated should probably be a Base event, with guidance on when to use which option.",
      "createdAt": "2020-01-21T10:27:41Z",
      "updatedAt": "2020-09-07T13:24:26Z",
      "closedAt": "2020-09-07T13:24:26Z",
      "comments": []
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU1NTM2MzIzNjY=",
      "title": "Updates for draft-25",
      "url": "https://github.com/quicwg/qlog/issues/46",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "future-versions"
      ],
      "body": "For now, there's just one I'm aware of:\r\n\r\nparameters_set.idle_timeout was renamed to .max_idle_timeout",
      "createdAt": "2020-01-22T15:54:15Z",
      "updatedAt": "2021-08-18T09:53:14Z",
      "closedAt": "2021-08-18T09:53:14Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "There was also HANDSHAKE_DONE, but we added that already.",
          "createdAt": "2020-01-22T17:44:02Z",
          "updatedAt": "2020-01-22T17:44:02Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "maybe this was flagged a while back but `HTTP3EventType:dependency_update`, since it looks like there will be no dpendency-based prioritization in HTTP/3 core probably want to remove it",
          "createdAt": "2020-01-24T12:06:38Z",
          "updatedAt": "2020-01-24T12:07:26Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue I think that's a specific issue for the TypeScript definitions that's not in the qlog draft itself? I've fixed it for ts here: https://github.com/quiclog/qlog/commit/cf4af5b227289fb32cde9dc9e39ee6a963a08384",
          "createdAt": "2020-01-24T12:38:25Z",
          "updatedAt": "2020-01-24T12:38:33Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU1NTQ3MTk0ODQ=",
      "title": "Revisit the category for generic events",
      "url": "https://github.com/quicwg/qlog/issues/47",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "We have a number of \"generic\" events in the draft (section 7, General error, warning and debugging definitions). These currently have their own categories: error, warning, info, debug, verbose, simulation. This is a bit awkward, since most of these only have a single event type. \r\n\r\nIt might be a good idea to group these under a single category, e.g., \"generic\" or \"general\" or \"textual\" or... (or maybe 2: generic and simulation). Another option would be to define a new event field called `log_level` next to category (but that would increase overhead, as now we're essentially squatting on the category to provide that). \r\n\r\nThe purpose of these events (sans simulation) is to allow one to replace the default textual logging with qlog completely (e.g., everything you now send to stdout/stderr with printf() would go into these kinds of events).\r\n\r\nThanks to @LPardue for reporting.",
      "createdAt": "2020-01-24T12:52:37Z",
      "updatedAt": "2020-11-01T13:04:11Z",
      "closedAt": "2020-11-01T13:04:11Z",
      "comments": [
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "I would vote for \"generic\" or \"general\".",
          "createdAt": "2020-08-06T00:27:00Z",
          "updatedAt": "2020-08-06T00:27:00Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWU1NTYxMDAyMzI=",
      "title": "Reference the JSON specification",
      "url": "https://github.com/quicwg/qlog/issues/48",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently JSON is mentioned, but not officially referenced.\r\nMake it clear that formats unspecified in the qlog draft should be taken from JSON spec (e.g., that booleans should be spelled `true` and `false`)\r\n\r\nthanks @hawkinsw for reporting",
      "createdAt": "2020-01-28T10:01:15Z",
      "updatedAt": "2020-09-05T16:23:51Z",
      "closedAt": "2020-09-05T16:23:51Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Was fixed in f5db7cdc8cd0cf37bfe5f1b0b4c54fc56ffc5f28",
          "createdAt": "2020-09-05T16:23:51Z",
          "updatedAt": "2020-09-05T16:23:51Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "MDU6SXNzdWU1NTk2NjMwNTQ=",
      "title": "More fine-grained connection states",
      "url": "https://github.com/quicwg/qlog/issues/49",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "Per @huitema:\r\n\r\n` I would split the active state between \"start\" and \"confirmed\", and the handshake start on the server side between \"received a request\" and \"address validated\".`\r\n\r\n```\r\nThe server will go through the \"anti dos mitigation\" phase until the client's address is validated. That's important, because the server behavior in that state is restricted. Once it has sent all the handshake packets, the server goes to a \"false start\" phase in which it can send 1-RTT packets but (should) not receive. And then once it receives the client finished and sends the \"handshake done\", it moves to a confirmed state, at which point it can deal with migration and key update.\r\n\r\nClient is kind of the same. It goes from initiating to handshake, then to an \"almost ready\" phase after sending the \"client finished\" and getting the 1rtt keys. But it will only become really active once it receives the \"handshake done\" or an equivalent.\r\n```",
      "createdAt": "2020-02-04T11:40:06Z",
      "updatedAt": "2020-11-03T11:50:32Z",
      "closedAt": "2020-11-03T11:50:32Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Defining connection states is hard, but here is what I would suggest:\r\n\r\n1) Client side, up to the \"ready\" state:\r\n* attempted (Initial sent, no handshake keys received yet)\r\n* handshake (handshake keys received)\r\n* almost ready (1RTT keys received, but handshake done not received yet)\r\n* ready (or active) (handshake done received from server, or equivalent)\r\n2) Server side:\r\n* received (initial received)\r\n* validated (client address has been verified)\r\n* handshake (handshake packets received from client, handshake in progress)\r\n* false start (1RTT keys write received, but handshake not complete yet)\r\n* ready (handshake complete, handshake done sent)\r\n3) Both sides:\r\n* draining (close connection packet sent or received, waiting for some time)\r\n* disconnected (done with this connection)\r\n\r\n",
          "createdAt": "2020-03-08T23:24:39Z",
          "updatedAt": "2020-03-08T23:24:39Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I like the addition of `validated`. That can be really useful when debugging the early handshake stages.\r\n\r\n> * almost ready (1RTT keys received, but handshake done not received yet)\r\n> * ready (or active) (handshake done received from server, or equivalent)\r\n\r\nThis could be `handshake_completed` and `handshake_confimred`. Both of them would work for client as well as the server.\r\n\r\n> false start (1RTT keys write received, but handshake not complete yet)\r\n\r\nNot sure if we need this. We already have a `key_updated` event.",
          "createdAt": "2020-04-12T12:08:56Z",
          "updatedAt": "2020-04-12T12:10:01Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's my proposal:\r\n\r\n```\r\nenum ConnectionState {\r\n    validated, // only for the server, when the client's IP has been validated\r\n    handshake_completed, // TLS handshake successful\r\n    handshake_confirmed, // handshake confirmed, see sec. 4.1.2 of the QUIC-TLS draft\r\n    draining, // CONNECTION_CLOSE sent\r\n    closed // connection actually fully closed, memory freed\r\n}\r\n```\r\n\r\n@rmarx, @huitema What do you think?",
          "createdAt": "2020-04-12T12:17:13Z",
          "updatedAt": "2020-04-12T12:17:13Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@marten-seemann I think that's too coarse. You have to consider scenarios in which Initial packets are exchanged for some time before handshake keys are available, e.g., for post quantum, and scenarios in which handshake packets are exchanged for some time before 1RTT keys are available, e.g., client auth. Also, per 4.1.2, handshake confirmed on the server happens at exactly the same time as handshake confirmed. That's why I use a \"false start\" state for the server.\r\n\r\nWe are discussing logging options here. Having detailed logging options does not hurt, there is no point in being too parsimonious. If you only want to log a subset of them, that's a fine implementation choice, but that should not prevent precise logging for those who want it.",
          "createdAt": "2020-04-12T17:25:09Z",
          "updatedAt": "2020-04-12T17:25:09Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> Also, per 4.1.2, handshake confirmed on the server happens at exactly the same time as handshake confirmed.\r\n\r\nTrue. This event would be kind of redundant for the server. It's also kind of redundant redundant for the client, since this is the time when the client drops Handshake keys.\r\n\r\n> @marten-seemann I think that's too coarse. You have to consider scenarios in which Initial packets are exchanged for some time before handshake keys are available, e.g., for post quantum, and scenarios in which handshake packets are exchanged for some time before 1RTT keys are available, e.g., client auth. [...] That's why I use a \"false start\" state for the server.\r\n\r\nFirst of all, I don't understand the name \"false start\". My point in https://github.com/quiclog/internet-drafts/issues/49#issuecomment-612604685 was that we already have an event for this: it's the [key updated](https://quiclog.github.io/internet-drafts/draft-marx-qlog-event-definitions-quic-h3.html#name-key_updated) event.\r\n\r\nNow it seems like both \"false start\", `handshake_comfirmed` and `handshake_completed` are all redundant, since they all accompanied by key generation / key discarding events. Not sure what to make of that...",
          "createdAt": "2020-04-13T09:55:26Z",
          "updatedAt": "2020-04-13T09:55:26Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, I've been trying to build a QUIC handshake/connection state machine to see which states we actually need. This initial design is garnered towards expressing the -entire- state machine with all state transitions. While I agree with @marten-seemann above that some of these can be deduced from e.g., `key_update` events, for now I'd like to keep this event as complete as possible, so it can be used without those other events as well. \r\n\r\n**I believe that we need 8 states in total** (mainly to allow for some phases to last longer than 1 RTT/1 flight):\r\n\r\n1. attempted (initial sent/received) \r\n2. peer_validated (peer address validated by: [client sent Handshake packet OR client used CONNID chosen by the server](https://tools.ietf.org/html/draft-ietf-quic-transport-32#section-8.1))\r\n3. handshake_started \r\n4. false_start (1 RTT can be sent, but handshake isn't done yet)\r\n5. handshake_complete ([TLS handshake complete](https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#section-4.1.1): Finished received and sent) \r\n6. handshake_confirmed ([HANDSHAKE_DONE sent/received](https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#section-4.1.2)) (connection is now \"active\", 1RTT can be sent)\r\n7. draining (connection_close sent/received)\r\n8. closed (draining period done)\r\n\r\nFollowing [the handshake examples in the transport draft](https://tools.ietf.org/html/draft-ietf-quic-transport-32#section-7.1), this would lead to the following events and transitions: \r\n\r\n**Client:**\r\n- send initial\r\n\t- state = attempted \r\n- get initial \r\n\t- state = validated _(not really \"needed\" at the client, but somewhat useful to indicate progress nonetheless)_\r\n- get first Handshake packet\r\n\t- state = handshake_started \r\n- get Handshake packet containing ServerFinished\r\n\t- state = handshake_complete \r\n- send ClientFinished\r\n\t- state = false_start \r\n\t(1RTT can now be sent)\r\n- get HANDSHAKE_DONE \r\n\t- state = handshake_confirmed \r\n\r\n**Server:**\r\n- get initial \r\n\t- state = attempted \r\n- send initial _(don't think this needs a separate state, since some handshake will always be sent in the same flight as this?)_\r\n- send handshake EE, CERT, CV, ... \r\n\t- state = handshake_started \r\n- send ServerFinished\r\n\t- state = false_start \r\n\t(1RTT can now be sent)\r\n- get first handshake packet / something using a server-issued CID of min length \r\n\t- state = validated \r\n- get handshake packet containing ClientFinished\r\n\t- state = handshake_complete \r\n- send HANDSHAKE_DONE\r\n\t- state = handshake_confirmed \r\n\r\nThis has a few ugly things, of course:\r\n- The server `validated` and `false-start` events won't always be in the same order, depending on how long the handshake takes (e.g., with a large CERT, handshake might need several flights to complete, causing `validated` to come before `false-start`)\r\n- At the server side, `handshake_complete` and `handshake_confirmed` will always fire directly after one another (this is also true [in the TLS draft's definitions](https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#section-4.1.2) however)\r\n- The `false_start` and `validated` aren't really needed at the client side (but do provide a nice parallel in logic to the server's progression imo)\r\n\r\nFinally, for users not wishing to log all states this fine-grainedly, this condenses nicely to:\r\n1. attempted\r\n2. handshake_started\r\n3. handshake_confirmed\r\n4. closed\r\n\r\nWhat do people think? Did I miss something?",
          "createdAt": "2020-10-31T19:49:37Z",
          "updatedAt": "2020-10-31T19:49:37Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "From an implementation point of view, you probably want to separate \"false_start\" (on the server side) and \"almost_ready\" on the client side. The server side is more constrained, because it cannot receive 1-RTT packets. Also, when the client enters the \"almost_ready\" start, the TLS stack on the client has seen the server certificate and validated the \"server finished\" message. In contrast, the server will only know that there is no MITM or 0-RTT replay attack when its TLS stack validates and receives the \"client finished\" message, so in theory the server has to apply some caution before sending data.",
          "createdAt": "2020-10-31T20:14:29Z",
          "updatedAt": "2020-10-31T20:14:29Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Our implementation has \"waiting for initial\", which roughly corresponds to your \"attempted\", but also encapsulates the server side prior to receiving the initial.  We don't keep that state very long server side; your description implies that it persists, but I don't think that is helpful.\r\n\r\nThen we have \"handshaking\", which we keep orthogonal to the states where various keys are available.  Keeping key availability separate is better than trying to enumerate the various availability options.  false_start is a problem, I think in that it implies something else; an \"early write\" state is fine.  In this state you can sometimes send, based on what keys are available, but you can never receive.  Also, trying to conflate address validation state with handshake state will likely complicate things more than necessary.\r\n\r\nThen we have \"complete\" where TLS is done.  And \"confirmed\" where you have thrown out handshaking state.\r\n\r\nWe use the states from the spec for closing, which is not a single state, but three.\r\n\r\nSo aside from your closed state, the summary form is probably best.  Logging both address validation and key availability independently would be good.",
          "createdAt": "2020-11-01T01:19:35Z",
          "updatedAt": "2020-11-01T01:19:35Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you both @huitema and @martinthomson for your input! \r\n\r\nChanges I've made for -02:\r\n1. renamed \"false_start\" to \"early_write\". I appreciate that this is potentially not entirely the correct term, but I was thinking mainly of non-protocol experts trying to following along and \"early write\" seemed easiest to grok. Open to other suggestions for -03. \r\n2. changed to having 3 closing states: closing, draining, closed\r\n3. added explicit guidance to support the condensed/simpler set \r\n\r\n@martinthomson: we keep support for logging the key updates separately as well. WRT address validation, this will be re-evaluated once I add proper support for connection migration/path management. For now, I'm keeping it in there because @huitema suggested it above and it's the most logical place to put it at this point. \r\n\r\n@martinthomson: I do not have anything before \"attempted\" because this event is connection scoped and IIUC servers don't have a connection concept before the first initial from the client arrives (similar for the client). In qlog, this is more generally reflected by other events like `server_listening` atm.  \r\n\r\n",
          "createdAt": "2020-11-03T11:50:32Z",
          "updatedAt": "2020-11-03T11:50:32Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "MDU6SXNzdWU1NjAyMDI4Mjc=",
      "title": "general observations",
      "url": "https://github.com/quicwg/qlog/issues/50",
      "state": "CLOSED",
      "author": "xquery",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "future-versions"
      ],
      "body": "The following is a 'bag' of general comments ... perhaps not so actionable but I did not find a mail list to send these kind of general observations.\r\n\r\n**scope**\r\n\r\nSome readers may try to contrast/compare this effort with higher level http logging formats (eg. NCSA, common log format and friends) ... might be worth reducing their confusion by adding some context eg. qlog sits near pcap.\r\n \r\nYou may consider explicitly constraining scope to h2/h3 and degrade gracefully for use with other protocols as a side effect of good design instead of assert broad applicability.\r\n\r\nThere is a statement of compliance attempted in 'tooling section' but this document defines a high level schema eg. I would have expected the only statement of compliance achievable (in this document) is the correct validation of schema against instance data.\r\n\r\nUnlike pcap (which is defined in terms of an api) qlog (so far) is defined in the form of a schema - hence I was looking for a clear definition of optional vs not required ... my expectation was for the core of qlog to be as small as possible.\r\n\r\nI would separate out protocol definition (endpoint) ... I am sure there exists a good IETF example of this ... but I am too lazy to find and will point you to a W3C set of specs as example https://www.w3.org/TR/2013/REC-sparql11-overview-20130321/\r\n\r\n**json**\r\n\r\nYou might consider adding some section on json convention/style (assert snake_case, etc) eg. remarking on challenges of using json for representing log data (limitations with datetime, decimal, no comments - all come to mind).\r\n\r\nYou are defining a high level schema (which for me implies no dependency on a concrete format like json) but as you have used json throughout to illustrate relationships/structure - I was looking (maybe missed it) for a non normative json schema definition.\r\n\r\n**keys**\r\n\r\nerror is buried in the text, should be normatively defined.\r\n\r\nI dislike the term 'vantage_point' ... I understand the requirements but maybe considering other terms like 'src' and 'target' are more appropriate.  \r\n\r\n**values**\r\n\r\nhave you considered defining a time unit in some human readable datetime (including tz notation ex.iso-8601 et al https://www.w3.org/International/core/2005/09/timezone.html)  \r\n\r\n**transforms**\r\nHave you considered demonstrating how transforms might work \r\nI like the way csv spec goes about this https://www.w3.org/2013/csvw/wiki/Main_Page\r\n\r\n**general** \r\n\r\nIt is unclear how easy for a database to index qlog formatted json. \r\n\r\nI think the section on 'Practical Use' might consider how compressed json compares to a binary format.\r\n\r\n",
      "createdAt": "2020-02-05T08:01:56Z",
      "updatedAt": "2023-06-07T14:16:28Z",
      "closedAt": "2023-06-07T14:16:27Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "It's two years since @xquery kindly gave us a review of the specification. Some things will have been overtaken by events (OBE), some others might still be valid. Here's a very quick triage response base on https://datatracker.ietf.org/doc/html/draft-ietf-quic-qlog-main-schema-03, that tries to draw out salient points from the OP:\r\n\r\n1. contrast to other logging formats and clarifiy the applicability - seems like an opportunity for solid editorial improvement\r\n\r\n1. mention of tooling in compliance - OBE\r\n\r\n1. optional fields - resolved by using CDDL.\r\n\r\n1. \"I would separate out protocol definition (endpoint)\" - not sure I understand this against current text. OBE?\r\n\r\n1. json - I think most of this has been addressed via CDDL. If you're willing to re-review and point out specific things on a new ticket(s), then addressing those sounds entireley reasonable\r\n\r\n1. \"error is buried in the text\" - OBE?\r\n\r\n1. \"I dislike the term 'vantage_point'\" - In general, this describes the role of the actor in the system that is logging, independent of the traffic flows. The suggestion of 'src' or 'target' are too tightly coupled to flows; server role is both a source and a target. I can live with the term vantage_point and, in my limited knowledge, have not heard anyone else complain. If you'd like us to bikeshed the name, please raise a separate issue.\r\n\r\n1. human-readable time? - needs to be tracked in a separate new issue. FWIW I'd hazard on the side of this being a tooling presentation matter, let's keep the machine-readable format simple\r\n\r\n1. \"Have you considered demonstrating how transforms might work\" - I don't know. Can you provide some more colour about what you're asking? My gut instinct is that transforms between CDDL, JSON, JSON-SEQ, and other formats is already detailed outside qlog and we don't need to repeat that. But I'd like to hear more.\r\n\r\n1. \"It is unclear how easy for a database to index qlog formatted json.\" -please see https://quicwg.org/qlog/draft-ietf-quic-qlog-main-schema.html#section-6.3.1 and surrounding text. If there's more that could be added, a new issue or a PR would be appreciated.\r\n\r\n1. Compression - OBE. See https://quicwg.org/qlog/draft-ietf-quic-qlog-main-schema.html#section-6.3.2\r\n\r\n",
          "createdAt": "2022-09-07T23:06:57Z",
          "updatedAt": "2022-09-07T23:06:57Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Closing this as I think _most_ things are obsolete in latest copy. Anything that might have been missed can be reopened separately.",
          "createdAt": "2023-06-07T14:16:27Z",
          "updatedAt": "2023-06-07T14:16:27Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWU1NjE2NDczMTY=",
      "title": "QLOGDIR environment variable",
      "url": "https://github.com/quicwg/qlog/issues/51",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Maybe the main schema should specify something like SSLKEYLOGFILE that implementations SHOULD adhere to. \r\n\r\nThough it needs to be a directory, not 1 file, since we probably don't want to dump all qlogs into 1 single file as we do with the SSL keys. \r\n\r\nA good option might be QLOGDIR.\r\n\r\nWe should also specify how to write/name individual files in that directory (or at least list options)\r\n\r\nTODO: find out where SSLKEYLOGFILE Is specified exactly (seems a bit difficult to google).\r\n\r\nCC @bagder @xquery",
      "createdAt": "2020-02-07T13:47:15Z",
      "updatedAt": "2020-09-01T19:13:31Z",
      "closedAt": "2020-09-01T19:13:31Z",
      "comments": [
        {
          "author": "bagder",
          "authorAssociation": "NONE",
          "body": "I don't think `SSLKEYLOGFILE` is specified anywhere and I don't know exactly how it came to exist, but I know that Firefox and Chrome with Wireshark have supported it a fairly long time and curl does too since a while back. It's just very convenient to have several applications agree on how to do this. I would very much like to have curl support the qlog variable as well.",
          "createdAt": "2020-02-07T13:50:23Z",
          "updatedAt": "2020-02-07T13:50:23Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This wfm, I need a parameter to pass to control behaviour anyway and this avoids me having to make my own",
          "createdAt": "2020-02-07T15:17:49Z",
          "updatedAt": "2020-02-07T15:17:49Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "MDU6SXNzdWU1NjYxMTQxNjQ=",
      "title": "mandatory new field in key_updated compromises security",
      "url": "https://github.com/quicwg/qlog/issues/52",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "future-versions"
      ],
      "body": "On a production system you probably don't want to log TLS secrets, even if you qlog (some of the) connections. The `new` field in the `key_updated` event therefore should not be mandatory. \r\n\r\nI'm not sure I understand the `old` field either. If you're logging 1-RTT key updates and their sequence numbers, the key would already be written to the qlog, so there's no need to export it again. Or am I missing something?\r\n\r\nMaybe it would be a good idea to keep key material to the SSLKEYLOGFILE and not even offer an option to write them to qlog?",
      "createdAt": "2020-02-17T07:49:23Z",
      "updatedAt": "2023-10-18T11:13:36Z",
      "closedAt": "2023-10-18T11:13:35Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Additionally, we should add an \"owner\" field to the `key_update` event.\r\n\r\nNow, difference between client/server keys is made with the trigger and also the KeyType: this should be made more consistent with the other events. See also #44. \r\n\r\nAn endpoint would then emit separate events for client and server key updates, which *should* work event if key calculation is delayed (though not 100% sure yet). \r\n",
          "createdAt": "2020-02-17T10:27:58Z",
          "updatedAt": "2020-02-17T11:05:46Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I support not logging secrets",
          "createdAt": "2023-03-25T06:48:17Z",
          "updatedAt": "2023-03-25T06:48:17Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU1NjY5MTU2NjY=",
      "title": "Provide clearer usage advice",
      "url": "https://github.com/quicwg/qlog/issues/53",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "editorial",
        "future-versions"
      ],
      "body": "At the moment, it's not entirely clear how qlog is \"supposed to be used\".\r\n\r\nFor example, it's not clear to implementers why some fields (e.g., quic version) are duplicated across `connection_started` and also the PacketHeader.\r\n\r\nWe should provide some examples of what things look like if you implement \"all of qlog\" and what should happen if you only implement the Core events (i.e., some fields in the Core events can be skipped if you're using the Base or Extra events instead). This is also important info for tool implementers. \r\n\r\nThis also depends on the use case: tracing while debugging vs production-level logging. ",
      "createdAt": "2020-02-18T14:05:55Z",
      "updatedAt": "2025-03-12T20:19:06Z",
      "closedAt": "2025-03-12T20:19:05Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking about this more, this seems to have become an untenable situation going forward to -03. \r\nqlog straddles the weird line between being a replacement for pcaps, as well as having to provide events for logging conceptual events not reflected in pcaps. \r\n\r\nThis was fine in the beginning, as everyone can/did log packet contents (e.g., ACK frames) and we could skip many events related to things clear from the wire (e.g., `packet_acked` or `flow_control_updated` etc.). However, for implementations that would not want to log the wire image itself, we would have to add these latter types of events for everything... (ref #107). Tools would then also have to be flexible enough to get this info both from frames and these other events. \r\n\r\nLong story short: we're tying to be a one-stop-shop, defining everything. That might be fine, but then we probably need to explicitly and quite clearly split up the wire-image events from the conceptual events (and provide alternatives for all and clear guidance). \r\n\r\nThis really could use wider discussion. \r\n\r\n",
          "createdAt": "2020-10-31T16:36:39Z",
          "updatedAt": "2020-10-31T16:36:39Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We had a clear example today of how a separate `flow_control_updated` event is useful. A misbehaving client was lowering flow control limits (probably because it retransmits FC frames as they were in the past, rather than create a new FC update with new limits). qvis showed this as lowering the limits, even though the server probably didn't actually apply the lower limits at its end. It was good that qvis showed the limits (leading to the discovery of this problem), but it again highlights that there is a difference between receipt of a given frame and how that's actually applied in the implementation. ",
          "createdAt": "2020-11-27T17:22:29Z",
          "updatedAt": "2020-11-27T17:22:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Sounds like we want to focus on transport-related events in qlog and tell people that logging what your implementation_does_ with those can aid analysis or debug. This is an implementation choice. And general-purpose tooling is unlikely to support implementation-specific needs or data. I'd think most people could live with that because it is logical.\r\n\r\nWhat else might we want to say? \r\n\r\nIn future, if people are always logging some application-specific field and want to ask their tool vendor to support it. That's probaby a good time for them to engage in the community.",
          "createdAt": "2022-09-07T23:40:53Z",
          "updatedAt": "2022-09-07T23:40:53Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Marking this as editorial since I don't think there's anything we can do apart from reiterate that qlog doesn't cover everything and that it extensible enough to support individual needs.\r\n\r\nRequests for adding design changes to these drafts can be raised as new issues (albeit at this stage likely to be declined unless there is sufficient evidence that it is needed).",
          "createdAt": "2024-02-19T03:50:45Z",
          "updatedAt": "2024-02-19T03:50:45Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Wearing both an editor and chair hat, I'm inclined to invoke a statute of limitations on this issue. Its not specific or measurable and there's been no change for over 12 months. \n\nAny objections editors?",
          "createdAt": "2025-03-12T01:25:01Z",
          "updatedAt": "2025-03-12T01:25:01Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this has severely improved since the issue was originally opened due to many smaller changes anyway. So closing without action is ok for me. ",
          "createdAt": "2025-03-12T10:57:37Z",
          "updatedAt": "2025-03-12T10:57:37Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWU1NzExOTQ3MDA=",
      "title": "Allow more wire-image indicators",
      "url": "https://github.com/quicwg/qlog/issues/54",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "design",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "Currently, we abstract out a lot of the on-the-wire specifics.\r\n\r\nA good example is in the STREAM frame: there, the length and offset fields are optional, depending on how the frame should be handled. Simply having the same fields optional in qlog doesn't convey quite the same semantics: did the implementation simply not log them or were they not present from the start? \r\n\r\nMore importantly though: if no length is set, the frame extends to the end of the packet, so it does have a length, which you'd probably want to log (that's the way it's currently designed), but so you loose the info that the length field wasn't encoded on the wire. \r\n\r\nThis is just one example of similar problems across the board. I rather like the simplicity of the current setup, but we should have ways to signal the explicit wire image as well. \r\n\r\ncc @huitema",
      "createdAt": "2020-02-26T09:36:21Z",
      "updatedAt": "2023-01-19T11:19:58Z",
      "closedAt": "2023-01-19T11:19:58Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can see three options:\r\n1. provide a more fine-grained, optional `raw_frame_type` field that encodes the actual stream type number instead of the conceptual name we have in frame_type (like how UnknownFrame works today)\r\n2. require people to log the (partial) (STREAM) frame header in the raw field to allow for later re-parsing\r\n3. do nothing\r\n\r\nProposal: use 1.",
          "createdAt": "2021-08-18T09:52:21Z",
          "updatedAt": "2021-08-18T13:16:43Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Can you elaborate on 1 more? By the time my parser informs me I have a STREAM frame, I might have discarded the on-wire bytes",
          "createdAt": "2021-08-18T10:00:28Z",
          "updatedAt": "2021-08-18T10:00:28Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This would be an -extra- option to log besides the `frame_type` in case you really need to know if you got 0x08, 0x09, 0x0A ... or 0x0F (at least for STREAM, for ACK it'd be 0x02 or 0x03). \r\n\r\nThis could be parsed if you logged the first few bytes in `raw` for example, but having a separate field would be more direct. We have precedent for this in e.g., `ConnectionCloseFrame.raw_error_code`.\r\n\r\nIf you don't have that information available at the point you're logging but still need it well... you'd need to log somewhere closer to the wire? In the ACK case, it is implicit through the logging of ECN info, for stream it is somewhat for the presence of the FIN bool, but for length and offset, it's more difficult to know sometimes. \r\n\r\nThis is not crucial information, but could be good to know in some highly specific edge case debugging.\r\n\r\nGot a bug in pcap2qlog about this just the other day, where I forgot to extrapolate the length field from the QUIC packet length if it wasn't present in the STREAM frame itself (https://github.com/quiclog/pcap2qlog/issues/7)",
          "createdAt": "2021-08-18T13:24:00Z",
          "updatedAt": "2021-08-18T13:24:00Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "> This could be parsed if you logged the first few bytes in raw for example, but having a separate field would be more direct. We have precedent for this in e.g., ConnectionCloseFrame.raw_error_code.\r\n\r\nSome the the question here is what do you mean by wire image. Should something like `raw_error_code` be raw bytes underlying the varint (maintaining the information on how the number was encoded on the wire), or the parsed varint.\r\n\r\nSince `raw_error_code` a single int, it must be the parsed varint, which is slightly easier. But even today I can't populate that because my implementation has discarded the data by the time I come to generate the qlog. Changing the code would boil down to me changing the logging pipeline, parsing the same value twice, and/or storing the data twice just for qlog. \r\n\r\nI'll note that for H3 this is even harder, because we have to handle non-atomic varint reads as STREAM data comes.",
          "createdAt": "2021-08-18T15:30:19Z",
          "updatedAt": "2021-08-18T15:30:19Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So the idea was:\r\nOption 1: parsed varint (so literally the 0x08 - 0x0F for STREAM)\r\nOption 2: raw wire image (so \"unparsed\" varint)\r\n\r\nI do see the confusion... probably we should use another word than `raw` here, since `raw_error_code` is intended to also be the parsed varint, but the `raw:RawInfo` fields are intended to be pure wire bits. \r\n\r\nWith regards to your implementation not having that info available... I'm not sure what you want me to say... these are optional fields that you can output if needed/available, but not something I would expect many implementations to do (by default). I don't see a way of solving the original issue here (representing all the wire image nuances in some form) without having access to those nuances at the logging location :) \r\n\r\nCould you elaborate on `because we have to handle non-atomic varint reads as STREAM data comes` with an example maybe? Not sure what you mean there? \r\n\r\n\r\n\r\n",
          "createdAt": "2021-08-19T07:55:52Z",
          "updatedAt": "2021-08-19T07:55:52Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The main point is that it's fairly straightforward to log the unprocessed bytes of a QUIC packet or QUIC frame, that's because an implementation will have received those in whole and know their length.  E.g. Read UDP, everything in the datagram.\r\n\r\nFor things on top of QUIC streams it becomes harder because they can span lots of packets. A streaming parser will possibly not have an entire frame available when it want to log an event.\r\n\r\nIf the proposal is to log the parsed varint, it makes things slightly easier ",
          "createdAt": "2021-08-19T10:24:23Z",
          "updatedAt": "2021-08-19T10:24:23Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "how about an optional field `frame_type_value: uin64`, which can be used in any frame type that spans a range of possible values. Then we'll update UnknownFrame s/raw_frame_type/frame_type_value.",
          "createdAt": "2022-09-07T23:46:45Z",
          "updatedAt": "2022-09-07T23:46:45Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by #274 ",
          "createdAt": "2023-01-19T11:19:58Z",
          "updatedAt": "2023-01-19T11:19:58Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWU1NzExOTU3ODk=",
      "title": "More fields should be optional in ConnectionCloseFrame",
      "url": "https://github.com/quicwg/qlog/issues/55",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, everything is required, which isn't optimal.\r\n\r\nAdditionally, qvis should use more of the present information. \r\n\r\ncc @huitema",
      "createdAt": "2020-02-26T09:38:09Z",
      "updatedAt": "2020-09-08T15:43:03Z",
      "closedAt": "2020-09-08T15:43:03Z",
      "comments": []
    },
    {
      "number": 56,
      "id": "MDU6SXNzdWU1NzExOTg5Njk=",
      "title": "Allow logging of partial raw data",
      "url": "https://github.com/quicwg/qlog/issues/56",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "Currently, we use the `raw` field in multiple events to allow logging of the raw data.\r\n\r\nIt would be interesting to allow logging for only the first x bytes, which can help in debugging.\r\n\r\nSome options:\r\n\r\n1. New `raw_partial` field, containing the partial hex-encoded data\r\n2. New `raw_length` field, indicating the length of the `raw` field. If it doesn't match the `length` parameter (or equivalent), we know `raw` is truncated\r\n3. No new fields: we can derive `raw`'s length from the size of the string. Then use similar logic as 2) to detect truncation\r\n4. No new fields, end `raw` field with `...` at the end of the string. Perfectly human readable, bit of a hassle when decoding the bytes to e.g., ASCII + less optimal for a potential binary format\r\n\r\nPersonally, I would prefer 3. We will strongly advise AGAINST logging `raw` in typical usage scenarios anyway: it's only to be used for core debugging. In these latter cases, the person debugging probably knows the stack a bit more deeply and understands that it's logging just partial raw values. \r\n\r\ncc @huitema",
      "createdAt": "2020-02-26T09:43:23Z",
      "updatedAt": "2020-11-02T17:05:28Z",
      "closedAt": "2020-11-02T17:05:28Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related to #104 and #102",
          "createdAt": "2020-09-08T15:47:58Z",
          "updatedAt": "2020-09-08T15:47:58Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Solved by allowing truncated values and specifying a separate length field (so basically option 2 above). ",
          "createdAt": "2020-11-02T17:05:28Z",
          "updatedAt": "2020-11-02T17:05:28Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWU1NzEyMDA1NDc=",
      "title": "Add IP addresses to datagram_* events",
      "url": "https://github.com/quicwg/qlog/issues/57",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "design",
        "current-version",
        "privacy"
      ],
      "body": "We currently extracted these to other events, assuming they wouldn't change or only change sparingly at specific times, handled by other events (e.g., when doing migration).\r\n\r\nHowever, this is not always the case. For example, @huitema mentioned:\r\n\r\n> NAT rebinding, probes of packets before migration\r\n\r\nFor these cases, it would be interesting to have (optional) IP from/to addresses in the datagram_* events as well. ",
      "createdAt": "2020-02-26T09:45:54Z",
      "updatedAt": "2024-03-19T11:59:09Z",
      "closedAt": "2024-03-19T11:59:09Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "If you want to cover migration, you probably want to include the port numbers too",
          "createdAt": "2022-07-25T16:08:56Z",
          "updatedAt": "2022-07-25T16:08:56Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "yeah I discussed this with Robin. He recommended considering a `PathInfo` struct that basically contains the 4 tuple and it can be reused for all cases, including Connection Migration and Multi-path ",
          "createdAt": "2022-08-04T01:22:27Z",
          "updatedAt": "2022-08-04T01:22:27Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Solved by https://github.com/quicwg/qlog/pull/336",
          "createdAt": "2024-03-19T11:59:09Z",
          "updatedAt": "2024-03-19T11:59:09Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWU1NzEyNTQ1NDg=",
      "title": "Consider splitting up parameters_set",
      "url": "https://github.com/quicwg/qlog/issues/58",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "quic-http3-fields",
        "future-versions"
      ],
      "body": "Currently, the parameters related events aggregate all sorts of parameters, doesn't matter where they come from. Good example is transport:parameters_set, which contains mostly data that's transported via TLS (Transport params, alpn), but also some other fields (like QUIC version). \r\n\r\nSome people (@huitema, @marten-seemann) have advocated splitting up this event into others. I personally don't see the benefit of that, so this issue is to track outside arguments and proposed solutions.",
      "createdAt": "2020-02-26T11:09:41Z",
      "updatedAt": "2024-02-19T08:57:26Z",
      "closedAt": "2024-02-19T08:57:25Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "One problem with the current design is that it couples QUIC's transport parameters with the handshake. Some of that data is provided by TLS to QUIC, but other things like ALPN are not used by the QUIC transport. \r\n\r\nA more natural model could be a series of handshake events, as suggested by others.",
          "createdAt": "2020-02-26T11:47:53Z",
          "updatedAt": "2020-02-26T11:47:53Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "4 years in, I think the combined `parameters_set` approach is pretty fixed and works well enough in practice (and I still don't see much concrete value splitting up), so closing without action. ",
          "createdAt": "2024-02-19T08:57:25Z",
          "updatedAt": "2024-02-19T08:57:25Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWU1NzEyNzIxMTI=",
      "title": "Add more TLS-specifics",
      "url": "https://github.com/quicwg/qlog/issues/59",
      "state": "OPEN",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "future-versions"
      ],
      "body": "Currently, we have few options for logging a lot of TLS related data (e.g., cipher suites, supported groups, (E)SNI, ...). \r\n\r\nNeed to figure out a generic form for TLS (extensions) data so it can be logged using qlog as well. \r\n\r\nNote: this is getting in the \"new TCP+TLS+HTTP/2 schema\" territory ",
      "createdAt": "2020-02-26T11:37:15Z",
      "updatedAt": "2024-10-21T09:16:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that #27 suggests to add some resumption and 0-RTT events, which arguably are TLS-specific. They do however (at least 0-RTT does) change how the QUIC stack behaves, in pretty fundamental ways (namely sending and processing 0-RTT data, restoring transport parameters, etc.), which is a good justification for including these (but not other) events.",
          "createdAt": "2024-10-21T09:16:58Z",
          "updatedAt": "2024-10-21T09:16:58Z"
        }
      ]
    },
    {
      "number": 60,
      "id": "MDU6SXNzdWU1Nzc0NTA0NzY=",
      "title": "packet_dropped header_decrypt_error should be header_parse_error",
      "url": "https://github.com/quicwg/qlog/issues/60",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Header decryption can never fail: it's just an XOR with a byte mask (header protection is not authenticated). You'd drop a packet though if header parsing fails, so maybe we can rename the trigger?",
      "createdAt": "2020-03-08T05:51:31Z",
      "updatedAt": "2020-09-08T12:30:28Z",
      "closedAt": "2020-09-08T12:30:28Z",
      "comments": []
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWU1Nzc1Mzk2MjY=",
      "title": "Logging of Retry and Version Negotiation packets",
      "url": "https://github.com/quicwg/qlog/issues/62",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "Initial, Handshake, 0-RTT and 1-RTT packets have a payload composed of a set of frames. Retry and Version Negotiation packets don't. The payload of retry packets is a retry token; the version negotiation packets contain a list of proposed versions. I wonder what the proper logging should be.\r\n\r\nStaying close to the transport spec would get:\r\n```\r\n[118740, \"TRANSPORT\", \"PACKET_RECEIVED\", { \r\n    \"packet_type\": \"version\",\r\n    \"header\": { \r\n        \"packet_number\": \"0\",\r\n        \"packet_size\": 43,\r\n        \"payload_length\": 20,\r\n        \"scid\": \"96f7ef87d6603a79\",\r\n        \"dcid\": \"130b28a505315b13\" },\r\n    \"proposed_versions\": [ \"ff00001b\", \"ff000019\", \"8aca3a8a\" ]}]\r\n\r\n[113660, \"TRANSPORT\", \"PACKET_RECEIVED\", {\r\n    \"packet_type\": \"retry\",\r\n    \"header\": {\r\n        \"packet_number\": \"0\",\r\n        \"packet_size\": 80,\r\n        \"payload_length\": 32,\r\n        \"scid\": \"fa49f056d84c11c1\",\r\n        \"dcid\": \"5bdfe3c33300b8b8\" },\r\n    \"retry_token\": \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\" }]\r\n```\r\nDoes this look right?",
      "createdAt": "2020-03-08T18:01:06Z",
      "updatedAt": "2020-11-02T17:08:27Z",
      "closedAt": "2020-11-02T17:08:27Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Was solved by including `supported_versions`, `retry_token`, `retry_token_length` and `stateless_reset_token` directly on `packet_sent` and `packet_received` (as this can conceptually be seen as being part of the \"payload\" of those special purpose packets, rather than their headers)",
          "createdAt": "2020-11-02T17:08:27Z",
          "updatedAt": "2020-11-02T17:08:27Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "MDU6SXNzdWU1ODA0Mjk3OTU=",
      "title": "Properly specify stateless reset, retry and migration",
      "url": "https://github.com/quicwg/qlog/issues/64",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "These concepts were in flux when -01 was made and are now much more settled.\r\n\r\nAny thoughts on how to best approach this are more than welcome.",
      "createdAt": "2020-03-13T07:50:57Z",
      "updatedAt": "2020-03-28T10:24:20Z",
      "closedAt": "2020-03-28T10:24:20Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For stateless reset, I can see two options:\r\n\r\n1. make it a new PacketType and then simply use `packet_received` / `packet_sent`\r\n2. make it a new event type with custom semantics\r\n\r\nAt least one implementer has indicated a preference for (1), since their stack only intends to support the core events. \r\n",
          "createdAt": "2020-03-13T08:05:59Z",
          "updatedAt": "2020-03-13T08:05:59Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "For stateless reset, both works for me. Most important thing is to get a way to log it at all, since this would be an interesting signal in production.",
          "createdAt": "2020-03-13T09:49:16Z",
          "updatedAt": "2020-03-13T09:49:16Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU1ODA0MzkwMTU=",
      "title": "Change data_moved to the transport category",
      "url": "https://github.com/quicwg/qlog/issues/65",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, `data_moved` is in the HTTP category, but it's (application) protocol agnostic and can be used for other application-layer protocols as well.\r\n\r\ncc @marten-seemann ",
      "createdAt": "2020-03-13T08:11:40Z",
      "updatedAt": "2020-09-07T19:40:28Z",
      "closedAt": "2020-09-07T19:40:28Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "strong agree!",
          "createdAt": "2020-04-10T17:34:54Z",
          "updatedAt": "2020-04-10T17:34:54Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWU1ODM1Njc3NDk=",
      "title": "relax ordering requirement",
      "url": "https://github.com/quicwg/qlog/issues/66",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "The spec currently says:\r\n> Events in each individual trace MUST be logged in strictly ascending timestamp order (though not necessarily absolute value, for the \"delta_time\" setup). Tools are NOT expected to sort all events on the timestamp before processing them.\r\n\r\nThis poses problems for multi-threaded implementations that implement a streaming encoder. Since qlogs take up a lot of memory for long-lived / active connections, implementing a streaming encoder is the only way to run qlog in production, without risking to overflow the host's memory.\r\n\r\nIf you have a multithreaded application, it's not possible to guarantee that the events will be strictly ordered by timestamp.",
      "createdAt": "2020-03-18T08:51:22Z",
      "updatedAt": "2020-11-01T13:04:52Z",
      "closedAt": "2020-11-01T13:04:52Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've been thinking about this while implementing an automated sort() in qvis to prevent this from going wrong (kazu also had this problem).\r\n\r\nIn and of itself, it's not necessary to -log- in order I think. But it saves a lot of time in (especially web-based) tooling if you don't have to sort all logs prior to using them. So we could say something like:\r\n\r\n> Events SHOULD be logged in ascending timestamp order. Tools are not expected to do sorting. If an implementation cannot guarantee ordered logs, they can use a postprocessing step to order the logs if their tool of choice does not offer automatic sorting.\r\n\r\nThis is similar to wireshark's approach IIUC (https://www.wireshark.org/docs/wsug_html_chunked/AppToolsreordercap.html)\r\n\r\nThough I am not 100% sure that sort() solves all problems... we've had some issues with wireshark recently where packets captured on different interfaces (but ending up in the same pcap) had quite a bit of timestamp differences and re-ordering on the timestamp field would be obviously wrong. Now, this is probably an artifact of the internal tcpdump implementation etc. and QUIC/H3 stacks should be much less affected. However, given that qlog is envisioned as a wider format (and because I can envision people splicing pcap-to-qlog with direct-qlog events from the application), I can't simply dismiss this. \r\n\r\n",
          "createdAt": "2020-03-18T09:03:28Z",
          "updatedAt": "2020-03-18T09:03:28Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "The whole point of using a streaming encoder is to not have to load the whole qlog file into memory at the same time. A post-processing step (which would have to happen when the whole qlog is written) would require me to do exactly that, so that's not an option.",
          "createdAt": "2020-03-18T09:07:12Z",
          "updatedAt": "2020-03-18T09:07:12Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm thinking more of an \"offline\" post-processing step. e.g., either in-bulk by a separate server/process as a cron-job or immediately prior to loading into a tool that doesn't support ordering itself. \r\n\r\nFor example, qvis currently detects if traces are un-ordered and does a sort() if that's the case. You could see that as a \"post processing step\" built in to the tooling itself. This is plenty fast enough for smaller traces (say up to 100MB) but can be slower for larger ones (though those aren't optimal in qvis either way).\r\n\r\nI think the whole point will be a bit moot in practice, since I would expect tools to have this built-in in practice, but that doesn't mean I would want to require this in the text. \r\n\r\nMaybe @nibanks has some insight into how windows ETW handles this type of thing? ",
          "createdAt": "2020-03-18T09:13:10Z",
          "updatedAt": "2020-03-18T09:13:29Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "That would be possible, but kind of ugly, since it would mean that a QUIC implementation cannot export semi-valid qlog on its own, and is reliant on external programs to fix the exported data. ",
          "createdAt": "2020-03-18T09:20:25Z",
          "updatedAt": "2020-03-18T09:20:25Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So I'm not sure what the solution would be then unless you'd force the tools to sort the logs themselves. Is that what you're advocating for? ",
          "createdAt": "2020-03-18T11:04:50Z",
          "updatedAt": "2020-03-18T11:04:50Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWU1ODkxNDQzOTY=",
      "title": "PTO is per PN-space",
      "url": "https://github.com/quicwg/qlog/issues/69",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, we log `pto_count` in `metrics_updated`. However, we can have multiple PTO's running across multiple PN spaces and there is no proper way to correlate them with a PN space in metrics_updated.\r\n\r\nThis also impacts the `loss_timer*` event types. \r\n\r\nPossible resolutions:\r\n- Add pn_space attribute to `metrics_updated`\r\n- Split PTO count into a separate event (potentially merge with loss_timer?)\r\n\r\nTODO: reason more about how these metrics are tied to PN spaces in general (are there others than PTO that are duplicated)\r\n\r\ncc @marten-seemann ",
      "createdAt": "2020-03-27T13:45:29Z",
      "updatedAt": "2020-03-28T10:29:31Z",
      "closedAt": "2020-03-28T10:29:31Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> * Add pn_space attribute to metrics_updated\r\n\r\nMost other metrics in the `metrics_updated` event are independent of the PN space, so that would be weird.\r\n\r\n> * Split PTO count into a separate event (potentially merge with loss_timer?)\r\n\r\nI'd prefer to do that. Not sure if it makes sense to merge is with the loss timer events, since we also need to be able to log a reset of the PTO count to 0 (which doesn't require setting of a timer).",
          "createdAt": "2020-03-27T13:51:04Z",
          "updatedAt": "2020-03-27T13:51:04Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "MDU6SXNzdWU1ODk1NTEzNzU=",
      "title": "Allow listing which events were supported by the logger",
      "url": "https://github.com/quicwg/qlog/issues/72",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "future-versions"
      ],
      "body": "When looking at a qlog at this time, if there is a certain event type missing, you don't know if it's because those events never occurred or if the implementation simply doesn't support/log that event type. \r\n\r\nThis is especially troublesome if you want to selectively enable/disable certain types to reduce overhead when you're doing targeted \"live\" debugging on a deployed system.\r\n\r\nThe simplest solution I can see is to add a new field to `configuration`, for example:\r\n\r\n> supportedEvents:Array\\<string\\> // each string is category:event_type (e.g., transport:packet_sent)\r\n\r\nSome bikeshedding can help to decide if we need two separate fields (supportedCategories separately for example) or if we can cut out the category in here completely (as there is little overlap in event names atm).\r\n\r\nThis would also be interesting for doing a fast \"is this trace compatible with this visualization\"-check in qvis and others tools. \r\n\r\nThanks to @mjoras for reporting.",
      "createdAt": "2020-03-28T10:36:52Z",
      "updatedAt": "2022-09-29T13:54:23Z",
      "closedAt": "2022-09-29T13:54:23Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "This only captures a subset of the possible changes. For example, you wouldn't be able to tell if a  qlog implementation already supported the recently added `stateless_reset` packet type or not.\r\n\r\nIn the end, I think it makes more sense to add some kind of versioning scheme to your qlog file (which is orthogonal to the `qlog_version`), and would not be interpreted by tools.",
          "createdAt": "2020-03-29T08:53:36Z",
          "updatedAt": "2020-03-29T08:53:36Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I follow you here...\r\nIf the implementation doesn't support stateless_reset, it won't log them either in the first place, so them being absent from the `supportedEvents` list is the same.\r\n\r\nThis is not really intended to show what an implementation \"supports\" but more what is has \"enabled\". The situation is that as a user, you get a random qlog file in front of you, on which you need to do analysis. You're looking for the occurrence of a certain event type, but it isn't there. Is that because the event type wasn't being logged for this log (e.g., mvfst wants to selectively log only -some- of the supported event types to keep overhead down) or because it actually never occurred during the connection (e.g., signalling the bug you're looking for).\r\n\r\nCould you expand on the orthogonal versioning scheme? For your example of the `stateless_reset`, that would just be `draft-02` going forward from my viewpoint. \r\n\r\n\r\n\r\n",
          "createdAt": "2020-03-29T10:53:44Z",
          "updatedAt": "2020-03-29T10:53:44Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I think this can be resolved as 2 optional lists containing event category+type, or name. One list  declares what events were in scope to be logged, one that declares what events were actually logged.\r\n\r\nThis would allow for easier scanning of traces to determine if they have events of interest - I.e. speeding up finding 1 in 10,000 connections that fail or bwhave in a certain way",
          "createdAt": "2022-09-21T09:22:19Z",
          "updatedAt": "2022-09-21T09:22:19Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Especially from the perspective of streaming logs I'm not sure I see much value in a list of events that \"were actually logged\"? That would imply somehow keeping track of what you were logging and then, at the end of the file (if there is even such a thing in a streaming context) dumping those out? \r\n\r\nTools can get this by making a list of event names seen in the logs (either in a file or a streamed collection of individual events) and then comparing to the `supportedEvents` list (which you call \"in scope to be logged\" IIUC). \r\n\r\nI think I understand a bit more now though what @marten-seemann was saying that we don't need explicit `supported_versions` but that this can just be an internal convention/configuration based on `our_custom_qlog_configuration_version_nr_or_tag`. This would mean it's not tracked in the qlog file itself, which also has merit I would assume.\r\n\r\nAt this point, with an eye on keeping qlog simple and given that IIUC no-one has implemented this or something similar, would be to close this without action. \r\n\r\n\r\n",
          "createdAt": "2022-09-28T13:33:01Z",
          "updatedAt": "2022-09-28T13:33:01Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Good point. On one hand I think it could be useful to have a list of the events a particular instance is configured to produce if they happened, whatever we named it. On the other hand, my experience with netlogs is that having a huge list at the top of every file is annoying (the reason they have a list of events is different but the effect is quite similar). \r\n\r\nSuch a field seems easy enough to add as a custom extension for vendor needs, or a standard extension as follow on work. Therefore closing with no action seems fine to me.",
          "createdAt": "2022-09-28T13:48:12Z",
          "updatedAt": "2022-09-28T13:48:12Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing for now, feel free to re-open if you have strong opinions later @marten-seemann or @mjoras. ",
          "createdAt": "2022-09-29T13:54:23Z",
          "updatedAt": "2022-09-29T13:54:23Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWU1ODk2MDg4Nzg=",
      "title": "Add packet_number to frames_processed",
      "url": "https://github.com/quicwg/qlog/issues/74",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "With recent discussions on that it's sometimes expensive to log parsed frames in packet_received/packet_sent directly, it would be interesting to make frames_processed a bit more usable in practice.\r\n\r\nGiving it a packet_number allows it to be more easily linked to a specific packet and thus can be combined with packet_sent/received.\r\n\r\nThough, maybe we should rather go for a frame_created/frame_parsed equivalent to H3, as _processed only implies _parsed at this point. In that vein, maybe make it multiple frameS instead of just 1? ",
      "createdAt": "2020-03-28T16:19:26Z",
      "updatedAt": "2020-09-07T13:37:28Z",
      "closedAt": "2020-09-07T13:37:28Z",
      "comments": []
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWU1OTAyMDI5MDU=",
      "title": "Add way to log contents of version negotiation packet",
      "url": "https://github.com/quicwg/qlog/issues/75",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "Currently, there is no way to do this.\r\n\r\nPossible approaches:\r\n1. add `supported_versions:Array<string>` to `parameters_set` (similar to ALPN in #28)\r\n2. add `supported_versions:Array<string>` to the `packet_*` events (similar to how we do stateless_reset\r\n\r\nI personally have a preference for nr. 2, since it's consistent with how other packets are handled. ALPN is after all indeed a parameter, not a full packet. \r\n\r\ncc @mpiraux",
      "createdAt": "2020-03-30T11:09:53Z",
      "updatedAt": "2020-11-03T11:08:57Z",
      "closedAt": "2020-11-03T11:08:57Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd argue that we need both. The supported versions is a parameter of the server that's interesting to know independent of if version negotiation was ever performed or not.\r\n\r\nFor the client, it's important to have a way to log the contents of a version negotiation packet, so adding it to the `packet_received` event makes sense.",
          "createdAt": "2020-04-14T09:37:13Z",
          "updatedAt": "2020-04-14T09:37:13Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related to #62 ",
          "createdAt": "2020-10-31T13:56:38Z",
          "updatedAt": "2020-10-31T13:56:38Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Option 2 was introduced in commit ac00848b50c1da3feaf50f43938e962a091396b0.\r\n\r\nHowever, we currently still lack a way to indicate which versions each endpoint supports by themselves (which is not always communicated over the wire). ",
          "createdAt": "2020-11-01T20:02:23Z",
          "updatedAt": "2020-11-01T20:02:23Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was resolved for now by adding the new `version_information` event. Per #85, I'm not entirely sure that's the best approach here though. Closing this for now and keeping that issue open for general discussion. We can revisit this later depending on the outcome. \r\n\r\n",
          "createdAt": "2020-11-03T11:08:57Z",
          "updatedAt": "2020-11-03T11:08:57Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "MDU6SXNzdWU1OTU2NzI3NDI=",
      "title": "packet_buffered should have a packet_size field",
      "url": "https://github.com/quicwg/qlog/issues/76",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This field would be really helpful for debugging. Without a packet size, there's no way to correlate a buffered packet to a packet that is later dequeued from the buffer.",
      "createdAt": "2020-04-07T08:01:26Z",
      "updatedAt": "2020-07-22T07:48:08Z",
      "closedAt": "2020-07-22T07:48:08Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good point.\r\n\r\nReminder to me: maybe mention in the comments that it's primarily useful when you're buffering because keys were not available yet (e.g., during handshake).\r\n\r\nAlso: related to #40 ",
          "createdAt": "2020-04-08T09:07:03Z",
          "updatedAt": "2020-04-08T09:07:20Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "MDU6SXNzdWU1OTg0MDUzODI=",
      "title": "revisit connection_state_updated",
      "url": "https://github.com/quicwg/qlog/issues/78",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "I see the following problems with the `connection_state_updated` event:\r\n1. `attempted` seems to be a duplicate of `connection_started` for the client (i.e. the two events would always be emitted at the same time)\r\n2. `reset` is impossible to log. You send a stateless reset if you lost state for a connection (after a crash or reboot, or if a packet was misrouted to the wrong backend server). In any case, there\u2019s no connection state to update by definition.\r\n3. `handshake` seems to be a duplicate of connection_started for both sides.\r\n\r\nI think these events could be removed without losing any information in the log.\r\n\r\nI suggest adding a new event for [confirmation of the handshake](https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#name-handshake-confirmed). Maybe it would make sense to rename `active` to `handshake_completed` and add a `handshake_confirmed`?",
      "createdAt": "2020-04-12T04:01:04Z",
      "updatedAt": "2020-11-02T20:37:30Z",
      "closedAt": "2020-11-02T20:37:30Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Potential duplicate of #49, should be handled together. \r\n\r\n(meaning that, yes, this should be handled for -02)",
          "createdAt": "2020-04-12T11:31:59Z",
          "updatedAt": "2020-04-12T11:31:59Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After some thinking, I feel it might worthwhile to see if we can transform `connection_started` into a `parameters_set` equivalent for the `connectivity` category.",
          "createdAt": "2020-04-12T12:11:05Z",
          "updatedAt": "2020-04-12T12:11:05Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Adding to my list, `keepalive` should probably not be a connection state. The QUIC specification doesn't  say a lot about keep-alives other than you can send a packet once in a while if you have nothing else to send.\r\nMaybe it's enough to set this as a `trigger` on the `packet_sent` event?",
          "createdAt": "2020-04-12T12:16:04Z",
          "updatedAt": "2020-04-12T12:16:04Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@marten-seemann just reported on slack that a separate `connection_closed` event would be interesting to log the reason the connection was closed (for which we're now either relying on the CONNECTION_CLOSE frame contents or an (internal_)error event). \r\n\r\nIt seem like adding a `reason` field to `connection_state_updated` would work there too.\r\nAlternatively, this could be part of the envisioned `parameters_set` connectivity event that would replace both separate `connection_started` and `connection_close` semantics, though I'd feel a bit uneasy putting a `reason` field in `parameters_set` (semantics seem off).  \r\n\r\nBest to take a step back and look at this from a higher viewpoint to see if making all this generic gives us more benefits than simply having separate events for everything. \r\n",
          "createdAt": "2020-04-20T15:45:58Z",
          "updatedAt": "2020-04-20T15:46:10Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's my suggestion for a better `connection_state_updated` definition:\r\n```\r\nenum ConnectionState {\r\n    client_address_verified, // when the server considers the client's source address verified\r\n    handshake_complete, // handshake completed\r\n    handshake_confirmed, // handshake confirmed\r\n    draining, // CONNECTION_CLOSE sent\r\n    closed // connection actually fully closed, memory freed\r\n}\r\n```\r\n\r\nI added a `client_address_verified` to my earlier suggestion, since with https://github.com/quicwg/base-drafts/pull/3924, servers can make this decision based on multiple different criteria.\r\n\r\n@rmarx What do you think?",
          "createdAt": "2020-07-27T04:18:33Z",
          "updatedAt": "2020-07-27T04:18:33Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I like splitting `active` into `handshake_complete` and `handshake_confirmed` as @marten-seemann is suggesting above, and I also like `client address verified` as an intermediate server state. On the client side, I would like to see logging of the transition between `started` and `heard_from_the_server`, which is pretty much the client equivalent of `client_address_verified`.\r\n\r\nOn the other hand, all these states can be trivially deduced from observing the packet flow. @rmarx is the connection_state event really useful?",
          "createdAt": "2020-08-02T00:25:57Z",
          "updatedAt": "2020-08-02T00:25:57Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have to re-read the draft myself first, but a merge of Marten's proposal (with a \"started\" state or similar put back in) and Christian's suggestion of `heard_from_server` seems sensible at first glance.\r\n\r\nWith regards to \"do we need this event at all\"... it depends. If you're logging all packets: potentially not, though that might hide implementation bugs (state transfer too early/late). However, as @marten-seemann has also said wrt a separate `connection_closed` event (instead of simply watching the `connection_state_updated` for this) and the discussion on needing a `packet_acked` event (#107): when writing tools that try to quickly deduce these state transitions from a trace, it can be useful to have these \"duplicate\" events as well. I don't think I'd write many tools that fully rely on only these myself, and I wouldn't mark them as \"core\" events in the spec, but I can see why some people like to keep them in and have a preference for this myself as well (up to a certain point...)",
          "createdAt": "2020-08-02T10:37:53Z",
          "updatedAt": "2020-08-02T10:37:53Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related to #43 ",
          "createdAt": "2020-10-31T14:00:18Z",
          "updatedAt": "2020-10-31T14:00:18Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this and moving to #43 as the main tracking issue for this. ",
          "createdAt": "2020-11-02T20:37:30Z",
          "updatedAt": "2020-11-02T20:37:30Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWU1OTg0NzE3MTI=",
      "title": "Add support for connection migration",
      "url": "https://github.com/quicwg/qlog/issues/79",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "Now that this is a bit more mature, it should be added to draft-02.\r\n\r\nVia @marten-seemann:\r\n> So I would assume that would best be modeled using a `path_probed` event (which has ips, ports, CID), and then a `path_confirmed` and a `path_abandoned` event\r\n\r\nSomewhat ties into #49 and #78 (and all other connectivity events really...).\r\nAlso look into how this is modeled in qlog for multipath by UCL (@mpiraux)",
      "createdAt": "2020-04-12T12:13:33Z",
      "updatedAt": "2024-11-05T19:44:17Z",
      "closedAt": "2024-11-05T19:44:16Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "@rmarx was this fixed by https://github.com/quicwg/qlog/pull/336?",
          "createdAt": "2024-11-04T15:58:58Z",
          "updatedAt": "2024-11-04T15:59:05Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Indeed, this can be closed :) ",
          "createdAt": "2024-11-05T19:44:16Z",
          "updatedAt": "2024-11-05T19:44:16Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "MDU6SXNzdWU1OTg4MDAyNTQ=",
      "title": "Remove trigger fields from individual events",
      "url": "https://github.com/quicwg/qlog/issues/80",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Triggers are now said to be a global optional property of all \"data\" fields in an event.\r\n\r\nYet, some events (like `key_retired` and `key_updated` still include them. Make sure they don't.\r\n\r\ncc @marten-seemann ",
      "createdAt": "2020-04-13T10:07:15Z",
      "updatedAt": "2020-09-07T10:27:46Z",
      "closedAt": "2020-09-07T10:27:46Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There were more of these than I expected, but all have been removed now. ",
          "createdAt": "2020-09-07T10:27:46Z",
          "updatedAt": "2020-09-07T10:27:46Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "MDU6SXNzdWU2MDM2ODIzNzM=",
      "title": "split up events",
      "url": "https://github.com/quicwg/qlog/issues/85",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "design",
        "high-level-schema",
        "current-version"
      ],
      "body": "This is a high-level observation based on my experience of 1. adding qlog support for quic-go and 2. writing some tooling to sift through a pile of logs.\r\n\r\nWhen adding qlog support for quic-go, I already found it confusing that qlog bundles things that have little to do with each other into the same event. Examples for these are:\r\n* The values in `parameters_set` event in `transport` that are not part of the QUIC transport parameters.\r\n* The `pto_count` in `metrics_updated`.\r\n* The `connection_state_updated` event. This is the worst in this list.\r\n\r\nIn my implementation, I worked around this by exposing an API that exposes different functions, which then would encode the same qlog event (with the respective fields set). For example, I have a `qlog.UpdatedPTOCount()` and a `qlog.UpdatedMetrics()`, which both emit a `metrics_updated` event.\r\n\r\nWriting my own qlog parser, I'm now encountering the same problem again. For example, one interesting thing to monitor on a production system would be the reason why a connection was closed (to see if there are any PROTOCOL_VIOLATIONS, for example). It would make filtering much easier if there was a `connection_closed` event, instead of having to look at optional fields in all the `connection_state_updated` events emitted over the lifetime of the connection. A similar argument applies to the PTO count (Connections that experience a lot of PTO events might be interesting to look at. Connections that collect many RTT samples are not).\r\n\r\nFrom my discussions with @rmarx (and I hope that I'm paraphrasing him correctly here), the main argument for having fewer events was that it makes things easier to implement. I hope that I laid out my argument here that the opposite is the case.",
      "createdAt": "2020-04-21T03:43:01Z",
      "updatedAt": "2024-02-19T09:06:05Z",
      "closedAt": "2024-02-19T09:06:05Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So to me, this is a core question that I'd like to resolve before finalizing draft-02.\r\n\r\nMy viewpoint has indeed always been that too many individual events and definitions would lead people to support only a minor subset. As it is, even with heavy coalescing, we have a large amount of events today and many implementations only implement a subset of those. \r\n\r\nThat being said, I can see the appeal of splitting things out again, yet that would mean doing that at all layers (e.g., you can't have everything split out at `transport` but keep everything aggregated in `http` (or am I wrong about that?)).\r\n\r\nThere is another aspect of \"backwards compatibility\" with existing implementations that are being re-used (e.g., Lucas' Rust crate, qvis). I'm not sure if people are willing to make major changes at this point. On the other end: we probably shouldn't get bogged down by that at this point yet.\r\n\r\nSo I'd like some more input on this from other active implementers/contributors: @lpardue, @huitema, @jlaine, @nibanks, @mpiraux\r\n\r\n\r\n\r\n",
          "createdAt": "2020-04-21T08:41:07Z",
          "updatedAt": "2020-04-21T08:41:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The crate is easy to update, I don't have many consumers of it right now and I do not have concerns about backwards compatibility. As long as qlog is versioned (which it is) I have no qualms about breaking changes. \r\n\r\nIn summary, qlog crate is not a concern in the decision you make",
          "createdAt": "2020-04-21T15:26:22Z",
          "updatedAt": "2020-04-21T15:26:22Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After further discussion on slack, I think @marten-seemann's overall viewpoint is:\r\n\r\n- Events can be grouped, but only if they (a) logically belong together and/or (b) share the same fields\r\n\r\nThis leads to the following concrete example changes:\r\n- In the example of `connection_state_updated`, if there is a `reason` for the `connection_close` (see #78), that reason won't be present for `connection_attempted` and so it makes sense to split up those events.\r\n- In the example of `metrics_updated`, almost everything happens as the result of receiving an ACK, but `pto_count` does not (due to timer firing), so they should be split up as well. (tangent: max_ack_delay is a constant and should probably be in a `parameters_set` recovery equivalent)\r\n\r\nTentative conclusion: we don't need to split up everything as it stands now, just go through the events and make sure they adhere to the general principle above. I tend to agree with that. \r\n\r\nA prime candidate for re-evaluation is `transport:parameters_set`\r\n\r\n",
          "createdAt": "2020-07-08T08:38:47Z",
          "updatedAt": "2020-07-08T08:48:23Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As indicated in the last comment above, I understand the arguments behind wanting to split up connection_state_updated and metrics_updated. \r\n\r\nI have now however spent a considerable amount of time thinking about splitting up `transport:parameters_set`, and I just don't see how it can be improved practically without introducing a large amount of one-of events or ending up with 2 very similar events in concept. \r\n\r\nConcretely, if parameters_set would indeed only contain the actual TLS-transport \"transport parameters\" from the QUIC draft, we'd need either:\r\n1. a separate `settings_set` event (or `configuration_chosen` or something) to contain other things in there (like chosen ALPN value, chosen version, chosen cipher, whether a retry is always required (e.g., DDoS prevention mode), whether early data is supported, etc.)\r\n2. multiple separate events, one for each thing: `version_selected`, `alpn_selected`, `cipher_selected`, ... etc. \r\n\r\nThis is then made more complicated by other issues that I can't seem to place easily either:\r\n- #28: how to list which ALPNs an endpoint supports (not the same as the one it actually sends/chooses)\r\n- #75: similar for the versions an endpoint supports (especially needed as not all connections send a VNEG containing (some of) this info)\r\n- #88: indicate which parameters were restored for 0-RTT (in that issue, @marten-seemann even advocates splitting up `parameters_set` into `parameters_sent` and `parameters_restored`, creating even more event types). \r\n\r\nAll these things could (for me) conceptually just be part of `parameters_set` (e.g., new `supported_versions` and `chosen_version` fields, logged at appropriate times with the correct owner). \r\nThe other option would be to split this out into several events, ending up with `local_configuration_set`, `configuration_chosen`, `parameters_restored`, etc. next to `parameters_set`... which, tbh, when listing it like that, I'm not sure is less confusing in the long run than having the single `parameters_set`.\r\n\r\nI somewhat have the feeling that I don't understand @marten-seemann's motivations for wanting to split up `parameters_set` the same way I do the two other examples in the first comment of this issue. At the moment, it feels mostly because of the semantics of the term `parameters` which is used for an explicit purpose in the QUIC drafts. Put differently: if we just renamed `parameters_set` to `configuration_chosen` (or similar), would you then still advocate for splitting the event? \r\n\r\nIf the answer is yes, I'd really like a concrete proposal for how to split them up exactly (mainly: how many different events would need to be created? option 1 or 2 above? and why?). \r\n\r\nInput from others in this is of course also greatly appreciated, as currently it seems mostly me and @marten-seemann having conflicting viewpoints. If we can't resolve this easily by tomorrow, I will punt this to draft-03. \r\n",
          "createdAt": "2020-11-01T20:01:16Z",
          "updatedAt": "2020-11-01T20:01:16Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> Put differently: if we just renamed parameters_set to configuration_chosen (or similar), would you then still advocate for splitting the event?\r\n\r\nYes, definitely! This is not about the name, but by the confusing created by stuffing unrelated things into the same event. I'm not sure I understand the motivation for keeping the number of events small, event types are cheap (both in terms of specifying them, in terms of implementing them). \r\nWhat's not cheap is writing tooling that needs to figure out what actual event a \"catch-all\" event like `parameters_set` corresponds to. I doubt that this will be possible without some complicated heuristics. How do I distinguish between TPs restored and TPs taken from a default configuration? Can a tool rely on a `parameters_set` that sets the ALPN doesn't at the same time set QUIC TPs?",
          "createdAt": "2020-11-02T08:18:52Z",
          "updatedAt": "2020-11-02T08:19:17Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I decided to take the middle road for draft-02 to see how it feels.\r\n\r\nI have now split out QUIC versions and ALPN to separate events (`version_information` and `alpn_information`) as those were the two most pressing fields in need of treatment (see also their specific issues, e.g., #74, #28). This does make these things easier to grok and log, I admit. However, doing this for other similar stuff (especially things like TLS ciphers, key share groups, signature algo's, ...) will cause many more event types. \r\n\r\nWhile I agree that event types are cheap in concept, I've always been afraid that adding all these fine-grained events will feel daunting for new qlog implementers or people updating to a new draft or, especially, new tooling implementers (though there haven't been many of those). If most things are in the `parameters_set` event, which they probably want to support anyway, it should feel like less effort to also support additional fields. I'm not saying that's correct in practice, but just to explain why I've been somewhat hesitant to add many new event types. \r\n\r\nI feel that the relatively small scope of qlog in -00 and -01 has contributed to the adoption levels we're seeing, but maybe the argument can be made that now that we have a \"critical mass\" we can start splitting things out, expecting people to incrementally follow along. It does also probably make it easier to make \"dumb\" tools that just plot the data instead of those that do considerably more processing/logic in the tools like qvis (which is the type of tool @marten-seemann is most interested in, IIUC). \r\n\r\nIn short, I'm keeping this open, as this is a main general design decision going forward. \r\n\r\n\r\n",
          "createdAt": "2020-11-03T11:24:58Z",
          "updatedAt": "2020-11-03T11:24:58Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I think one high level design decision needs to be made here first. Is the format of the logs supposed to be optimized for the performance of implementations generating them or for tools that are processing them? Generally, I believe it should be optimized for the ones generating them. Tools can afford the extra time and complexity because they're not in the production loop.\r\n\r\nAssuming there's general agreement with optimizing for the implementations and not the tools, then splitting up events makes sense in my opinion. For most of these things, the instantaneous action/operation that would trigger these events is very often isolated from much of everything else. Therefore trying to force extra packaging or coalescing requires implementations that don't already have it, to manage additional state.\r\n\r\nAs to the worry that all the individual events will make it feel daunting for new users/implementers of qlog, this is not unfounded, but things should be structured such that generally as many events as possible are optional, but you only get the full benefit out of the tools if you implement them all. In my opinion, tools should be **very** resilient to missing events for several reasons:\r\n\r\n1. Not all may be implemented (yet?).\r\n2. Filtering at collection time may be enabled (e.g. for performance reasons).\r\n3. Events may be lost at collection time (log buffer overflows are **very** common).\r\n4. Events containing PII data may not be allowed to be collected in production.\r\n\r\nThis obviously makes things much more complicated for the tool, but that's just unfortunately how things are.",
          "createdAt": "2020-11-03T16:22:39Z",
          "updatedAt": "2020-11-03T16:23:37Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Linking this to #107 for future reference, since that also contains a piece of this puzzle. ",
          "createdAt": "2021-04-23T07:58:18Z",
          "updatedAt": "2021-04-23T07:58:18Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So this discussion was important at a time, but since the \"middle road\" detailed above hasn't received much more input. This was also related to a bunch of other issues that have since been closed (including #58 today) and resolved with adding additional events (e.g., `packets_acked` in #107). \r\n\r\nI still understand the general feedback, but it seems that the major issues have been resolved and splitting things up further would take a lot more design work + re-implementation in a lot of stacks, so I'm closing this without action. ",
          "createdAt": "2024-02-19T09:06:05Z",
          "updatedAt": "2024-02-19T09:06:05Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "MDU6SXNzdWU2MTA2NDIwNTU=",
      "title": "Need to add support for the token in an Initial packet",
      "url": "https://github.com/quicwg/qlog/issues/86",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Probably needs to be in the PacketHeader struct",
      "createdAt": "2020-05-01T08:41:49Z",
      "updatedAt": "2020-09-08T15:31:44Z",
      "closedAt": "2020-09-08T15:31:44Z",
      "comments": []
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU2MjM4MTk0NDk=",
      "title": "How to log transport parameters restored for 0-RTT",
      "url": "https://github.com/quicwg/qlog/issues/88",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "When initiating a 0-RTT connection, the client restores transport parameters that it remembers from the last connection. Currently, it has to use the `parameters_set` event for this, with `owner` equal to `server`.\r\n\r\nAs I've already argued in #85, the `parameters_set` event would benefit from being split up. Taking this issue into consideration, maybe `parameters_sent`, `parameters_received` and `parameters_restored` would be a good fit?",
      "createdAt": "2020-05-24T08:24:27Z",
      "updatedAt": "2020-11-03T11:27:29Z",
      "closedAt": "2020-11-03T11:27:29Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have now added `transport:parameters_restored` and `http:parameters_restored` to help deal with this. I'm personally still not convinced this is better than simply logging them with \"owner\" equal to \"server\" as was the intent for draft-01, but do like the fact that it's more explicit this way. \r\n\r\nIt will depend a bit on how we're going to end up doing `parameters_set` in general (see #85). If we keep that, maybe an \"owner\" value of \"restored\" would be an interesting middle ground. Closing for now though. ",
          "createdAt": "2020-11-03T11:27:27Z",
          "updatedAt": "2020-11-03T11:27:27Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "MDU6SXNzdWU2MjQxMzIzNTg=",
      "title": "Make traditional JSON the default, provide two optimization options",
      "url": "https://github.com/quicwg/qlog/issues/89",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, we utilize what I'd call a \"csv\" optimization, where the `time, category, event name and data fields` omit their keys (these are defined once in `event_fields`, much like csv columns are defined on top) and only log their values. This saves some bytes, but is non-trivial to parse (need to remember the order of the columns to know which value represents what) and to serialize (serializers typically don't like this type of thing).\r\n\r\nThis also breaks a bit with traditional JSON, which just lists the key names for every field as well. Using normal JSON would make it easier to serialize and parse, but increase the file size. \r\n\r\nThere is a third optimized option, which is to replace all keys (and potentially also values) with indices into a lookup table/dictionary. This was discussed in #30 and, especially in combination with compression, seems like a good optimization option. \r\n\r\nSo, to summarize, we have three options:\r\n1. csv column optimization (current default and only supported)\r\n2. pure JSON\r\n3. dictionary optimization\r\n\r\nThe proposal is to switch qlog to nr 2 as default, and present nr 1 and 3 as optional optimizations (which can also be done post-hoc and offline). There would not be a given static dictionary (at least not in draft-02), with the dynamic dictionary always included in the qlog. Implementations are of course free to provide a built-in static dictionary themselves.\r\n\r\nTools would be required to only support nr 2, with optional support for 1 and 3. qvis would support all 3. \r\n\r\nCompression (gzip, brotli or other) would be also described but not mandated (qvis already supports gzip and brotli atm). \r\n\r\ncc @marten-seemann @LPardue\r\n\r\nI also know @martinthomson had strong opinions on this, so it would be interesting to hear from you as I'd like to get this right for -02 now. ",
      "createdAt": "2020-05-25T08:22:55Z",
      "updatedAt": "2020-09-05T16:15:21Z",
      "closedAt": "2020-09-05T16:15:20Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd prefer to only have only 2. The choice of JSON as a logging format already means that we don't care about file size. I see little point in introducing piecemeal improvements to JSON's inefficiency to create what is essentially a new file format.\r\n\r\nIn addition to 2 I'd like to see a binary format (I know I've been nagging with this for a long time) that was built with efficiency considerations from the ground up.",
          "createdAt": "2020-05-25T08:28:11Z",
          "updatedAt": "2020-05-25T08:28:11Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Moving to only/mainly 2 does make a binary format a lot easier I think, as things can be more directly mapped and interchanged (at least from what I know now of protobufs). \r\n\r\nOne option would be to say: qlog draft is format agnostic (but uses JSON as examples because it's readable) and the events can be presented in other formats as well (i.e., qlog just defines the fields and their types per event, not their eventual \"on the wire\" serialization). Tools should provide conversions between other forms and JSON if they want to support alternate forms. Then, anyone can just make e.g., a protobuf format based on that. \r\n\r\nI am planning to move away from TypeScript format for the event definitions anyway, as it's needed to define e.g., the difference between 64-bit numbers, smaller numbers and strings (see #39). That requires a custom mapping to TypeScript/JSON anyway, so a protobuf (or similar) mapping fits in that logic too. ",
          "createdAt": "2020-05-25T09:41:36Z",
          "updatedAt": "2020-05-25T09:41:36Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I think there's a good chance I could switch the `qlog` crate to 2) without an API change. Addding an API method would allow user selection, and be non-breaking in the first case.\r\n\r\nIt seems nice if logs could self-identify the serialization format, otherwise you're relying on tools to do heuristics. This could be done with file extensions, or qlog parameters, or file magic. It's probably hard to get complete coverage but something might be a quick win.",
          "createdAt": "2020-05-25T13:09:30Z",
          "updatedAt": "2020-05-25T13:09:46Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I was wondering if CBOR should be the standard format. The representation is very similar to JSON, but it provides better typing support:\r\n1. it can unambiguously represent uint64s (so #39 would be solved)\r\n2. it supports byte strings, eliminating the need for byte to string conversions (as remarked in #30). Those happen quite often, e.g. for connection IDs, retry token, stateless reset tokens etc.\r\n\r\nI'm not sure human readability should be a goal. For my part, I've never felt the urge to look at a raw qlog file, mostly thanks to amazing tools like qvis. I don't expect this situation to shift in favor of viewing raw files in the future, if at all, more tools will make it even less necessary to do so.\r\nThat being said, CBOR could easily be converted to a human-readable file format, should the need to manually inspect a trace arise.\r\n\r\nThere are also moderate file size savings, but those wouldn't be the main motivation here. CBOR of course doesn't provide any compression of map keys / values, so I'd expect CBOR qlogs to still be quite wasteful. Not sure if there's a schema-less serialization format that can use something like a dictionary to compress commonly used identifiers.",
          "createdAt": "2020-05-26T03:40:57Z",
          "updatedAt": "2020-05-26T03:44:55Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Finished this transformation in f5db7cdc8cd0cf37bfe5f1b0b4c54fc56ffc5f28.\r\n\r\nDraft 02 will use default JSON as prime format, with NDJSON for streaming. CBOR is discussed as an option, but provides few benefits over normal JSON when paired with compression. \r\n\r\nThe text now also includes (limited) discussion and reasoning on the choice of JSON as the default format, per tests mainly discussed in #30. \r\n",
          "createdAt": "2020-09-05T16:15:20Z",
          "updatedAt": "2020-09-05T16:15:20Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWU2MjQ3MTE5Mjg=",
      "title": "Add events indicating reasons for stalls",
      "url": "https://github.com/quicwg/qlog/issues/90",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "future-versions"
      ],
      "body": "For example, an application might have more data ready to send, but cannot due to Flow Control or Congestion Control or Anti-Amplification limits. \r\n\r\nThese are currently only observable for the Flow Control case and only if the sender sends *_BLOCKED frames (which is optional). \r\n\r\nI'm not sure in which category this type of event would belong though... maybe look at msquic's handling (they have this type of event for sure). \r\n\r\ncc @scw00",
      "createdAt": "2020-05-26T08:50:30Z",
      "updatedAt": "2021-08-18T10:07:16Z",
      "closedAt": "2021-08-18T10:07:16Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Duplicate of more detailed #132 ",
          "createdAt": "2021-08-18T10:07:16Z",
          "updatedAt": "2021-08-18T10:07:16Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWU2MjQ3MTQ4MzM=",
      "title": "Add mechanism for tracking coalesced packets",
      "url": "https://github.com/quicwg/qlog/issues/91",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "Currently, this can be done implicitly by looking at `datagrams_sent` and `datagrams_received` events, but: a) these are very chatty if enabled for the entire connection and b) it's still implicit.\r\n\r\nOne proposed option (cc @marten-seemann) would be to add an optional `datagram_id` field to the `packet_*` and `datagrams_*` events that allows explicit correlation. This id would be an implementation-specific thing though, since QUIC itself does not define it (can be as easy as an implementation incrementing a counter).\r\n\r\nAnother point from Marten:\r\n> Note that this would also allow to correlate packets that processed at different times: assume that one packet contained in a datagram can be processed immediately, but it is coalesced with a packet of an encyrption level that the endpoint doesn\u2019t have keys for, and needs to buffer first\r\n\r\nIn that case, we probably also need to add the datagram_id to the `packet_buffered` event",
      "createdAt": "2020-05-26T08:54:28Z",
      "updatedAt": "2020-11-01T20:32:43Z",
      "closedAt": "2020-11-01T20:32:43Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "And to `packet_dropped`.",
          "createdAt": "2020-05-26T09:07:47Z",
          "updatedAt": "2020-05-26T09:07:47Z"
        }
      ]
    },
    {
      "number": 94,
      "id": "MDU6SXNzdWU2NDIzNTgwMDc=",
      "title": "Add support for retry token and integrity tag",
      "url": "https://github.com/quicwg/qlog/issues/94",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "future-versions"
      ],
      "body": "Related to #86 , probably also best at home in the PacketHeader struct.\r\n\r\nProposal:\r\n- use a single `token` field for both retry and initial tokens\r\n- use a single `token_length` field for initial (explicit) and retry (implicit), `integrity_tag` field for retry",
      "createdAt": "2020-06-20T11:16:37Z",
      "updatedAt": "2020-11-18T10:19:57Z",
      "closedAt": "2020-11-18T10:19:57Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I don\u2019t think we need to log the integrity tag. We also don\u2019t log the AEAD tag for normal packets.",
          "createdAt": "2020-06-20T12:37:16Z",
          "updatedAt": "2020-06-20T12:37:16Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "It would probably be interesting to log if the token is a Retry token or a NEW_TOKEN token.\r\nFor the client, this bit of information is trivially available, for the server it is after it unprotects the token (assuming unprotecting succeeds), as servers are required to be able to distinguish between Retry and NEW_TOKEN tokens.",
          "createdAt": "2020-07-08T08:58:20Z",
          "updatedAt": "2020-07-08T08:58:20Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was partially fixed in https://github.com/quiclog/internet-drafts/commit/ac00848b50c1da3feaf50f43938e962a091396b0. That was just the most straightforward change though, just adding fields that allow logging the tokens.\r\n\r\nThis does not yet allow differentiating NEW_TOKEN from Retry and we currently have no way of keeping those two separate (or e.g., to log that a NEW_TOKEN was successfully accepted). \r\n\r\nI am unsure about the design for that though... my gut tells me to move to separate `token_created` and `token_processed` events, which would in turn also allow logging the token's raw contents instead of logging them in the `packet_*` events. \r\n\r\nExample:\r\n```\r\ntoken_created\r\n\ttype: \"retry\"|\"resumption\"|\"stateless_reset\",\r\n\r\n       metadata:any, // to allow implementations to log which field are contained within an (encrypted) token\r\n\t\r\n\traw_length?:uint32,\r\n\traw?:bytes\r\n\r\ntoken_processed\r\n\ttype: \"retry\"|\"resumption\"|\"stateless_reset\",\r\n\tstatus: \"accepted\"|\"rejected\",\r\n\t\r\n       metadata:any, // to allow implementations to log which field are contained within an (encrypted) token\r\n\r\n\traw_length?:uint32,\r\n\traw?:bytes\r\n\r\n\ttrigger: why accepted/rejected \r\n\t\tinvalid_format\r\n\t\tinvalid_source\r\n\t\tinvalid_contents\r\n\t\t-> NOTE: for retry, this should also lead to a connection close with INVALID_TOKEN\r\n\r\n```\r\n\r\nHowever, I'm not sure this is the best approach. I'm going to mark this extension for draft-03 and keep the more straightforward option for draft-02. ",
          "createdAt": "2020-09-08T15:37:20Z",
          "updatedAt": "2020-09-08T15:37:20Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "MDU6SXNzdWU2NTMwODU3NTI=",
      "title": "remove the time_units configuration",
      "url": "https://github.com/quicwg/qlog/issues/95",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "All time values are encoded as floats, so it doesn't make any difference if we encode them in ms or in \u03bcs.\r\n\r\nRemoving the configuration option makes it easier to implement qlog parsers, since there's less state to carry around to parse events.",
      "createdAt": "2020-07-08T08:09:14Z",
      "updatedAt": "2020-07-11T20:49:16Z",
      "closedAt": "2020-07-11T20:49:16Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While I agree it makes it more difficult to parse, I'm not sure we can remove this?\r\n\r\nWould you advocate for forcing implementation to log either ms or \u03bcs (and do x1000 or /1000 if they use the other internally) then? Currently, I think we have about 4 implementations doing \u03bcs. ",
          "createdAt": "2020-07-08T08:12:48Z",
          "updatedAt": "2020-07-08T08:12:48Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "It doesn't matter which one is removed. Currently, I'm logging in ms (just because it's the default).\r\nChanging this to \u03bcs would basically just being a change from calling `duration.Milliseconds()` to `duration.Microseconds()` (see https://github.com/lucas-clemente/quic-go/blob/master/qlog/event.go#L14). I assume it's the same for other implementations: You have one (language/implementaton-specific) time representation, and you convert that to whatever unit you export to qlog.",
          "createdAt": "2020-07-08T08:27:47Z",
          "updatedAt": "2020-07-08T08:27:47Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWU2NTMxMDY1MTI=",
      "title": "in_recovery is a congestion_state_updated event and doesn't belong in metrics_updated",
      "url": "https://github.com/quicwg/qlog/issues/96",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "indicating whether the CC has entered recovery can currently be done in two ways, should probably removed this from `metrics_updated`.\r\n\r\ncc @marten-seemann ",
      "createdAt": "2020-07-08T08:40:20Z",
      "updatedAt": "2020-07-08T09:29:59Z",
      "closedAt": "2020-07-08T09:29:59Z",
      "comments": []
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWU2NTMxMTA2OTA=",
      "title": "Indicate (encoded) sizes",
      "url": "https://github.com/quicwg/qlog/issues/97",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "Currently we do not have many fields for indicating (compressed) sizes of things.\r\n\r\nWe have the `packet_size`, but this is in the wrong place (#40) and `payload_length` (though it's not well-defined whether packet_size includes the TLS suffix). \r\n\r\nHowever, we lack size indicators for datagrams and, especially frames. When creating the qvis packetization diagram, this was very annoying, as I'd have to reconstruct the encoded frame headers to properly render those (and even then there might be rounding issues if the sender didn't encode things in the absolute minimum of bytes allowed). \r\n\r\nIn comparison, wireshark output does include exact sizes for these fields for TCP/TLS/H2 and this was quite handy. \r\n\r\nAnother point: need some way to indicate the used TLS AEAD tag length (though that should be constant for the entire connection and depends on the used cipher IIUC. For TCP+TLS from Wireshark I also had to manually calculate this from the cipher definitions though, which was a PITA). \r\n\r\nFinally, make terminology consistent (_size vs _length)\r\n",
      "createdAt": "2020-07-08T08:46:33Z",
      "updatedAt": "2020-11-02T16:54:20Z",
      "closedAt": "2020-11-02T16:54:20Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From a discussion on slack, most are in favor of adding AEAD length to the general packet_size field (one reasons is because the tag also contributes to cwnd calculation)",
          "createdAt": "2020-08-06T14:10:11Z",
          "updatedAt": "2020-08-06T14:10:11Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We have a bit of a weird situation with packet_size, payload_size and header_size, in that if you have 2, you can calculate the third from those... so do we want to specify all three? \r\n\r\nI would reckon that packet_size and payload_size will typically be readily available to implementations, but header_size might be more difficult to come by (as headers can be of varying sizes, while payload is \"the rest of the packet after the header has been processed\"). \r\n\r\nFinally, there is overlap with what we currently call \"raw_length\" if we're logging the full raw byte contents of the packet (in the \"raw\" field, which we currently name \"raw\" across all events for consistency). To keep naming consistent, you'd want this \"raw_length\" here as well, but you also kind of want \"packet_size\" to show the core semantics (especially as I'd suspect most won't log the raw values (and accompanying \"raw_length\") in most places, but do log packet_size). A similar remark for datagram_size in the datagram_* events... do we live with having the same field defined twice with different names or do we remove packet_size and datagram_size and explain that people should use raw_length for those instead (I'm personally tending to this latter option).\r\n\r\nCould use some input on this @marten-seemann, @huitema, @dtikhonov\r\n\r\n",
          "createdAt": "2020-09-07T20:00:22Z",
          "updatedAt": "2020-09-07T20:00:22Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ended up not logging the header_length and writing out how it can be calculated from total length and payload length and aead length.\r\n\r\nCurrently, aead length is logged separately in `transport:parameters_set`, which is not optimal, but good enough for now until we figure out what to do with that event and how to split it up (see #85)\r\n\r\n\r\nFinally, I ended up keeping explicit length fields when they are used in the QUIC/H3 drafts. This is not the case for the `packet_size` field, so that has now been changed to `raw.length` instead. I'm not entirely enamored by this, as arguably .packet_size was clearer, but since we're moving packet_size out of Header anyway (see #40), it felt best to keep things consistent and punt this to the new RawInfo approach. \r\n",
          "createdAt": "2020-11-02T16:54:20Z",
          "updatedAt": "2020-11-02T16:54:20Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWU2NTMxMTYzNDc=",
      "title": "make it possible to log persistent congestion",
      "url": "https://github.com/quicwg/qlog/issues/100",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "design",
        "current-version"
      ],
      "body": "This would be *really* important for generating metrics.\r\n\r\nLogically, it's a congestion event, but I'm not sure if it would probably make sense to add this as a state to the `congestion_state_updated` event, because once you declare persistent congestion, your congestion controller enters either slow start or congestion avoidance (not sure which one, haven't implemented persistent congestion yet), which are already `congestion_state_updated` events.",
      "createdAt": "2020-07-08T08:54:37Z",
      "updatedAt": "2024-02-19T08:59:03Z",
      "closedAt": "2024-02-19T08:59:03Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So currently this is done using a trigger of \"persistent_congestion\" on the `congestion_state_updated` event (i.e., https://quiclog.github.io/internet-drafts/draft02/draft-marx-qlog-event-definitions-quic-h3.html#name-congestion_state_updated).\r\n\r\nReading your issue above, that seems like all that's needed? I know you have more experience with persistent_congestion at this point, so wondering if that is enough or we need something else?  ",
          "createdAt": "2020-09-08T12:26:44Z",
          "updatedAt": "2020-09-08T12:26:44Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm unsure if this is still an issue given my comment above @marten-seemann? ",
          "createdAt": "2020-10-31T13:52:21Z",
          "updatedAt": "2020-10-31T13:52:21Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "What's the status here. Close it?",
          "createdAt": "2022-09-07T23:51:20Z",
          "updatedAt": "2022-09-07T23:51:20Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "MDU6SXNzdWU2NTMxMjM3NjI=",
      "title": "Combine category and event type",
      "url": "https://github.com/quicwg/qlog/issues/101",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, we have two separate fields for category and event type.\r\n\r\nIn a default JSON form, you'd have:\r\n```\r\n{\r\n    category: \"transport\",\r\n    type: \"parameters_set\"\r\n}\r\n```\r\n\r\nHowever, the event type names (e.g., `parameters_set`, `state_updated`) aren't unique to the categories at the moment. \r\n\r\nThis can lead to some issues:\r\n- Processing qlog requires you to always check the category as well (cannot just look at the event_type)\r\n- Makes them difficult to encode in formats like protobuf (e.g., https://github.com/quiclog/pcap2qlog/blob/binary/src/converters/types/qlog.proto#L54) (and I assume things like serde as well @LPardue?) because you cannot easily de-serialize based just on the type-name.\r\n\r\nOne solution would be to combine both into one field:\r\n```\r\n{\r\n    type: \"transport:parameters_set\"\r\n}\r\n```\r\n\r\nThis should make it easier to de-serialize just based on the type field (and make it into an enum) and easier to do a `switch` when processing events. \r\n\r\nAnother option would be to make sure each event has a unique name, but that would come down the pre-pending the category (or something similar) anyway afaict (e.g., `transport_parameters_set`), which is basically the same thing. \r\n\r\nI don't see many use cases where you'd only want to log one category (and thus could leave that out and just log the event names to save some space). I also don't know if compression would be that much worse overall if we'd combine the two into one field. If we'd move to regular JSON as the default (#89), it would probably save space, as then we'd only have a single field per-object instead of 2 (as in the examples above).\r\n\r\nWhat do people think? CC @LPardue  @marten-seemann @mpiraux @triplewy @mikkelfj @nibanks @jlaine\r\n\r\n \r\n",
      "createdAt": "2020-07-08T09:04:43Z",
      "updatedAt": "2020-09-05T16:18:38Z",
      "closedAt": "2020-09-05T16:18:38Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Makes sense to me. I support making this change.",
          "createdAt": "2020-07-08T09:17:31Z",
          "updatedAt": "2020-07-08T09:17:31Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "MDU6SXNzdWU2NTMxMjQ1OTY=",
      "title": "remove redundant length fields",
      "url": "https://github.com/quicwg/qlog/issues/102",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "Once we require hex-encoding for byte-fields (which, as far as I can see from other peoples' qlogs, is already the de-facto standard), we don't need length fields any more. This applies to the `scil` and `dcil` in the `Header` (as well as the proposed token length in #94), the `NewTokenFrame`, `NewConnectionIDFrame` (and probably also the QPACK events, but I'm not an expert on those).",
      "createdAt": "2020-07-08T09:05:51Z",
      "updatedAt": "2020-11-02T16:50:46Z",
      "closedAt": "2020-11-02T16:50:45Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I kind of disagree, as I think an important use case is where you'd not want to log the raw values but only the lengths. \r\n\r\nWe can argue whether that's the case for the CIDs of course, but for tokens and qpack data (and, obviously, payloads), I think people should have the option to not log the raw values. \r\n\r\nThis flows from privacy/security concerns, as well as storage efficiency for larger deployments. \r\n\r\nI do think we could add text stating something like \"if you log the raw values in hex, the length field is redundant, and tools SHOULD be able to derive length from hex\"?",
          "createdAt": "2020-07-08T09:13:08Z",
          "updatedAt": "2020-07-08T09:13:08Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point. I can see why you want to log tokens (since they create a correlation spanning two separate connections).\r\n\r\n> I do think we could add text stating something like \"if you log the raw values in hex, the length field is redundant, and tools SHOULD be able to derive length from hex\"?\r\n\r\nI'd make this an even stronger statement: \"\"if you log the raw values in hex, the length field is redundant and SHOULD (or MUST?) be omitted. Tools MUST be able to derive length from hex\".",
          "createdAt": "2020-07-08T09:20:09Z",
          "updatedAt": "2020-07-08T09:22:53Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by above commits.\r\n\r\nMain draft now explains how truncated raw byte values should be accompanied by a length field and that tools should be able to derive the length field from the raw byte values. \r\n\r\nEvent definitions draft references this explicitly when discussing the RawInfo approach. ",
          "createdAt": "2020-11-02T16:50:45Z",
          "updatedAt": "2020-11-02T16:50:45Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWU2NTMxMzAxNTY=",
      "title": "consider removing StreamFrame.raw",
      "url": "https://github.com/quicwg/qlog/issues/104",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design",
        "future-versions",
        "privacy"
      ],
      "body": "I can't see how logging the exact contents of a STREAM frame could facilitate debugging / analysis of QUIC connections.\r\n\r\nArguably, a transport-level logging system should not log application data exchanged, as this might expose user data to places where it doesn't belong. While qlog can't prevent implementations from adding additional JSON fields to existing events, it should not encourage this behavior.",
      "createdAt": "2020-07-08T09:14:00Z",
      "updatedAt": "2023-01-13T15:03:54Z",
      "closedAt": "2023-01-13T15:03:53Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While I agree from a security/privacy perspective that it shouldn't be encouraged, I disagree somewhat about the non-usefulness in debugging (esp. if you go beyond just H3 and look at things like DoQ or MASQUE). \r\n\r\nTwo direct alternatives I can see at the moment:\r\n- Remove from QUIC STREAM, but keep it on H3 DATA (though this means people can't easily get this without also logging H3/app-layer events, which e.g., things like quant might not like)\r\n- Add a generic `raw` and/or `raw_payload` field for all events to use (much like what we have for `trigger`). This makes it less obvious per-event (so less encouraged you might say) while still keeping a common name for interoperable tooling. \r\n\r\nOverall though, I'd vote to just keep it as-is. While it shouldn't be encouraged, it should imo be -possible- to express in the format for specific use cases. I'd even go one step further and add an explicit `raw` field to the datagram_* events (especially `datagram_dropped`) as I've seen several times in the slack that packets aren't being decoded correctly and having the raw values available could help there. \r\n\r\nIf we do keep `raw`, I'd propose to work out a scheme to allow logging only the first x-bytes though (e.g., `raw: 0xABABCD...(436)` indicating there were 436 more bytes not logged). ",
          "createdAt": "2020-07-08T09:23:36Z",
          "updatedAt": "2020-07-08T09:27:44Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added a generic \"RawInfo:data\" field in the last commit. Byte-fields can be logged in a truncated form now as well (see main draft), which alleviates some of the privacy issues. \r\n\r\nKeeping this issue open to remember to add stringent prohibitions on logging/exposing raw data in the privacy section later. \r\n",
          "createdAt": "2020-11-02T16:49:14Z",
          "updatedAt": "2020-11-02T16:49:14Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is now in the privacy considerations and cross-referenced in several places.",
          "createdAt": "2023-01-13T15:03:53Z",
          "updatedAt": "2023-01-13T15:03:53Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWU2NTUwMDg1NDk=",
      "title": "Log Retry and Connection in same Qlog file, use ODCID for indentification",
      "url": "https://github.com/quicwg/qlog/issues/105",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "design",
        "high-level-schema",
        "current-version"
      ],
      "body": "Many implementations identify the Qlog file using the \"Initial DCID\" used by the client. In the case of Retry, this results in two Qlog traces: one identified by the original DCID that contains the first initial packet of the client and the Retry packet that the server produced, and a second one identified by the Initial DCID used in the subsequent connection.\r\n\r\nMy proposal is to use a single file for the retry and for the next connection, identified by the ODCID. But I wonder whether that's going to break something.",
      "createdAt": "2020-07-10T20:06:03Z",
      "updatedAt": "2023-10-18T15:12:15Z",
      "closedAt": "2023-10-18T15:12:15Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "The current spec kind of gives up on the issue. It says \"Note that this can make it difficult to match logs from different vantage points with each other. For example, from the client side, it is easy to log connections with version negotiation or stateless retry in the same trace, while on the server they would most likely be logged in separate traces.\" My point is that it can be solved on the server, if the server keys logging events with the ODCID.",
          "createdAt": "2020-07-10T20:11:56Z",
          "updatedAt": "2020-07-10T20:11:56Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> My point is that it can be solved on the server, if the server keys logging events with the ODCID.\r\n\r\nThat's correct, and it's a trivial thing to do. The server needs to encode the ODCID in the token anyway, to be able to send it in the transport parameters. In fact, that's [how quic-go does it](https://github.com/lucas-clemente/quic-go/blob/e7fa420e264c4d319625c6dbf7cdf1c7668e7535/server.go#L452-L456).",
          "createdAt": "2020-07-11T01:36:30Z",
          "updatedAt": "2020-07-11T01:36:46Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema I'm not 100% sure what the issue is here.\r\n\r\nThe current qlog text explicitly mentions using the ODCID as filename for qlog files as the \"lowest common denominator\". Furthermore, qlog files can contain multiple individual traces, as the `traces' property is an array. So it's already perfectly possible to log one trace for the first connection and then a second trace for the retried one after that. As @marten-seemann said, there are people doing just that already. Maybe the problem is in the wording? That you interpret a `trace' as a single file, and I interpret it as a list of events, where 1 file can contain multiple traces? \r\n\r\nAnother approach would be to use the `group_id' field and not set that to an ODCID but assign that a sort of internal server number based on IP+port or something to uniquely identify a client across attempts. That would work even for \"version negotiation\", as there you don't have the luxury of having a stable ODCID. I don't want to mandate this type of thing in the text though, since it all implies the server needs to keep extra state around to match up connections, and some (most?) won't want to do that (in production). \r\n\r\nIn short: I'm not sure what you'd like me to change to the text at this time. \r\n\r\n\r\n\r\n",
          "createdAt": "2020-07-11T15:53:59Z",
          "updatedAt": "2020-07-11T15:53:59Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> So it's already perfectly possible to log one trace for the first connection and then a second trace for the retried one after that. As @marten-seemann said, there are people doing just that already.\r\n\r\nActually, that's not what I'm doing. I'm not logging the first Intitial received and the Retry sent at all on the server side (only on the client side), since there's no reasonable way of logging events that happen outside of a connection (see #106).",
          "createdAt": "2020-07-12T01:08:58Z",
          "updatedAt": "2020-07-12T01:08:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I might suggest that the people that care about logging Retry are those using it for DoS mitigations, and they have a whole bunch of other factors to consider too.\r\n\r\nLet's see if the current text can be minimally changed for clarity. If someone with the problem wants to propose a concrete suggestion that differs from this in a PR that would be great but lets not sit around forever in anticipation.",
          "createdAt": "2022-09-08T00:01:27Z",
          "updatedAt": "2022-09-08T00:01:27Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I would claim that this issue was resolved by https://github.com/quicwg/qlog/pull/279. Unless anybody objects within the next 24h, I'm going to close this issue and the associated PR (#213).",
          "createdAt": "2023-10-18T11:27:02Z",
          "updatedAt": "2023-10-18T11:27:02Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@marten-seemann agreed, this can be closed. ",
          "createdAt": "2023-10-18T14:56:49Z",
          "updatedAt": "2023-10-18T14:56:49Z"
        }
      ]
    },
    {
      "number": 106,
      "id": "MDU6SXNzdWU2NTUwMTI5OTY=",
      "title": "Logging events outside of connections",
      "url": "https://github.com/quicwg/qlog/issues/106",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Servers typically notice events happening outside of connections: packets for which the DCID is not recognized, malformed Initial packets, etc. When debugging and looking at both client traces and server traces, it might be useful to match a client packet with an out-of-connection event at the server. I wonder how to do that within the qlog framework.",
      "createdAt": "2020-07-10T20:15:49Z",
      "updatedAt": "2020-09-05T16:18:06Z",
      "closedAt": "2020-09-05T16:18:06Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I encountered the same issue. I think the root of the problem is that qlog is not streamable. Otherwise, you could just have a `server.qlog` and append every event that's not matched to any connection.\r\n\r\nSure, you can always play some tricks to work around this issue, like exporting a server qlog every one hour, for example. Downside is, of course, that you wouldn't have access to the events that happened with the last hour.\r\n\r\nBroadening the scope of this issue, I'd say the root cause is that qlog is trying to make it possible to have multiple traces per file. Sure, it's possible, but only by giving up on streamability. I'm not sure if that's a feature worth having though, considering how much complexity it creates for the format itself (and for parsers that want to support it). I'd actually prefer to have a format that looks something like this:\r\n```\r\n<header>\r\n   config options, vantage, other trace-related metadata\r\n</header>\r\n<events>\r\n\r\n<events>\r\n```\r\n",
          "createdAt": "2020-07-11T01:34:15Z",
          "updatedAt": "2020-07-11T01:34:15Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, here again (like with #105, which I see as similar to this, maybe read my reply there first) I'm not sure what the issue is.\r\n\r\nIf an event cannot be matched to a connection, it's difficult to log it together with other events without keeping extra state and doing some work. That is usually relatively easy though: you can e.g., match IP+port of a malformed initial to other proper packets from the same source and aggregate them in the same trace based on that. Then you do need to add extra logic for migration etc. but it's certainly possible I'd say? \r\n\r\nAnother option is as @marten-seemann mentions to have a single big `server.qlog' that includes all the events that don't nicely match to a connection (this could also include things you reply to with a version negotiation for example). I think Lars does this for quant. To me, it depends on how you want to debug your setup and how you approach these types of errors. I'm not sure if there needs to be more text on this? \r\n\r\n-----------\r\n\r\nI am however unsure about why this `server.qlog` wouldn't be possible with the JSON-based setup... each qlog event is self-contained (it's a single array with some values and in draft-02 will be a single object) and can trivially be appended to a file by prepending it with a `,`. \r\n\r\nThe thing that makes a JSON file that was \"streamed\" a bit more awkward is that you'd need to close it with a `]}]}' to be \"valid JSON\". However, qvis for example includes a fallback to a streaming parser (http://oboejs.com) to deal with files that don't do this and it seems to work perfectly fine (was initially added for cases where the endpoint shuts down unexpectedly and doesn't have time to print those final closing characters). Furthermore, this case is trivially fixed by a post-processor that adds those characters if they're not found at the end of a file. \r\n\r\nAm I missing something crucial in this discussion on streaming? Several people have brought this up (e.g., @martinthomson) but I have always considered this a non-issue. If we were switch to e.g., a csv-format, you'd have to write custom parsers for that as well (which would likely be slower than optimized, built-in JSON parsers), while now at least you get a free JSON parser if your files are well-formed (which, from my experience, most are or can be made to be). \r\n\r\nI also don't agree this is due to having support for multiple traces in one file. You can have just a single trace and use `group_id' to split things out later. The only thing this adds is the extra `]}`. Even if we left that out and stayed with JSON, you'd still be stuck with the other `]}' to close the `<events>` list and total object. \r\n\r\nFinally, especially for @marten-seemann, these might be moot points for draft-02, as that should make it much easier to use protobufs or similar instead of JSON. Still, I'd love some feedback on my points above, to make sure I'm not missing a key point in this discussion. \r\n\r\n",
          "createdAt": "2020-07-11T16:12:46Z",
          "updatedAt": "2020-07-11T16:12:46Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am however unsure about why this server.qlog wouldn't be possible with the JSON-based setup... each qlog event is self-contained (it's a single array with some values \r\n\r\nI'm not sure if I understand your point. I thought this is not the case. You can have multiple traces per file, so you'd have a file where events are appended at different locations within that file.\r\nThis is why I suggested getting rid of this corner case by saying that `1 qlog file == 1 trace`. That would simplify things quite a bit.\r\n\r\n> Am I missing something crucial in this discussion on streaming? Several people have brought this up (e.g., @martinthomson) but I have always considered this a non-issue.\r\n\r\nI'd be curious to hear what other peoples' requirements are here.\r\nFor me, streaming means that you have a valid at any given moment. With the qlog format that's not possible since you'll always be missing some closing `]` and `}`.\r\nImagine you want to build a tool like the UNIX command line utility `tail` for qlog, which outputs events as soon as they come in. This would be hard to do, as you're dealing with invalid JSON most of the time. \r\nThings are further complicated by the fact that JSON doesn't define the order of the fields within an object (for example, it would be valid qlog if `common_fields` comes after the `events`, and iirc, I've seen at least one qlog implementation write files like that).\r\n\r\n>  If we were switch to e.g., a csv-format, you'd have to write custom parsers for that as well (which would likely be slower than optimized, built-in JSON parsers), while now at least you get a free JSON parser if your files are well-formed (which, from my experience, most are or can be made to be).\r\n\r\nWhen I think of slow encoders, I think of JSON...\r\nThat being said, I don't think JSON buys us a lot here. The fact that qlogs have `common_fields` and `event_fields`, and that events are not exported as objects but as arrays makes it quite cumbersome to write a qlog exporter / parser. As I understand, the `event_fields` are effectively an attempt to build in some compression into the format, an attempt rendered moot by the fact that JSON is an inherently space-inefficient file format. gzipping a tyical qlog gives you a file smaller than 10% of the original file size... so I can't help to think of this as a premature optimization.",
          "createdAt": "2020-07-12T02:32:10Z",
          "updatedAt": "2020-07-12T02:32:10Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "+1 on premature optimization. I tripped on the event_fields when writing a python parser for the qlogs, and I see that others have similar issues. If you want to reduce volume, it would be simpler to just have shorter names for the variables.",
          "createdAt": "2020-07-12T02:37:29Z",
          "updatedAt": "2020-07-12T02:37:29Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "+1 on format too. I would very much like to be able to just add an event by appending the data at the end of the log file. I can do that with my binary logs, and then call a converter to produce the qlog and add the required set of curly and square brackets at the end. But with an actual qlog file, I would have to roll back the end of the file, remove the end brackets, write the event, and then add the brackets again. Kind of, not funny.\r\n",
          "createdAt": "2020-07-12T03:09:04Z",
          "updatedAt": "2020-07-12T03:09:04Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this was resolved with the introduction of the streaming NDJSON option (discussed in #109) and other options I outlined in https://github.com/quiclog/internet-drafts/issues/106#issuecomment-657087933. If not, feel free to re-open. \r\n\r\n\r\n",
          "createdAt": "2020-09-05T16:18:06Z",
          "updatedAt": "2020-09-05T16:18:06Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWU2NTU1NjA4MzM=",
      "title": "Do we need an acked_packet event?",
      "url": "https://github.com/quicwg/qlog/issues/107",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "We have a `lost_packet` event, but no corresponding `acked_packet` event. That event would fire when a packet is acknowledged and removed from the map of sent packets.\r\n\r\nA parser that wants to track when a packet is (first) acknowledged would have to build a map of sent packets, and remove packets from that map when they are either acknowledged, declared lost or when the packet number space is lost.",
      "createdAt": "2020-07-13T03:49:47Z",
      "updatedAt": "2020-11-01T20:34:19Z",
      "closedAt": "2020-11-01T20:34:19Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So this is similar to \"do we need a `connection_closed` event?\" in that there's a question of how many \"redundant\" ways we can have to log the same event. \r\n\r\nFor connection close and packet acked, the reasoning initially was that those could be fully parsed from the corresponding frames inside `packet_sent` and `packet_received` and thus didn't need an extra event. \r\n\r\nI can now see the reasoning for wanting a specific `connection_closed` event (e.g., logging an internal reason that you don't send over the wire), but I'm not sure what a separate `acked_packet` event would give us. For some use cases it would make it easier (if you're not parsing frames inside the `packet_*` events), but in most, I feel it would make things more complicated (do I need to log both? Do I skip logging of ACK frames if I do `acked_packet`? etc.). I do see that receipt of an ACK frame is potentially different from adding/removing to the internal packet datastructure (given duplicate acks), but not sure that should be exposed in a default way in qlog (we have many more of those type of `implied` actions that are expected to happen upon frame processing. Though there is some precedent of exposing that type of thing, e.g., in `data_moved`). In most cases, it was expected that tools could derive this type of action from the logged frames (e.g., like how I track retransmissions and gaps in streams in qvis: those are also not explicitly logged).",
          "createdAt": "2020-07-13T14:15:51Z",
          "updatedAt": "2020-07-13T14:18:11Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Personally, I agree with @marten-seemann. MsQuic logs (to [ETW](https://docs.microsoft.com/en-us/windows/win32/etw/event-tracing-portal)) events or state changes for things. For qlog, we then have a converter. We don't log the contents of every packet or frame. For packets, we track when they're created, acknowledged, dropped, assumed lost, deemed spuriously lost, etc. IMO, tools that process the logs should not have to know how to process a logged ACK frame to then go calculate which in-flight packets have now been acknowledged. Another reason, is that our logging system doesn't assume full state was contained within the log file. The logs may have been started mid run or the fixed fixed log buffer rolled over. In those cases, you wouldn't necessarily have the created event for a packet and wouldn't know what is already in-flight.",
          "createdAt": "2020-07-13T14:30:59Z",
          "updatedAt": "2020-07-13T14:30:59Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Paraphrasing an argument I made in a Slack conversation:\r\n \r\nI can see @rmarx's argument that logging both the ACK frame and `packet_acked` is kind of redundant, given that a parser can build a copy of the packet map. However, I\u2019d rather log a `packet_acked` event instaed of the content of ACK frames. I care more about the state changes than about what redundant ACK ranges get serialized on the wire.",
          "createdAt": "2020-08-03T15:09:41Z",
          "updatedAt": "2020-08-03T15:09:41Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "MDU6SXNzdWU2Njc2MjkwNjI=",
      "title": "Add streaming option",
      "url": "https://github.com/quicwg/qlog/issues/109",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Current thinking is to allow http://ndjson.org and to log the qlog header information as a separate object on top. \r\nThis would remove the possibility to log multiple traces in the same qlog file if it uses the streaming option, so users would need to use `group_id` in those cases.\r\n\r\nWould also require the addition of a \"format\" field to the qlog metadata header (though we probably need that anyway if we want to keep support for other JSON-based optimizations like `event_fields`.\r\n\r\nWe first need to check how this plays with oboe.js in qvis though, to see if we need to add another parser in the mix. \r\n\r\nSee also #106 and #2 for more discussion.\r\n\r\nFor comparison:\r\n```\r\nDraft-01 would look like this (if, like me, JSON serializers would be too lazy to add quotes):\r\n{\r\n    version: draft-01,\r\n    traces: [\r\n        {\r\n             vantage_point: client,\r\n             common_fields: [ ... ],\r\n             event_fields: [ ... ], \r\n             events: [\r\n                 [ 55, transport, packet_sent, { ... } ],\r\n                 [ 66, transport, packet_received, { ... } ],\r\n                 ...\r\n             ]\r\n        }\r\n    ]\r\n}\r\n\r\nDraft-02 would be more like:\r\n{\r\n    version: draft-02,\r\n    format: \"ndjson\",\r\n    trace: {\r\n             vantage_point: client,\r\n             common_fields: [ ... ]\r\n     }\r\n}\r\n{ time: 55, name: \"transport:packet_sent\", data: { ... } }\r\n{ time: 66, name: \"transport:packet_received\", data: { ... } }\r\n...\r\n```\r\n\r\nCC @marten-seemann @huitema",
      "createdAt": "2020-07-29T07:49:26Z",
      "updatedAt": "2020-09-05T16:25:57Z",
      "closedAt": "2020-09-05T16:25:57Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this idea. In the interest of keeping parsers simple, I would be supportive of completely replacing the current qlog format with this.\r\nAs I've said elsewhere, I don't think that the complexity that comes with putting multiple traces into the same file justifies the complexity.",
          "createdAt": "2020-07-29T08:00:15Z",
          "updatedAt": "2020-07-29T08:00:15Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I agree with @marten-seemann. We should optimize for the primary case, which is definitely single machine/trace.",
          "createdAt": "2020-07-29T11:12:46Z",
          "updatedAt": "2020-07-29T11:12:46Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Streaming would definitely be useful for me too. Currently, I have to use a two stage approach to solve that: stream-supporting binary log, then convert to qlog once I am sure the end is reached. And yes, all usage is single machine/trace.",
          "createdAt": "2020-07-29T18:11:00Z",
          "updatedAt": "2020-07-29T18:11:00Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "support this, would be good to see a short example of the difference between new and old formats so I can start planning",
          "createdAt": "2020-07-29T23:33:32Z",
          "updatedAt": "2020-07-29T23:33:32Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've updated the issue with an example, PTAL. \r\n\r\nI'm highly skeptical that that type of thing would be de-serializable automatically with something like @LPardue's serde, but a girl can dream. ",
          "createdAt": "2020-07-30T08:58:37Z",
          "updatedAt": "2020-07-30T08:58:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Thanks. FWIW, the current qlog format is effectively not deserializable using serde either, so nothing would be lost.\r\n\r\nedit: hmm, actually the new format might make it more straightforward to use a semi-automated deserializer",
          "createdAt": "2020-07-30T09:03:36Z",
          "updatedAt": "2020-07-30T09:05:52Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Initial support for \"newline delimited JSON\" qlog streaming is now in qvis per https://github.com/quiclog/qvis/commit/8504c0e4581b28c985f97eff701589b866bde4b9\r\n\r\nAn example draft-02 NDJSON file can be found in attachment (should load just fine in the live qvis atm).\r\nNow that I'm certain this can be done without major performance issues, I will move forward with this for qlog draft-02. \r\n\r\nIn the meantime, further feedback based on the example file is of course welcome. \r\n\r\n[newline_delimited.zip](https://github.com/quiclog/internet-drafts/files/5137476/newline_delimited.zip)\r\n\r\n",
          "createdAt": "2020-08-27T16:01:36Z",
          "updatedAt": "2020-08-27T16:01:36Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issues should have been resolved by the choice of NDJSON as streaming format as of https://github.com/quiclog/internet-drafts/commit/f5db7cdc8cd0cf37bfe5f1b0b4c54fc56ffc5f28",
          "createdAt": "2020-09-05T16:25:57Z",
          "updatedAt": "2020-09-05T16:25:57Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWU2Nzk4MTM1MDI=",
      "title": "push_allowed may be misleading",
      "url": "https://github.com/quicwg/qlog/issues/110",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The \"push_allowed\" data element is `parameters_set` event is odd in that other data elements log actual settings values while \"push_allowed\" is derived from the value of `MAX_PUSH_ID` frame.\r\n\r\nIn addition, for pushing to be allowed, a second condition is necessary:  There must be enough unidirectional stream credit.  For example, if only three unidirectional streams are allowed, it effectively means that pushing is not possible, as those will be taken by the control and the two QPACK streams.",
      "createdAt": "2020-08-16T19:41:52Z",
      "updatedAt": "2020-09-07T10:21:24Z",
      "closedAt": "2020-09-07T10:21:24Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree this is unclear.\r\nThe thinking was that you'd be able to see the MAX_PUSH_ID frame when that's logged as part of `frame_created` or `frame_parsed` and the `push_allowed` would be a more high-level indicator if applications don't log the frames individually (e.g., to save space).\r\n\r\nGiven this, would you advocate:\r\n1. removing `push_allowed` altogether\r\n2. properly defining `push_allowed` as meaning both MAX_PUSH_ID > 0 AND unidirectional credit at the same time\r\n3. replacing `push_allowed` with a `max_push_id` field\r\n",
          "createdAt": "2020-08-19T13:12:50Z",
          "updatedAt": "2020-08-19T13:12:50Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "MEMBER",
          "body": "Well, `MAX_PUSH_ID` is already logged, so we don't need (3).  (2) may be onerous to log because now the implementation needs to add checks in at least two places and log `push_allowed`...  Let the tool do it!\r\n\r\nThus, I vote for (1).",
          "createdAt": "2020-08-20T12:49:21Z",
          "updatedAt": "2020-08-20T12:49:21Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Was removed and explanation text added. ",
          "createdAt": "2020-09-07T10:21:24Z",
          "updatedAt": "2020-09-07T10:21:24Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "MDU6SXNzdWU2Nzk4MTU5OTY=",
      "title": "data_moved describes three layers, but only two are specified",
      "url": "https://github.com/quicwg/qlog/issues/111",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> Used to indicate when data moves between the HTTP/3 and the transport layer (e.g., passing from H3 to QUIC stream buffers and vice versa) or between HTTP/3 and the actual user application on top (e.g., a browser engine). This helps make clear the flow of data, how long data remains in various buffers and the overheads introduced by HTTP/3's framing layer.\r\n\r\nThe paragraph above describes three layers: transport, HTTP/3, and user application.\r\n\r\nThe definition allows for only two layers:\r\n\r\n```\r\n    from?:\"application\"|\"transport\",\r\n    to?:\"application\"|\"transport\",\r\n```\r\n\r\nIn addition, the definition of \"application\" is ambiguous: it could be the application protocol (HTTP/3) or the user application.",
      "createdAt": "2020-08-16T19:58:10Z",
      "updatedAt": "2020-09-07T19:40:40Z",
      "closedAt": "2020-09-07T19:40:40Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, the current thinking is that this is always an HTTP level event, so there is no need to specify the \"third\" layer, as it is always HTTP. \r\n\"application\" in this case will always be the user application, not the application protocol (which, I agree, is not entirely clear or obvious).\r\n\r\nGiven this explanation, would you push for:\r\n1. making this a more generic event by adding the \"third layer\" as well (not sure which category we would use for this event then though)\r\n2. re-naming \"application\" to something else here to separate it from HTTP3/application protocol more clearly\r\n3. keeping it as is but adding text to explain it more clearly\r\n",
          "createdAt": "2020-08-19T13:10:27Z",
          "updatedAt": "2020-08-19T13:10:27Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "MEMBER",
          "body": "I'd vote for (1), with the three layers being:\r\n1. transport (or QUIC);\r\n2. HTTP/3; and\r\n3. application.\r\n\r\nNote that the data may skip the HTTP/3 layer ([lsquic](https://github.com/litespeedtech/lsquic), for example, tries hard to avoid intermediate buffering) altogether, so the event should be able to describe that as well.",
          "createdAt": "2020-08-20T12:56:08Z",
          "updatedAt": "2020-08-20T12:56:08Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could you give an example of how data can skip the H3 layer in practice? I can understand this if you're for example using raw DATAGRAM frames in QUIC that don't use the HTTP/3 DATAGRAM stuff, but the moment you're carrying H3, you still need to strip out the frame headers in the H3 layer, no? ",
          "createdAt": "2020-08-20T13:07:48Z",
          "updatedAt": "2020-08-20T13:07:48Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "MEMBER",
          "body": "Here is how reading from an HTTP/3 stream works in lsquic (in the best-case scenario):\r\n\r\n1. The packet is decrypted and the decrypted payload is stored in a new memory object.  (This is data copy number 1.)\r\n2. The packet is parsed.  This creates _STREAM_ frame marker objects.\r\n3. If, as a result of a new marker, reading from a stream becomes possible, the user is notified via an \"on stream write\" event.  Note that *in the case of HTTP/3 stream, special magic happens internally*: the stream is fast-forwarded through the framing.  _DATA_ frames are processed and discarded.  You can peek at [how it's done in the `read_data_frames()` function](https://github.com/litespeedtech/lsquic/blob/v2.19.5/src/liblsquic/lsquic_stream.c#L1360L1363).\r\n4. The user then reads data from stream using one of two ways.\r\n   - **copy read**.  In this case, `lsquic_stream_read()` or `lsquic_stream_readv()` is called and data is copied into user-supplied buffer(s).  (This is data copy number 2.)\r\n   - **zero copy**.  User can call `lsquic_stream_readf()` with a callback.  This callback will then be given a pointer to the data from the  first copy (in Step 1).  See [line 1367](https://github.com/litespeedtech/lsquic/blob/v2.19.5/src/liblsquic/lsquic_stream.c#L1367) -- this is where this callback is called.  Here, the user can copy the data or process it directly.\r\n\r\nNote that there was no copy from transport layer into any intermediate layer.  So, no, stripping out frame headers does not mean that data must be copied.",
          "createdAt": "2020-08-20T14:20:34Z",
          "updatedAt": "2020-08-20T14:20:34Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is tied to #65 ",
          "createdAt": "2020-09-07T13:40:36Z",
          "updatedAt": "2020-09-07T13:40:36Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "MDU6SXNzdWU2Nzk4MTczNTI=",
      "title": "QPACK encoder and decoder each has its own state",
      "url": "https://github.com/quicwg/qlog/issues/112",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Each peer has two QPACK states: encoder and decoder.  `qpack`'s `state_updated` and `dynamic_table_updated` events do not make such differentiation, making the specification incomplete.  For example:\r\n\r\n> This event is emitted when one or more entries are added or evicted from QPACK's dynamic table.\r\n\r\nWhich dynamic table is meant: encoder or decoder?",
      "createdAt": "2020-08-16T20:06:37Z",
      "updatedAt": "2020-09-07T10:17:26Z",
      "closedAt": "2020-09-07T10:17:26Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by adding an \"owner\" field to `dynamic_state_updated`.\r\n\r\nOther qpack events either already had this field or are split out into created/parsed or encoded/decoded events, which makes this implicit. ",
          "createdAt": "2020-09-07T10:17:26Z",
          "updatedAt": "2020-09-07T10:17:26Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWU2Nzk4MTc2MzE=",
      "title": "QPACK: dynamic table entries are \"inserted,\" not \"added\"",
      "url": "https://github.com/quicwg/qlog/issues/113",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "editorial",
        "current-version"
      ],
      "body": "The draft should use the QPACK terminology.",
      "createdAt": "2020-08-16T20:08:19Z",
      "updatedAt": "2022-09-08T00:04:29Z",
      "closedAt": "2022-09-08T00:04:29Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, I'm not entirely sure what to do here... I based myself mainly on this section, which does use \"added\"/\"evicted\": \r\nhttps://tools.ietf.org/html/draft-ietf-quic-qpack-16#section-3.2.2\r\n\r\nHowever, I agree that in other places, \"inserted\" is used for the same/similar operations. I have changed it to \"inserted\" in qlog, as I trust @dtikhonov's good judgement, but wonder if this should be made consistent in the QPACK text? \r\n\r\nSimilarly, several diagrams refer to the \"dropping point\" or \"dropped count\", which I -assume- is the same as \"evicted\" or \"eviction index\" etc. The \"dropping point\" is not mentioned in the running text anywhere in any case. Maybe that should also be made more consistent?\r\n\r\nCC'ing @afrind on this. If needed, I can make issues in the quicwg repo for this. \r\n",
          "createdAt": "2020-09-07T10:11:23Z",
          "updatedAt": "2020-09-07T10:11:23Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "MEMBER",
          "body": "You're right: \"inserted\" is used nine times in the draft, while \"added\" is used six times.  My claim that entries are only \"inserted,\" not \"added,\" may have been incorrect!",
          "createdAt": "2020-09-08T20:27:23Z",
          "updatedAt": "2020-09-08T20:27:23Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "@rmarx this one seems resolved already. Can it be closed or is there something more to do?",
          "createdAt": "2022-06-29T15:53:20Z",
          "updatedAt": "2022-06-29T15:53:20Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Closing since this is trivial, probably fixed, and any remainig inconsistencies can (and will) be raised later with ease.",
          "createdAt": "2022-09-08T00:04:29Z",
          "updatedAt": "2022-09-08T00:04:29Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "MDU6SXNzdWU2Nzk4MTgxMjA=",
      "title": "qpack.instruction_sent -- which \"sent\" time is meant?",
      "url": "https://github.com/quicwg/qlog/issues/114",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> This event is emitted when a QPACK instruction (both decoder and encoder) is sent.\r\n\r\nA QPACK instruction is:\r\n- written to the encoder (or decoder) stream, which is then\r\n- packetized, and\r\n- the packet (or packets!) is sent.\r\n\r\nWhich of the three events above is meant is not clear.",
      "createdAt": "2020-08-16T20:11:32Z",
      "updatedAt": "2020-09-07T10:04:05Z",
      "closedAt": "2020-09-07T10:04:05Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolved by renaming `instruction_sent/received` to `instruction_created/parsed`, as an analogy to the HTTP/3 `frame_created/parsed` events. \r\n\r\nThanks for noticing this @dtikhonov!",
          "createdAt": "2020-09-07T10:04:05Z",
          "updatedAt": "2020-09-07T10:04:05Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "MDU6SXNzdWU2ODE4ODYxODI=",
      "title": "QPACK: check data types",
      "url": "https://github.com/quicwg/qlog/issues/115",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Commit 128f3840cf951e8032c25896683b369cb92d13e6 adds proper data type definitions (e.g., uint64 instead of just \"number\", bytes instead of \"hex string\") to the qlog event fields.\r\n\r\nThese were a bit difficult to figure out for QPACK events (with the whole \"prefixed integer\" stuff), so I've put everything at uint64 for now. While this is the \"safest\" option, elsewhere in the document I've taken the approach of choosing the smallest \"likely\" integer size for a given value. One example is the datagram_size: it's unlikely we'll see datagrams larger than uint32 in practice (you could even argue uint16?), so this field is not a uint64. Similarly, the length of a QUIC STREAM frame is also just uint32, not 64. This approach should help make binary qlog derivations more optimized. \r\n\r\nAs such, I was hoping someone with more QPACK experience could help indicate the \"minimal\" data type size for the different fields. \r\n\r\nA secondary aspect is the values logged for \"name\" and \"value\" (e.g., in InsertWithoutNameReferenceInstruction). I'm not sure if these should be readable strings (e.g., \"Content-Encoding\" or their hex/byte equivalents (e.g., \"abcde1234\"). For debugging it makes more sense if they are the readable strings, though I'm not sure it's logical to treat them that way inside a QPACK implementation. Alternative is the make the datatype for those `string | bytes` (one of both) and let the logger/tools figure it out. \r\n\r\nSo, TLDR:\r\n1. Which QPACK number-esque fields can do with less than 64 bits in practice?\r\n2. Which data type should name and value fields have in qlog? \r\n\r\nI was hoping for some input on this from maybe @dtikhonov, @lpardue, @afrind. Thanks in advance!\r\n\r\n\r\n\r\n",
      "createdAt": "2020-08-19T14:27:50Z",
      "updatedAt": "2020-09-07T10:04:54Z",
      "closedAt": "2020-09-07T10:04:53Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I don't have answers sorry, only a question. Have you considered making the name string and value string optional?",
          "createdAt": "2020-08-19T16:28:05Z",
          "updatedAt": "2020-08-19T16:28:05Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue yes, and most already are, but it seems I missed a few. Will be fixed, thanks for reporting. ",
          "createdAt": "2020-08-19T16:34:08Z",
          "updatedAt": "2020-08-19T16:34:08Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "MEMBER",
          "body": "> Similarly, the length of a QUIC STREAM frame is also just uint32, not 64.\r\n\r\nI looked at the latest version of the draft and stream IDs in the \"qpack\" section are all uint64...",
          "createdAt": "2020-08-20T13:09:47Z",
          "updatedAt": "2020-08-20T13:09:47Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Similarly, the length of a QUIC STREAM frame is also just uint32, not 64.\r\n> \r\n> I looked at the latest version of the draft and stream IDs in the \"qpack\" section are all uint64...\r\n\r\nyes, because the IDs can conceivably go higher than 32. However, the raw_length of the STREAM frame (https://quiclog.github.io/internet-drafts/draft-marx-qlog-event-definitions-quic-h3.html#name-streamframe) can never span more than just the single packet, and I assume individual packets won't be larger than 32 bits in practice. (the \"length\" field there should then probably also be uint32 instead of 64, though the offset should remain at 64). \r\n",
          "createdAt": "2020-08-20T13:18:48Z",
          "updatedAt": "2020-08-20T13:18:48Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "MEMBER",
          "body": "Oh, I see where I went wrong! :-)\r\n\r\nThe updated \"qpack\" types in the draft look OK.",
          "createdAt": "2020-08-20T13:59:24Z",
          "updatedAt": "2020-08-20T13:59:24Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Seems like you could probably reduce the table capacity and table size to 32 bits, as I have a hard time seeing someone reserving up to 4GB for this purpose.  That said, it is possible in the protocol, so if you want to be able to handle even the crazies I guess you have to stick to 64.  ",
          "createdAt": "2020-08-20T15:47:06Z",
          "updatedAt": "2020-08-20T15:47:06Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks all for the review.\r\n\r\nName and value (and their lengths) are now always optional and some uint64's have become uint32's (we do not want to encourage the crazies ;)) ",
          "createdAt": "2020-09-07T10:04:53Z",
          "updatedAt": "2020-09-07T10:04:53Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "MDU6SXNzdWU2OTQ4NjY2MDE=",
      "title": "Add certificate verification events",
      "url": "https://github.com/quicwg/qlog/issues/116",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "quic-http3-fields",
        "future-versions"
      ],
      "body": "In real deployments, getting some feedback on certificate validation events is useful (e.g., these are included in NetLog).\r\n\r\nI wonder if these can be done as triggers... but on what event would those triggers be logged then? Maybe on a connection close if validation fails? What if it succeeds? \r\n\r\nAs I've seen some discussion about these things being async and sometimes depend on remote fetches (e.g., for OCSP), it would probably be useful to have separate events though. \r\n\r\nI need to get a better overview of the types of events though to decide on how to log this. Probably add something simple for draft-02 and extend in -03. ",
      "createdAt": "2020-09-07T08:37:28Z",
      "updatedAt": "2022-09-29T14:02:57Z",
      "closedAt": "2022-09-29T14:02:57Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This falls into the camp of something the application does, rather than a transport feature. \r\n\r\nWhen a handshake fails, there are protocol messages that communicate that. We support them already AFAIK.\r\n\r\nExtra information is useful for debugging but qlog is flexible enough to let application do what ever they want. \r\n\r\nSuggest close with no action; reopen if there is clear demand for a specific event.",
          "createdAt": "2022-09-08T00:09:51Z",
          "updatedAt": "2022-09-08T00:09:51Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "This also seems to fall into the realm of a TLS qlog extension.",
          "createdAt": "2022-09-08T07:13:40Z",
          "updatedAt": "2022-09-08T07:13:40Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed to close with no action, as this leans more towards top-level Application or low-level TLS, neither of which we do (much of) today. ",
          "createdAt": "2022-09-29T14:02:54Z",
          "updatedAt": "2022-09-29T14:02:54Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWU3MDE1OTAxNTE=",
      "title": "token logging",
      "url": "https://github.com/quicwg/qlog/issues/117",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "current-version"
      ],
      "body": "Currently (in draft-02) tokens are logged like this:\r\n```\r\n    retry_token?:bytes, // only if header.packet_type === retry\r\n    retry_token_length?:uint32, // only if header.packet_type === retry\r\n```\r\n\r\nIt would be nice if it was possible if the server could also log tokens received on Initial packets. More interesting than the raw byte representation of a token would be the data encoded in a token. The most interesting bit is probably if the token is a Retry token or a NEW_TOKEN token. Implementations could then add more fields and fill them with data that's encoded into the token.",
      "createdAt": "2020-09-15T04:07:02Z",
      "updatedAt": "2020-11-02T19:48:52Z",
      "closedAt": "2020-11-02T19:48:52Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, this is an absolute mess... but it's a mess in the specs as well. \r\n\r\nRetry (from the server) and stateless reset tokens are logged in the packet events directly, because they are sent in the body of their respective packet types.\r\n\r\nThen, tokens included in the initial, are logged in the PacketHeader struct (see https://quiclog.github.io/internet-drafts/draft02/draft-marx-qlog-event-definitions-quic-h3.html#name-packetheader). There is no specified way in the spec to know whether the initial token is retry or NEW_TOKEN, except for the semantics of the connection state at that time, so that's what the current setup is with qlog as well (which, I agree, is suboptimal). \r\n\r\nI -could- add a kind of `token_type?: \"retry\"|\"resumption\"` to PacketHeader I guess, but then there will be situations where implementations don't want to log that/don't have that information available at that location etc. \r\n\r\nAs for the \"what exactly is in a token\"... this is hyper implementation-specific, so you couldn't make interoperable tools for that anyway. I considered adding a generic `token_contents:any` field, but given the above I'd have to repeat that for the `retry_token` and PacketHeader:token separately, which is again... a mess. So I'm really not sure about the cleanest solution. \r\n\r\nAs explained in https://github.com/quiclog/internet-drafts/issues/94, I was planning on keeping this floating for -02 and probably moving to separate token-based events in -03 to make this cleaner. \r\n",
          "createdAt": "2020-09-15T09:27:58Z",
          "updatedAt": "2020-09-15T09:27:58Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> Then, tokens included in the initial, are logged in the PacketHeader struct (see https://quiclog.github.io/internet-drafts/draft02/draft-marx-qlog-event-definitions-quic-h3.html#name-packetheader). There is no specified way in the spec to know whether the initial token is retry or NEW_TOKEN, except for the semantics of the connection state at that time, so that's what the current setup is with qlog as well (which, I agree, is suboptimal).\r\n\r\nThat's not true. An implementation MUST be able to distinguish between them, see https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#name-token-construction:\r\n> A token sent in a NEW_TOKEN frames or a Retry packet MUST be constructed in a way that allows the server to identify how it was provided to a client. These tokens are carried in the same field, but require different handling from servers.\r\n\r\n> As for the \"what exactly is in a token\"... this is hyper implementation-specific, so you couldn't make interoperable tools for that anyway.\r\n\r\nIn principle, yes, although the spec imposes a few restrictions:\r\n> Tokens sent in NEW_TOKEN frames MUST include information that allows the server to verify that the client IP address has not changed from when the token was issued.\r\n\r\nand\r\n> Servers SHOULD ensure that tokens sent in Retry packets are only accepted for a short time. \r\n\r\nVery likely, implementations will save the creation time and the peer's remote address into the token.",
          "createdAt": "2020-09-15T09:45:03Z",
          "updatedAt": "2020-09-15T09:45:14Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed for draft-02 by extracting out a separate Token class. Open to revisiting this for draft-03. ",
          "createdAt": "2020-11-02T19:48:52Z",
          "updatedAt": "2020-11-02T19:48:52Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "MDU6SXNzdWU3MTU0Mjg2Njk=",
      "title": "key update logging",
      "url": "https://github.com/quicwg/qlog/issues/118",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "future-versions"
      ],
      "body": "The spec is not clear on when to log key updates. I'm trying to debug a failure of the key update interop runner test case, and qlog just doesn't give me enough information what's going on.\r\nThe main problem is that there's no `key phase` information available on the `PacketHeader`.\r\n\r\n* During the handshake (all keys with trigger `tls`), it's most useful to log when a new key becomes available, as it allows you to see why packets might end up as undecryptable.\r\n* Key updates for 1-RTT keys are more tricky: For a locally initiated key update, it's only clear how to log the send key. You do compute the receive key at the same point, but you don't use it until the client has acted upon the key update.\r\n\r\nI think the following would be the easiest:\r\n\r\n1. Add a `key_phase` field on the `PacketHeader`. This is the key phase `N`, not the key phase bit. The receiver will know the full key phase value after successfully decrypting a packet. For undecryptable packets, there should be a `key_phase_bit` field.\r\n2. Split the `key_updated` event: The event in its current form makes a lot of sense for TLS-initiated updates. For 1-RTT key updates, there's no need to distinguish between the `server_1rtt_secret` and the `client_1rtt_secret`.",
      "createdAt": "2020-10-06T07:43:28Z",
      "updatedAt": "2024-02-19T09:07:18Z",
      "closedAt": "2024-02-19T09:07:18Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related to #52 ",
          "createdAt": "2020-10-31T13:58:09Z",
          "updatedAt": "2020-10-31T13:58:09Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in #390. ",
          "createdAt": "2024-02-19T09:07:18Z",
          "updatedAt": "2024-02-19T09:07:18Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "MDU6SXNzdWU3MzM3MjQxNjQ=",
      "title": "Make initiator clear in connection_started",
      "url": "https://github.com/quicwg/qlog/issues/119",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design",
        "quic-http3-fields",
        "current-version",
        "privacy"
      ],
      "body": "Currently, `connection_started` utilizes `src_ip` and `dst_ip` (and equivalent for ports), where the intended meaning is that src means the initiator (typically client) and dst the server. \r\n\r\nHowever, this is a) unclear and b) it does not allow deducing what the \"local\" ip is for where this trace was captured without correlating client/server with the vantagepoint (and if that vantagepoint is network, it becomes more murky). \r\n\r\nSome options for solving:\r\n1. rename fields to `local_ip` and `remote_ip`  \r\n2. add `initiator` field (e.g., with values 'local' and 'peer')\r\n3. completely revise how we log paths/IPs and potentially decouple from `connection_started` (also good in terms of privacy, migration, multipath, ...). \r\n\r\nOption 3 is probably best, should revisit when properly fixing migration in qlog (see also #79 and #57)\r\n\r\ncc @marten-seemann \r\n",
      "createdAt": "2020-10-31T13:47:19Z",
      "updatedAt": "2025-03-13T14:06:43Z",
      "closedAt": "2025-03-13T14:06:43Z",
      "comments": []
    },
    {
      "number": 120,
      "id": "MDU6SXNzdWU3MzQ1ODAxNDQ=",
      "title": "Allow logging of TLS internals",
      "url": "https://github.com/quicwg/qlog/issues/120",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "discuss"
      ],
      "body": "Depending on some TLS parameters, things might behave strangely on a QUIC level.\r\n\r\nFor example, TLS key shares can apparently use different \"group types\", e.g., p-256 or x25519 (this is somehow separate from the cipher it uses... I really need to brush up on my TLS understanding). The client chooses one of the groups that it thinks the server will support. If it doesn't the server will send an initial back, to which the client replies with another ClientHello using the correct group type, leading to a 2RTT QUIC handshake instead of 1RTT. An example can be seen in https://quic-tracker.info.ucl.ac.be/traces/20201101/2 (or if that's not longer available, a quic-tracker to mvfst connection setup, which seems to do this consistently).\r\n\r\nThis example above has already caught two separate researchers by surprise, and it should really be possible to expose this in qlog for easier debugging. \r\n\r\nIn general, I think we can do with providing more options for logging TLS-level information, but for that I first need to understand the variables better (or find someone to propose the concrete things to surface in qlog for that). ",
      "createdAt": "2020-11-02T15:05:32Z",
      "updatedAt": "2024-06-27T19:03:50Z",
      "closedAt": "2024-06-27T19:03:49Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Applications can log what they like with their own events. Do we really need to say anything more?",
          "createdAt": "2022-09-08T00:15:12Z",
          "updatedAt": "2022-09-08T00:15:12Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "If our motto is to keep things limited to what the 3 QUIC RFCs describe, this would be out of scope.\r\n\r\n> Applications can log what they like with their own events. \r\n\r\nI'm not sure if this really constitutes an application-layer event, as the TLS stack is most likely provided by the QUIC implementation, not the application. Maybe we can punt this to a TLS stack extension to qlog?",
          "createdAt": "2022-09-08T07:12:51Z",
          "updatedAt": "2022-09-08T07:12:51Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In one way, I would agree punting this to a broader TLS extension would be good.\r\n\r\nIn another, I really feel our current TLS capabilities of qlog are too limited to be of much use to debug TLS-specific aspects (e.g., it irks me we can't log extensions or ciphersuites properly, though I also hesitate to put this stuff in atm). \r\n\r\nWill mark this as needs discussion, as we need a plan for how deep we want TLS support to go imo. ",
          "createdAt": "2022-09-29T14:06:30Z",
          "updatedAt": "2022-09-29T14:06:30Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems like a duplicate of #59 (at least at this point...). Closing in favor of that one. ",
          "createdAt": "2024-06-27T19:03:49Z",
          "updatedAt": "2024-06-27T19:03:49Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "MDU6SXNzdWU3MzQ5MDEwNDI=",
      "title": "Allow the logging of Session Ticket contents and stored transport params/SETTINGS",
      "url": "https://github.com/quicwg/qlog/issues/121",
      "state": "OPEN",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "design",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "Currently, we can log which params/settings were restored upon attempting 0-RTT, but not which ones were actually stored at the end of a connection (though we might assume it were the correct ones, using the values from `parameters_set`).\r\n\r\nFor a server which encodes this information in for example the SessionTicket, we also cannot log which values are in the ticket when sending it, nor when receiving it, nor if early data was denied because of a mismatch therein. ",
      "createdAt": "2020-11-02T23:14:15Z",
      "updatedAt": "2023-01-09T14:36:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": ">  (though we might assume it were the correct ones, using the values from parameters_set)\r\n\r\nThe client might also save the RTT (and RTT variance maybe?), which would not be a QUIC transport parameter.\r\n\r\n> For a server which encodes this information in for example the SessionTicket, we also cannot log which values are in the ticket when sending it\r\n\r\nI think _all_ servers would encode this in the SessionTicket, but maybe we should be flexible enough to allow for other options?\r\n\r\nThe way we could do this is by introducing a `parameters_saved` and a `parameters_restored` event, which allows to encode both QUIC transport parameters and other values. We might also add a `dest` / `src` field, so we can specify where those values were saved (in the session ticket / to disk / etc.).",
          "createdAt": "2021-10-04T14:07:08Z",
          "updatedAt": "2021-10-04T14:07:08Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Taking a long hard look at the documents, I suggest the following:\r\n* split the `TransportParametersSet` event. There should be one event (keeping the `TransportParametersSet` name) that only logs the QUIC transport parameters, and another TLS event\r\n* the TLS event will _only_ capture the parts that are relevant for QUIC, e.g. cipher suite (since this determines the header protection algorithm used), the QUIC parts of the session ticket, 0-RTT etc.",
          "createdAt": "2022-12-28T03:20:38Z",
          "updatedAt": "2022-12-28T03:20:38Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I understand how exactly that would aid solve this particular issue, unless you mean that the new TLS event would use a `dest`/`src` field as mentioned in your comment above to indicate `TLSParametersSaved` vs `TLSParametersRestored`.\r\n\r\nI do see the appeal of having a separate TLS event. I assume it would still be under the `transport` category? \r\n\r\nCan you make a (quick) mockup of what the `TLSParametersSet` would look like? \r\n",
          "createdAt": "2023-01-09T14:36:14Z",
          "updatedAt": "2023-01-09T14:36:34Z"
        }
      ]
    },
    {
      "number": 122,
      "id": "MDU6SXNzdWU3MzQ5ODg0NjA=",
      "title": "the new Token is confusing",
      "url": "https://github.com/quicwg/qlog/issues/122",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "design",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "The `Token` introduced in https://github.com/quiclog/internet-drafts/commit/60690f4033624006b5bbac8797e69b8a78331ce3 doesn't make sense to me. I don't see the motivation for bundling stateless resets and Retry tokens into the same struct (other than incidentally, the spec calls them tokens).\r\n\r\nStateless reset tokens are by definition random values (or rather, a deterministic pseudorandom value derived from the connection ID). They are always 16 bytes and never contain any other information.\r\n\r\nOn the other hand, the token sent on the Initial can be a Retry token or a NEW_TOKEN token (I guess that's what a resumption token is). This token typically does contain additional information encoded into the value (in fact, as I've described in https://github.com/quiclog/internet-drafts/issues/117#issuecomment-692603028, the spec mandates that you encode a bunch of values into that token). I would have wished that at least those mandatory fields are clearly defined in the `Token`.",
      "createdAt": "2020-11-03T03:30:41Z",
      "updatedAt": "2022-07-27T20:27:29Z",
      "closedAt": "2022-07-27T20:27:29Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From a discussion on Slack, @marten-seemann is in favor of splitting stateless reset tokens from the Token class and logging them as a `stateless_reset_token?:bytes` (which is the approach we had before and works well because the reset token is always 128 bits in length).\r\n\r\nWrt to specifying detail fields, from what I can gather there are two main ones:\r\n- `remote_address?:IPAddress` for a NEW_TOKEN \r\n- `timeout?:uint32` for a retry token\r\n\r\nAre there others that would benefit from being specified explicitly? ",
          "createdAt": "2020-11-03T11:06:25Z",
          "updatedAt": "2020-11-03T11:06:25Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I think most implementations encode the timestamp (and not the timeout) when the token was generated into the token, so they can decide if they want to accept a token based on current conditions.",
          "createdAt": "2020-11-03T12:28:03Z",
          "updatedAt": "2020-11-03T12:28:03Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "MDU6SXNzdWU3NDY3MjcwMTU=",
      "title": "Add support for QUIC DATAGRAM and HTTP/3 DATAGRAM frames",
      "url": "https://github.com/quicwg/qlog/issues/124",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "design",
        "quic-http3-fields",
        "future-versions"
      ],
      "body": "[QUIC DATAGRAM spec](https://tools.ietf.org/html/draft-ietf-quic-datagram-01)\r\n\r\n[HTTP/3 DATAGRAM spec ](https://tools.ietf.org/html/draft-schinazi-quic-h3-datagram-05)\r\n\r\nAn interesting point was made about this by @lpardue, in that these frames are almost identical, with the H3 layer just adding a flow_id. \r\nFor this, their implementation somewhat abstracts away the difference between these two, and their H3 code doesn't really have the concept of a DATAGRAM frame. \r\nFor this, it would be interesting to have the flow_id field defined on the QUIC-level DATAGRAM as well, not just the HTTP/3 frame. \r\n\r\nTo me, this feels a bit dirty, qlog not mirroring the specs to make implementation/logging easier. Still, it's something to consider.\r\n\r\nAn alternative is to implement this purely in the tooling. For example, qvis could just look for a flow_id field on the QUIC DATAGRAM frame, even though it's not defined in qlog proper. Alternatively, it could parse raw.data and extract the flow-id from that (which is worse...). \r\n\r\nThis raises an overall point about the robustness of the tooling and whether we should mention something like this in the qlog texts. ",
      "createdAt": "2020-11-19T16:19:40Z",
      "updatedAt": "2022-11-01T10:34:14Z",
      "closedAt": "2022-11-01T10:34:13Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I think there is a place for the H3 DATAGRAM frame qlog object. The quiche implementation, at present, only provides transport layer logging but it would be logical to log an H3 layer frame if we supported it.\r\n\r\nWith what quiche has today, I would not implement flow_id logging for transport DATAGRAM. That would require me to do some layering violation and means the generic transport code suddenly becomes application aware. Its unfair to ask someone else to do the same violation I'm not willing to do and they might well reject it just as I have done. But implementations often have different incentives \ud83d\ude00",
          "createdAt": "2020-11-19T16:53:02Z",
          "updatedAt": "2020-11-19T16:53:02Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "There is some overlap here with discussion in the draft repo about whether a flow-id should go in the transport. One comment there described a TAPS concept where interface boundaries can accept a function that can be executed on behalf of the caller. Qvis could for instance by default just plot all datagrams as 1 \"series\", or plot multiple \"series\" based on a user supplied transform function such as varint(dgram_frame.bytes[])",
          "createdAt": "2020-11-19T16:59:52Z",
          "updatedAt": "2020-11-19T16:59:52Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Based on other discussions, I think we should punt QUIC or HTTP/3 extensions to their own documents. So suggest close with no action on these documents.",
          "createdAt": "2022-09-08T00:22:01Z",
          "updatedAt": "2022-09-08T00:22:01Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After discussion, it was decided to indeed handle these (and other, future) extensions in their own documents. \r\n\r\nFor the DATAGRAM frames concretely, this has now been done at https://github.com/rmarx/draft-marx-quic-qlog-datagram. This is intended to be an example and testing ground of how to approach qlog extensibility in general. \r\n\r\nSmall note: the original discussion on this issue regarding `flow_id` is now mute due to changes in how the DATAGRAM frames have been defined in their respective RFCs. ",
          "createdAt": "2022-11-01T10:34:13Z",
          "updatedAt": "2022-11-01T10:34:13Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "MDU6SXNzdWU3NTg5NjU5NTg=",
      "title": "QuicFrame length and payload_length",
      "url": "https://github.com/quicwg/qlog/issues/126",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "current-version"
      ],
      "body": "I recently implemented draft 2 and was very confused about the these two fields, found in some of the QuicFrame classes.\r\n\r\n1. What does it mean when a frame has both `payload_length` and `length` (total frame size)? \r\nex. `PaddingFrame`, `PingFrame`, `AckFrame`, `ResetStreamFrame`, `StopSendingFrame`\r\n\r\nDoes `length` include the frame type while `payload_length` is the rest? That doesn't seem true for `PingFrame` and `PaddingFrame`, as `payload_length` == `length`. Also the frame type [must use the minimum size](https://www.ietf.org/archive/id/draft-ietf-quic-transport-32.html#section-12.4-16), so they're just going to be off by 1. Or does `payload_length` measure something else?\r\n\r\n\r\n====\r\n\r\n2. What about frames with both `payload_length` and `length` (not total frame size)?\r\nex. `CryptoFrame`, `StreamFrame`\r\n\r\nDo I need to make an exception for these frames? Is `payload_length` the aforementioned total length - 1, or is it the length of the STREAM/CRYPTO data? \r\n\r\nThe RFC says: > payload_length: length of the packet/frame payload, excluding AEAD tag. For many control frames, this will have a value of zero\r\n\r\nThat implies that `payload_length == length` for these frames, and `payload_length == 0` for every other type of frame???\r\n\r\n====\r\n\r\n3. What about frames with no `length` or `payload_length`?\r\nex. `NewTokenFrame`, `MaxDataFrame`, `MaxStreamDataFrame`, `MaxStreamsFrame`, ... \r\n\r\nIs there no way to measure the size or these frames? The length of most of them don't matter, although you can make the same argument for `ResetStreamFrame` and `StopSendingFrame`. It seems like somebody got distracted while going down the list.\r\n\r\n====\r\n\r\n4. What about classes with `raw_length`?\r\nex. `UnknownFrame`\r\n\r\nSeems inconsistent!",
      "createdAt": "2020-12-08T00:50:13Z",
      "updatedAt": "2024-06-24T15:24:24Z",
      "closedAt": "2024-06-24T15:24:24Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hello Luke,\r\n\r\nThanks for opening this issue, because you're correct that there are some problems with this, as the design for how to do this has changed over time and there seem to be some leftovers/oversights. The person who \"got distracted going down the list\" was me ;) \r\n\r\nThe (currently) intended approach is to log actual lengths and payload lengths as part of an optional \"raw\" field, as described in https://tools.ietf.org/html/draft-marx-qlog-event-definitions-quic-h3-02#section-4.1. This is because many implementations won't log this info and it's only really useful for doing packetization analysis, which you don't always need, so it makes sense to split this up a bit. \r\n\r\nAs such, the `payload_length` and `length` fields on PingFrame, AckFrame, ResetStreamFrame, and StopSendingFrame and the `payload_length` field on PaddingFrame and CryptoFrame **should be removed and instead `raw.payload_length` and `raw.length` should be used**. \r\n\r\nThe `length` fields on Crypto and Stream remain and reflect the fields as defined in the QUIC docs, to make it easier to map them to qlog (this means that frame.length will be the same as raw.payload_length, but so be it...)\r\n\r\n_I'm not sure what to do with PaddingFrame. It doesn't have a length in the spec, but that would be useful to have in qlog. You could say implementations should then just log `raw.payload_length`, but not everyone has that type of flexible stack where that's easy to do if you don't log the `raw` field everywhere, so I'm in favor of keeping `length` on PaddingFrame as well._\r\n\r\nFinally, for UnknownFrame, `raw_length` and `raw` should also be changed to just use the generic `raw` field. \r\n\r\nKeeping this open to tackle for draft-03. Feel free to open a PR, otherwise I'll make the fixes over time. \r\n\r\n---\r\n\r\nAs I said in the other issue you opened in qvis, it's great to have this type of feedback. It can be tough keeping every detail consistent in this type of document and I find I tend to overlook things like this. If you find anything else that seems strange, don't hesitate to open an issue. \r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-12-08T10:57:11Z",
          "updatedAt": "2020-12-08T10:57:11Z"
        },
        {
          "author": "ptrd",
          "authorAssociation": "NONE",
          "body": "My 2 cents:\r\n- IMHO Padding should contain a length field (in kwik i do the same optimisation of combining padding bytes into one frame; i guess more people are doing so ;-))\r\n- for frames, having both length and payload_length wouldn't be very useful, would it? One can easily computed from the other (where \"easily\" is even an understatement ;-))",
          "createdAt": "2020-12-20T10:12:23Z",
          "updatedAt": "2020-12-20T10:12:23Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Has this been addressed? If not, what needs doing?",
          "createdAt": "2022-09-08T00:31:05Z",
          "updatedAt": "2022-09-08T00:31:05Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Coupling this to #243 as it seems that should be a (partial) fix if we properly use RawInfo, but should still double-check. ",
          "createdAt": "2022-10-05T14:45:14Z",
          "updatedAt": "2022-10-05T14:45:14Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "AFAICT this was indeed fixed when moving to 'RawInfo everywhere\" a while back. It still has some issues that @kixelated originally detailed (sometimes `payload_length` will be 0 for example), but I feel the more generalized approach is more important here (implementations can still choose to `payload_length` for those instances, as they're optional fields). \r\n\r\nClosing for now; feel free to leave additional comments or open a new issue if this is still problematic. ",
          "createdAt": "2024-03-04T14:56:00Z",
          "updatedAt": "2024-03-04T14:56:00Z"
        }
      ]
    },
    {
      "number": 127,
      "id": "MDU6SXNzdWU3ODA3NDYzNTg=",
      "title": "Properly add double quotes for JSON keys as well",
      "url": "https://github.com/quicwg/qlog/issues/127",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "current-version"
      ],
      "body": "I've been lazy and didn't add double quotes for JSON keys, just for string field values.\r\nFor a more formal version, this should be changed. ",
      "createdAt": "2021-01-06T18:05:52Z",
      "updatedAt": "2022-10-05T14:52:44Z",
      "closedAt": "2022-10-05T14:52:44Z",
      "comments": []
    },
    {
      "number": 128,
      "id": "MDU6SXNzdWU3ODExNzcyOTM=",
      "title": "Remove implementation detail from PacketType enum",
      "url": "https://github.com/quicwg/qlog/issues/128",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "editorial",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "At the moment, the PacketType enum has `onertt = \"1RTT\"` (and similar for 0RTT) because in most programming languages, enum keys cannot start with numerical characters. This has however led to some confusion in some cases, so it's probably best to leave out this implementation detail in the spec.\r\n\r\nSee also https://github.com/p-quic/pquic/issues/18#issuecomment-756005163",
      "createdAt": "2021-01-07T09:44:36Z",
      "updatedAt": "2021-10-06T09:53:51Z",
      "closedAt": "2021-10-06T09:53:51Z",
      "comments": [
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "@rmarx are you recommending just an editorial change to remove `= \"1RTT\"` and `= \"0RTT\"` or do you have something else in mind? \r\n\r\nI would see no issue in just using zerortt and onertt. Another option would be to add a prefix so that the first character is not a number, e.g. \r\n\r\n```\r\nenum PacketType {\r\n    initial,\r\n    handshake,\r\n    _0rtt,\r\n    _1rtt,\r\n    retry,\r\n    version_negotiation,\r\n    stateless_reset,\r\n    unknown\r\n}\r\n```\r\n",
          "createdAt": "2021-09-16T06:36:29Z",
          "updatedAt": "2021-09-16T06:36:29Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would indeed just be an editorial change, but to be backwards compatible with existing qlog implementations, we shouldn't do `onertt` and `zerortt` but just 1RTT and 0RTT (as those are the actual serializations used atm).\r\n\r\nThe point here is that I feel we don't need to take into account the fact that most programming languages don't allow numericals as the first character in an enum; that should be an implementation detail.\r\n\r\nSo I'd propose:\r\n```\r\nenum PacketType {\r\n    initial,\r\n    handshake,\r\n    0RTT,\r\n    1RTT,\r\n    retry,\r\n    version_negotiation,\r\n    stateless_reset,\r\n    unknown\r\n}\r\n``\r\n",
          "createdAt": "2021-09-16T09:51:03Z",
          "updatedAt": "2021-09-16T09:51:03Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "MDU6SXNzdWU3ODE3NDY3NTk=",
      "title": "TransportError",
      "url": "https://github.com/quicwg/qlog/issues/129",
      "state": "CLOSED",
      "author": "kazu-yamamoto",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial",
        "quic-http3-fields",
        "current-version"
      ],
      "body": " A.7.22.  `TransportError` should catch up the latest transport draft. Probably four errors are missing.",
      "createdAt": "2021-01-08T00:34:45Z",
      "updatedAt": "2023-01-18T19:59:48Z",
      "closedAt": "2023-01-18T19:59:48Z",
      "comments": []
    },
    {
      "number": 130,
      "id": "MDU6SXNzdWU3ODc2NjEzODk=",
      "title": "Formal definition of CommonFields seems to be missing",
      "url": "https://github.com/quicwg/qlog/issues/130",
      "state": "CLOSED",
      "author": "ptrd",
      "authorAssociation": "NONE",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "editorial",
        "high-level-schema",
        "current-version"
      ],
      "body": "Section https://tools.ietf.org/html/draft-marx-qlog-main-schema-02#section-3.3 defines class Trace that has a field\r\n`common_fields?: CommonFields`, \r\nhowever, the class CommonFields is not defined in the document.",
      "createdAt": "2021-01-17T08:50:09Z",
      "updatedAt": "2021-11-04T11:19:17Z",
      "closedAt": "2021-11-04T11:19:16Z",
      "comments": [
        {
          "author": "ptrd",
          "authorAssociation": "NONE",
          "body": "Hmm, 3.4.8 defines it. I missed it because i did a text search on \"CommonFields\", which occurs only once in the text.\r\nEven though it is defined as a dictionary that can contains anything, personally, i would still like to see a class definition of CommonFields in the text. This could at least define the 4 default fields.",
          "createdAt": "2021-01-17T08:56:34Z",
          "updatedAt": "2021-01-17T08:56:34Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This should now be fixed in the latest draft, at the bottom of the Section: https://datatracker.ietf.org/doc/html/draft-ietf-quic-qlog-main-schema-01#section-3.4.7.",
          "createdAt": "2021-11-04T11:19:16Z",
          "updatedAt": "2021-11-04T11:19:16Z"
        }
      ]
    },
    {
      "number": 131,
      "id": "MDU6SXNzdWU3ODc2Njc0NTk=",
      "title": "Improve definition of event and data",
      "url": "https://github.com/quicwg/qlog/issues/131",
      "state": "CLOSED",
      "author": "ptrd",
      "authorAssociation": "NONE",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "editorial",
        "current-version"
      ],
      "body": "As discussed on Slack, i find definition of event and data object a bit confusing. \r\nSome suggestions for improvement:\r\n- https://tools.ietf.org/html/draft-marx-qlog-main-schema-02#section-3.4.3: TransportPacketSentEvent is not an event in the terminology of this document, but an example of data object; as such, i'd suggest to name it TransportPacketSentData\r\n- it would help if the data serialization example in the same section would also show how the data object fits into the event (i.e. include the event in the example)\r\n- https://tools.ietf.org/html/draft-marx-qlog-event-definitions-quic-h3-02#section-5: i'd suggest to also mention each subsubheading / event-type will define the data class that is referred to in main-schema\r\n- why not use the more formal way of defining a data class used in the main-schema document (e.g. class TransportPacketSentData) in stead of the informal \"Data\" label this is now used in quic-schema? The latter confuses me, because it makes me wonder how it fits in the formal definition of event. Also, it would be helpful as one can find the QUIC example in main-schema (TransportPacketSentEvent) in the QUIC-document; currently this example cannot be found in the quic-doc, which is a bit confusing also as it states the example is taken from QUIC ;-)\r\n- the definition (example) of TransportPacketSentEvent in main-schema does not match the definition in quic-doc  section 3.5.3; either make them equal or add a note in the main-schema document that it is only partial.",
      "createdAt": "2021-01-17T09:33:04Z",
      "updatedAt": "2023-12-19T01:56:59Z",
      "closedAt": "2023-12-19T01:56:59Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Since this ticket was opened, we've switched to CDDL and tightened up our terminology usage around Events and Data. I think some of the original points have been addressed but it would be good to double check. \r\n\r\nOne comment that might have hungover is \r\n\r\n> TransportPacketSentEvent is not an event in the terminology of this document, but an example of data object; as such, i'd suggest to name it TransportPacketSentData\r\n\r\nThis is now called simply `TransportPacketSent`, however it belongs to `QuicEvents`, which extends `$ProtocolEventBody`, which is defined in https://www.ietf.org/archive/id/draft-ietf-quic-qlog-main-schema-04.html#figure-15 as \r\n\r\n```\r\nEvent = {\r\n    time: float64\r\n    name: text\r\n    data: $ProtocolEventBody\r\n\r\n    ? time_format: TimeFormat\r\n\r\n    ? protocol_type: ProtocolType\r\n    ? group_id: GroupID\r\n\r\n    ; events can contain any amount of custom fields\r\n    * text => any\r\n}\r\n```",
          "createdAt": "2023-01-17T17:45:08Z",
          "updatedAt": "2023-01-17T17:45:08Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "To add a bit more. I don't really have much problem with an Event's `data` field containing an abstract notion of something called `QuicEvents` or similar. When it comes to concrete events in serialized form it'll all tend to look the same. However, if we really wanted to consistent with terminology, perhaps something to consider is\r\n\r\n1. Rename `$ProtocolEventBody` to `$ProtocolEventData` throughout\r\n1. Recommend that extensions are names `NewProtocolEventData`\r\n1. Rename our extensions\r\n   * QuicEvents -> QuicEventData\r\n   * HTTPEvents -> HTTPEventData\r\n   * QPACKEvent -> QPACKEventData",
          "createdAt": "2023-01-17T18:01:53Z",
          "updatedAt": "2023-01-17T18:02:17Z"
        }
      ]
    },
    {
      "number": 132,
      "id": "MDU6SXNzdWU3OTAxNTM0NTY=",
      "title": "Add events to explicitly indicate send blocking",
      "url": "https://github.com/quicwg/qlog/issues/132",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design",
        "quic-http3-fields",
        "current-version",
        "discuss"
      ],
      "body": "msquic has separate events that indicate if the sender was blocked/delayed/idle and due to which cause (e.g., pacing, flow control limited, cwnd limited, etc.).\r\n\r\nThis is quite useful for debugging. While some of this can be deduced from looking at other existing qlog events, adding some more explicit events for this could be interesting. \r\n\r\n@nibanks: maybe you could give some pointers/links to where these events are defined for msquic for reference? \r\n\r\ncc @lpardue",
      "createdAt": "2021-01-20T16:56:04Z",
      "updatedAt": "2025-07-07T14:25:59Z",
      "closedAt": "2025-07-07T14:25:59Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "As far as I could intuit, MS had events for blocked and unblocked. \r\n\r\nThis seemed to be an application/  implementation event, rather than something strictly transport related. So I wonder what type of category it would fit into.",
          "createdAt": "2021-01-20T17:00:15Z",
          "updatedAt": "2021-01-20T17:00:15Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "https://github.com/microsoft/msquic/blob/main/src/inc/quic_trace.h#L44\r\n```C\r\ntypedef enum QUIC_FLOW_BLOCK_REASON {\r\n    QUIC_FLOW_BLOCKED_SCHEDULING            = 0x01,\r\n    QUIC_FLOW_BLOCKED_PACING                = 0x02,\r\n    QUIC_FLOW_BLOCKED_AMPLIFICATION_PROT    = 0x04,\r\n    QUIC_FLOW_BLOCKED_CONGESTION_CONTROL    = 0x08,\r\n    QUIC_FLOW_BLOCKED_CONN_FLOW_CONTROL     = 0x10,\r\n    QUIC_FLOW_BLOCKED_STREAM_ID_FLOW_CONTROL= 0x20,\r\n    QUIC_FLOW_BLOCKED_STREAM_FLOW_CONTROL   = 0x40,\r\n    QUIC_FLOW_BLOCKED_APP                   = 0x80\r\n} QUIC_FLOW_BLOCK_REASON;\r\n```\r\nThe lack of any flags means it's unblocked.",
          "createdAt": "2021-01-20T17:00:52Z",
          "updatedAt": "2021-01-20T17:00:52Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "And the connection has a set of flags, as well as each stream has its own set.",
          "createdAt": "2021-01-20T17:01:43Z",
          "updatedAt": "2021-01-20T17:01:43Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I guess my intuit was a bit off \ud83d\ude1c",
          "createdAt": "2021-01-20T17:01:43Z",
          "updatedAt": "2021-01-20T17:01:43Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Leaning on the side of let folks log what they like, and focus these drafts on transport events.",
          "createdAt": "2022-09-08T00:37:50Z",
          "updatedAt": "2022-09-08T00:37:50Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I still personally feel these would be very useful to have.\r\n\r\nI'm not sure why these wouldn't be part of \"transport events\" @LPardue? Seems like being blocked on e.g., flow control is a very transport-esque thing? \r\n\r\nRight now, we can somewhat deduce this information by e.g., looking at logged values for `MAX_STREAM_DATA` and friends and `*_BLOCKED` and matching those with actual `StreamFrame` sent events, but having something explicit is useful here imo. \r\n\r\n",
          "createdAt": "2022-09-29T14:35:07Z",
          "updatedAt": "2022-09-29T14:35:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "There's no QUIC message to tell your peer you can't send it data due to pacing or amplification prevention. So to do that in qlog here, we'd have to invent some new category of event and explain to people what it means and how to use it (produce and consume). \r\n\r\nYes it could be interesting but I lean on punting it to be done when there's a good case about why it needs to be defined in an interoperable way in qlog.",
          "createdAt": "2022-09-29T14:44:47Z",
          "updatedAt": "2022-09-29T14:44:47Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I still think we can live without standardizing this today. It seems a generic \"application data\" category of event can be defined that would work for e.g. both HTTP/2 and HTTP/3 sending on a stream could be blocked due to stream flow control or the transport congestion control. That's simple enough to write in a new spec.",
          "createdAt": "2023-12-09T21:12:29Z",
          "updatedAt": "2023-12-09T21:12:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I made a proposal on #444 and people didn't like it. We are blocked (pun intended) on finding an alternative. @nibanks @kazuho I'd like to make a friendly ping and move the discussion back to here.\n\nAs another proposal what about something simple like\n\n```\nStreamDataBlocked = {\n  ? stream_id: uint64\n  ? reason = $BlockedReason\n}\n\nStreamDataUnblocked = {\n  ? stream_id: uint64\n}\n\nDatagramDataBlocked = {\n  ? reason = $BlockedReason\n{\n\nDatagramDataUnblocked = {\n\n}\n\n$BlockedReason /= \"scheduling\" /\n                  \"pacing\" /\n                  \"amplification_protection\" /\n                  \"congestion_control\" /\n                  \"connection_flow_control\" /\n                  \"stream_flow_control\" /\n                  \"stream_id\" /\n                  \"application\"\n```\n\nThen a log can have a shape like\n\n```\ndo some handshake stuff\ndo some stream data handling\nsend some packets\nreceive some acks\n** stream data blocked for a reason **\ndo some other QUIC things\n** stream data unblocked **\n```",
          "createdAt": "2025-03-12T02:25:38Z",
          "updatedAt": "2025-03-12T02:25:38Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My one knee-jerk reaction to this is that that would entail a bunch of extra events... especially if you'd split up blocked and unblocked (elsewhere we always use the StateUpdated pattern with `? old` and `? new` instead, so that would be preferential here too?)\n\nIf you combine blocked/unblocked, I guess you'd need 3 extra events for QUIC (connection, stream, datagram) and 1 extra down the line for QPACK, which seems agreeable :) ",
          "createdAt": "2025-03-13T13:44:34Z",
          "updatedAt": "2025-03-13T13:44:34Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "MDU6SXNzdWU3OTUwODc3OTM=",
      "title": "Clarify that Retry, VNEG, and Stateless Reset packets don't have packet numbers",
      "url": "https://github.com/quicwg/qlog/issues/133",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "editorial",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "With draft-02, we moved packet_number to PacketHeader and used that field for all types of packets as well. \r\nHowever, packet_number is currently a required field, but Retry, Version Negotiation and Stateless Reset packets don't actually use packet numbers.\r\n\r\nI don't want to just make the packet_number field generally optional, since imo it shouldn't be for other packet types. Better (best?) solution is to add an explicit comment indicating the field MUST be omitted for the 3 exceptions and MUST be included for all others. ",
      "createdAt": "2021-01-27T13:10:01Z",
      "updatedAt": "2022-10-05T14:40:23Z",
      "closedAt": "2022-10-05T14:40:23Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Another option is to define aNumberlessPacketHeader type, which is used in packets that have no numbers",
          "createdAt": "2022-09-08T00:40:33Z",
          "updatedAt": "2022-09-08T00:40:33Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "The underlying problem here is that some fields only apply to some kind of headers. This is most obvious for the packet number, but it also applies to the Token (which is only carried on Initial packets), the Length (only on long header packets) and the SCID.\r\n\r\nIf we want to use a strict encoding scheme here, we'll probably have to define a new header for each and every packet type.",
          "createdAt": "2022-09-08T08:08:12Z",
          "updatedAt": "2022-09-08T08:08:12Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At this point in time, I think I'd be fine with just making `packet_number` an optional field and adding comments saying that it of course should be logged if available.\r\n\r\nSplitting into several events seems icky just for this (especially not if you'd split it more than once as Marten indicates) and in the end implementers will still choose themselves which fields to log. If they don't include `packet_number` they probably don't need it for their use case (if they do, the lack of it becomes obvious quite immediately).\r\n\r\nThat doesn't detract libraries/implementations of the qlog schema (e.g., @LPardue's rust crate) to enforce this by including multiple types, but I wouldn't have this in qlog (at least not in my current thinking).\r\n\r\nIn short: I propose to change to `? packet_number: uint64`.\r\n",
          "createdAt": "2022-09-28T14:01:35Z",
          "updatedAt": "2022-09-28T14:01:35Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> In short: I propose to change to ? packet_number: uint64.\r\n\r\nSounds reasonable to me.",
          "createdAt": "2022-09-28T16:41:42Z",
          "updatedAt": "2022-09-28T16:41:42Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Optional packet number sounds good too. we already have other optional fields with the conditions of usage stated clearly. This is just another one",
          "createdAt": "2022-09-28T16:46:03Z",
          "updatedAt": "2022-09-28T16:46:03Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "MDU6SXNzdWU3OTUwOTU4NTU=",
      "title": "Multipath support",
      "url": "https://github.com/quicwg/qlog/issues/134",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "quic-http3-fields",
        "future-versions"
      ],
      "body": "With the multipath conversation gaining traction in the QUIC wg, it's time to start thinking more seriously about adding (rough) multipath support to qlog and qvis to aid practical implementation efforts (e.g., see https://huitema.wordpress.com/2021/01/26/implementing-multipath-in-quic).\r\n\r\nThe simplest approach that I can see would be to associate a `path_id` with each qlog event:\r\n\r\n```\r\nEvent definition without multipath:\r\nclass Event {\r\n    time: number,\r\n    name:string,\r\n    data:any\r\n}\r\n\r\nEvent definition with multipath:\r\nclass Event {\r\n    time:number,\r\n    name:string,\r\n    path_id:number | string,\r\n    data:any\r\n}\r\n```\r\n\r\nThis would allow users to log all events belonging to a single \"connection\" to differentiate per-path events without having to split them up in separate qlog Trace objects. Additionally, it prevents from having to overload the existing `group_id` field with an additional meaning.\r\n\r\nHowever, the main problem I can see is that the `path_id` (which can be anything, preferably an opaque/obscured value) is not available everywhere in the code that wants to output a qlog event. For example, a congestion controller will wish to output the `recovery:metrics_updated` event, but might not necessarily have the `path_id` available in the code path where these metrics are calculated/available (e.g., if a congestion control method is re-used as-is between single-path and multi-path QUIC). Similar concerns exist for other events (e.g., ACK processing or event `packet_sent` if this is logged before the packet scheduler decides which path to take). \r\n\r\nWhile there are of course always solutions to this (e.g., pass the path_id as extra parameter/as global variable/put it on a stack/put it on a logging object reference/etc.) it is at this time unclear if this is an actual problem and if implementers would wish to add these patchwork \"solutions\" if required, just to get proper qlog output.\r\n\r\nCC @huitema @mpiraux\r\n\r\n\r\n",
      "createdAt": "2021-01-27T13:20:50Z",
      "updatedAt": "2024-03-19T11:58:37Z",
      "closedAt": "2024-03-19T11:58:37Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I will try implement that and give you feedback. I think this is natural for QUIC level events, not so much for application level events.",
          "createdAt": "2021-01-27T20:25:29Z",
          "updatedAt": "2021-01-27T20:25:29Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Excellent! Having implementation experience will help here, while example output traces will help get something into qvis. \r\n\r\nThe `path_id` would indeed only be for transport-layer events. For application-layer events, I was thinking to either omit the `path_id` (and specify that events without path_id should be considered cross-path/valid for all paths/...) or give a special `path_id` value (e.g., \"app\"), though omitting it seems cleanest and most optimized. ",
          "createdAt": "2021-01-28T10:53:35Z",
          "updatedAt": "2021-01-28T10:53:35Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I am finding a first difficulty: how does one define the path identifier? The uniflo ID in draft-deconinck and the DCID sequence number in draft-liu have very similar properties: they define flows in only one direction. But the numbers derived from the DCID are place holders. The \"actual path\" is defined by the addresses and ports from and to which packets are sent. The DCID maps to that when it is present, but what if is not? Today, a popular setup is for clients (but not servers) to use NULL connection IDs -- this minimizes overhead in the server-to-client direction. The solution that I presented in draft-huitema allows that; my implementation of draft-liu also allows it. But if there is no DCID in the packets sent from server to client, how shall I define the path-id?\r\n\r\nFor picoquic, I could use the DCID ID sequence number when the DCID is present, and an arbitrary \"path number\" when it is not. But doing that will not result in a good log, because if the choice is arbitrary the path-id in the client log may not match the path-id in the server log. We do want to be able to match events from client and server log, so we have to do something better. My take is the following:\r\n\r\n* If the DCID is present, use the number associated with it.\r\n* If the DCID is NULL, check whether there is a CID used in the reverse direction. If it is present, use the number associated with that CID.\r\n* If the DCID is NULL in both direction, use the number 0.\r\n\r\nNote that if solutions allow the use of NULL DCID, they will need to somehow provide a way to identify the paths -- if only because they need to ask the peer to \"abandon path X\" when they loose connectivity on that path, and they need an identifier for that. It is just that the proposals are not quite mature enough...\r\n\r\n ",
          "createdAt": "2021-01-29T00:40:40Z",
          "updatedAt": "2021-01-29T00:40:40Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That is some very useful feedback! \r\n\r\nI hadn't considered that we need to define a way to choose the `path_id` to make it possible to sync up client and server-side traces purely on `path_id`... I think your proposal makes sense, though we would have to specify concretely how to derive the `path_id` \"number\" from the connection ID (i.e., simply taking the first/last 8 bits or similar is simple enough, but might not be optimal considering privacy down the line (e.g., in setups where you don't even want to log the real CIDs)). \r\n\r\nAn alternative approach would be to shift the client/server path correlation to the tools themselves (i.e., have them use knowledge about the Multipath extension and IP+port info to link `path_id`s), but that has similar privacy issues...\r\n\r\nIt seems like the final solution would indeed depend on the chosen Multipath design (e.g., if that always requires a DCID + seq nr or Uniflow ID, we can just use that). For now, we can probably make due with a simpler scheme like the one you propose to get implementation experience. \r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-01-29T16:15:45Z",
          "updatedAt": "2021-01-29T16:15:45Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Personally, I'd add a PathCreated event, that defines an arbitrary ID and all the parameters necessary to describe it. You might also want a PathUpdated event if you need to modify any of those parameters before the PathDestroyed event. For all other events that must represent \"the path\" they merely use the arbitrary ID.\r\n\r\nWe generally try to use this model for all event logging in MsQuic, though, much of the time, we use the object * for the ID for additional usefulness when live debugging.",
          "createdAt": "2021-01-29T16:42:52Z",
          "updatedAt": "2021-01-29T16:43:16Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@nibanks with arbitrary identifiers, how do you reconcile client log and server log?",
          "createdAt": "2021-01-29T16:45:39Z",
          "updatedAt": "2021-01-29T16:45:39Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "You obviously cannot just use the ID value. You must search for two paths with the same parameters and associate those path objects.",
          "createdAt": "2021-01-29T16:46:39Z",
          "updatedAt": "2021-01-29T16:46:39Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That seems tantamount to the second option I described @nibanks, but the question then becomes: what are those parameters? IIUC those would mainly be IP+port info, which is not something a privacy-aware endpoint would want to include in their qlogs. ",
          "createdAt": "2021-01-29T16:50:07Z",
          "updatedAt": "2021-01-29T16:50:07Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "If you're warry of PII, you simply include a hash of the information. Then your parser must understand both raw data format and hash format. If one side includes raw and the other a hash, then the parser converts raw to hash and does the comparison.",
          "createdAt": "2021-01-29T16:56:43Z",
          "updatedAt": "2021-01-29T16:56:43Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So that is a more general question I'm struggling with wrt qlog privacy and whether hashing is enough. Conceptually, if the attacker is looking for a specific (set of) IP(s) or users, and the hashing function is known (which it has to be to correlate independent client-server logs), they could still derive if a trace was for a given IP/user or not by generating hashes for all IPs/users under consideration. \r\n\r\nI'm not at all sure if that's an actual concern in practice or even something that can be worked around (I need to do more reading on data anonymization). It's also a bit esoteric, as you'd only need to use that type of hashing if you know you want to cross-correlate logs (which you probably don't want to do in production?), otherwise you can just use internal opaque IDs. But that's a potential issue here imo, and one that could require a rework of the mechanism should we choose the hashing approach now and it is deemed too \"dangerous\" later. \r\n\r\nAs I've said however, for now to allow us to make progress, I have no qualms choosing this type of approach to get experience. I also feel some generic path-related events are needed (e.g., path_created, path_updated, path_removed etc.) besides just the `path_id`. ",
          "createdAt": "2021-01-29T17:18:20Z",
          "updatedAt": "2021-01-29T17:18:20Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "First off, I think the notion of privacy should be a separate Issue and not discussed here. Still, I don't think you're going to be able to completely solve this without exchanging a completely arbitrary value on the wire. If you want two independent parties to log the same thing, they have to agree on a mechanism to turn PII_DATA -> ANONYMIZED_DATA. So you have to standardize a mechanism to do that. If it's standardized then anyone who knows of a particular PII_DATA can convert it as well. The best you can do is have the method be key based, but that only helps if 1) both the client and server know the key and 2) the person you want to view the logs but not be able to correlate **not** know the key. I'm not sure how you'd achieve that.",
          "createdAt": "2021-01-29T17:23:36Z",
          "updatedAt": "2021-01-29T17:23:36Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Yes, the tools could rely on addresses and ports to match paths. But in the presence of NAT the values changes. You end up requiring heuristics.\r\n\r\nAs for going to anonymized data, there is a whole body of literature on the subject, and it is not easy to be both anonymous and useful. Plus there is an interesting problem of comparing hashes after NAT.",
          "createdAt": "2021-01-29T18:00:34Z",
          "updatedAt": "2021-01-29T18:00:34Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Another question regarding default values. What happens if there is path_id specified for some events, but not for others?\r\n\r\nAsking that because I would like to not include a path_id in the qlog files if not using multipath. My preference would be using a default \"path_id = 0\" when the element is absent.",
          "createdAt": "2021-01-30T06:53:47Z",
          "updatedAt": "2021-01-30T06:53:47Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As I mentioned above (https://github.com/quiclog/internet-drafts/issues/134#issuecomment-768970236), I indeed feel you should be able to omit `path_id` on events that do not require it and that a single trace can perfectly contain events with and without `path_id` set. \r\n\r\nI don't fully agree with the semantics of making an omission imply a default path_id value though, as e.g., HTTP/3 events will probably always lack a `path_id` as they belong to \"all paths\" concurrently. \r\n\r\nPut differently: there is a (subtle) difference between \"omission = default value\" and \"omission = belongs to all paths\", and I'd prefer the latter. This also holds up in the non-multipath case.",
          "createdAt": "2021-01-30T10:40:33Z",
          "updatedAt": "2021-01-30T10:40:33Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I have a bit of a situational argument. I have logging tests that simulate a connection, generate a log, and compare the log to the reference value. As I am implementing multipath log, I am running these monopaths tests and verifying that \"nothing changed\". The alternative would be to allow that something changes (allow path_id=0 here and there), and then check the result line by line to verify that the difference with the reference is as expected. Of course that's doable to. It is just way more time consuming...",
          "createdAt": "2021-01-30T23:57:20Z",
          "updatedAt": "2021-01-30T23:57:20Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "OK. At that point, I need some advice on the JSON formatting. In the traces, the events look like:\r\n```\r\n[0, \"recovery\", \"metrics_updated\", {\"bytes_in_flight\": 3202}],\r\n```\r\nAs you can see, we have a simplified notation, in which the headers are omitted. The simplification is defined in the header element:\r\n```\r\n\"event_fields\":[\"relative_time\",\"category\",\"event\",\"data\"],\r\n```\r\nOnce I have defined the \"events fields\", it appears that writing something like this is invalid:\r\n```\r\n[70892, \"path_id\": 1, \"recovery\", \"metrics_updated\", {\"bytes_in_flight\": 2747,\"smoothed_rtt\": 25681}],\r\n```\r\nI suppose that my only option would be to write:\r\n```\r\n\"event_fields\":[\"relative_time\",\"path_id\",\"category\",\"event\",\"data\"],\r\n...\r\n[70892, 1, \"recovery\", \"metrics_updated\", {\"bytes_in_flight\": 2747,\"smoothed_rtt\": 25681}],\r\n```\r\nWhich requires writing the path ID on every event. Is that correct?",
          "createdAt": "2021-01-31T02:06:26Z",
          "updatedAt": "2021-01-31T02:41:43Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "OK, so I went ahead and updated the picoquic qlog code to add a path_id to the event header when multipath is being negotiated. Although conceptually simple, that changes a lot of code in a lot of places. The PR is at https://github.com/private-octopus/picoquic/pull/1124.\r\n\r\nHere is an example of multipath log:\r\n[multipath_qlog_ref.txt](https://github.com/quiclog/internet-drafts/files/5899304/multipath_qlog_ref.txt)\r\n \r\n\r\n",
          "createdAt": "2021-01-31T06:58:30Z",
          "updatedAt": "2021-01-31T06:58:30Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "This is another example of qlog with multipath traffic: \r\n[simple_multipath_qlog_ref.txt](https://github.com/quiclog/internet-drafts/files/5938171/simple_multipath_qlog_ref.txt). This one uses the \"simple multipath\" option that I defined in my original draft, which uses a single packet number space. As you will see, the sequence displays well with qvis, although some visualisation of path-id would be nice. The congestion graph, on the other hand, is also wrong. Maybe less wrong than the previous multipath variant, but there really should be one graph per path for congestion window, bytes in flight, etc.",
          "createdAt": "2021-02-07T02:52:17Z",
          "updatedAt": "2021-02-07T02:52:17Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "To avoid scope creep, I think we need to punt as much of the multipath qlog work as possible on to another document. \r\n\r\nWhat are the minimal viable changes to the qlog specs, that need to happen now, in order to ensure future work on logging can succeed? If the CDDL supports extension of type by insertion of new fields, I might suspect the minimal changes could be zero.\r\n",
          "createdAt": "2022-09-08T00:46:22Z",
          "updatedAt": "2022-09-08T00:46:22Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Yes, I suppose we could defer to \"qlog extensions for multipath, TBD\". But having a path_id in the header to qualify the packet number would be very convenient.",
          "createdAt": "2022-09-08T01:30:16Z",
          "updatedAt": "2022-09-08T01:30:16Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "A single field sounds reasonable today. Let's hammer down on whether anyone objects to that.",
          "createdAt": "2022-09-08T01:49:18Z",
          "updatedAt": "2022-09-08T01:49:18Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "In general, I agree a single new field seems reasonable, but which events does it apply to? Just packet events? Congestion control / loss recovery? Not every event needs to be path aware.",
          "createdAt": "2022-09-08T11:35:36Z",
          "updatedAt": "2022-09-08T11:35:36Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "The multipath specification uses path specific number spaces. In 1 RTT packets, path numbers are qualified by a packet-number-space identifier (a.k.a., path ID). This is set to the sequence number of the destination OID. My early observation was that this was really confusing for tools like QVIS, which would see the same packet number occurring multiple times. Yes, they could somehow parse the transport parameters and infer that they should be multipath aware, and then match the sequence number space with the sequence number of the OID. But that's quite a bit of work, and stating the path-ID would make that process much simpler.\r\n\r\nThe other frames that are path aware are the ACK frames, Path Abandon Frames, and Path Status frames. There is a special type of ACK frame for multipath, and the ACK-MP frames explicitly carry the path ID; the Status and Abandon frames also do. No need for anything else than \"learn to parse these frames.\"",
          "createdAt": "2022-09-09T05:52:22Z",
          "updatedAt": "2022-09-09T05:52:22Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not too sure I like the \"single field\" option for inclusion in the current documents...\r\n\r\nThe only way this would work as a single addition (that I can see) is to add it to the main event definition, for example:\r\n```\r\nEvent = {\r\n    time: float64\r\n    name: text\r\n    ; only used in multipath contexts\r\n    ? path_id: text\r\n    data: $ProtocolEventBody\r\n\r\n    ? time_format: TimeFormat\r\n\r\n    ? protocol_type: ProtocolType\r\n    ? group_id: GroupID\r\n\r\n    ; events can contain any amount of custom fields\r\n    * text => any\r\n}\r\n```\r\n\r\nSomething like that is easy enough to do in an extension document that can give more context. \r\n\r\n------\r\n\r\nThat being said, we do still need to decided how to properly handle RFC9000 connection migration and how/if to log IP addresses for QUIC packets, which this has overlap with (discussed partially in https://github.com/quicwg/qlog/pull/211#issuecomment-1249383687). \r\n\r\nI don't think handling connection migration is best done with a singular `path_id` field, but I could very well be wrong. \r\n\r\n",
          "createdAt": "2022-09-29T13:19:14Z",
          "updatedAt": "2022-09-29T13:44:13Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by https://github.com/quicwg/qlog/pull/336",
          "createdAt": "2024-03-19T11:58:34Z",
          "updatedAt": "2024-03-19T11:58:34Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "MDU6SXNzdWU4MDE4MDg0MTI=",
      "title": "DPLPMTUD events",
      "url": "https://github.com/quicwg/qlog/issues/135",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "design",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "While DPLPMTUD is optional, there's an [entire section](https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#name-datagram-packetization-laye) about it in QUIC transport.\r\n\r\nMinimal support for this in qlog would define an event `mtu_increased` for every increase of the MTU:\r\n```\r\n{\r\n     new_mtu: uint16\r\n}\r\n```\r\n\r\nI don't think we need a separate event for the sending of an MTU probe packet, but we should probably standardize a `trigger` for this. Suggestion: `mtu_probe`.\r\n\r\nOpen question: Do we want a separate failure event? Failure would be either the loss of an MTU probe packet, or (for implementations that pay attention to ICMP packets) the receipt of an ICMP Packet Too Big (PTB) message.",
      "createdAt": "2021-02-05T03:23:23Z",
      "updatedAt": "2022-09-09T13:59:41Z",
      "closedAt": "2022-09-09T13:59:41Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree it would be useful to have this information in qlog.\r\n\r\nIn terms of design, as always there are several options:\r\n1) have separate events for this (`mtu_updated`, `mtu_probe_sent`, `mtu_probe_lost`, etc.)\r\n2) integrate them into existing events( triggers on `packet_sent` and `packet_lost`, new `mtu` field in `metrics_updated`)\r\n3) a combination of these approaches (which is what you suggest IIUC)\r\n\r\nThis is imo a good example of where we need clear design guidelines on how to add new information/events to qlog. \r\n",
          "createdAt": "2021-02-09T13:41:25Z",
          "updatedAt": "2021-02-09T13:41:25Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Revisiting this after a long time:\r\n* `mtu_probe_sent` is problematic, as this would essentially be a copy of the normal `packet_sent` event (it is allowed, although not recommended, to just send normal application data as a probe packet). The trigger seems to be the best solution here\r\n* `mtu_updated` needs to be a separate event, there's just no way we can reasonably collapse this into an acknowledgment event\r\n* `mtu_probe_lost` is what I'm still undecided about. This logically belongs to the regular `packet_lost` event, we'd just need a way to attach \"oh and by the way, this was a MTU probe packet\". In fact, it would be really useful to have it on that event, since the congestion control implications are very different for lost MTU packets (i.e., you wouldn't decrease your cwnd).",
          "createdAt": "2022-06-29T11:39:38Z",
          "updatedAt": "2022-06-29T11:39:38Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> The trigger seems to be the best solution here\r\n\r\nI have to disagree with myself here. The sending of the packet might have been triggered by something else, it's just that the stack decided to send a probe packet.\r\n\r\nI suggest:\r\n1. Add a `isMTUProbePacket` optional `bool` on the `packet_sent` and `packet_lost` events.\r\n2. Add a `mtu_updated` event.\r\n",
          "createdAt": "2022-06-29T15:09:09Z",
          "updatedAt": "2022-06-29T15:09:09Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Supporting DPLPMTUTD events seems important to cover in the base specs. ",
          "createdAt": "2022-09-08T00:47:26Z",
          "updatedAt": "2022-09-08T00:47:26Z"
        }
      ]
    },
    {
      "number": 136,
      "id": "MDU6SXNzdWU4MDI5Mjc3MTg=",
      "title": "add a field to log the code version",
      "url": "https://github.com/quicwg/qlog/issues/136",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "design",
        "high-level-schema",
        "current-version"
      ],
      "body": "With many iterations of my qlog implementation running in production now, it would be helpful if there was a way to tell which version of my code generated any particular qlog file (even better if qvis could display it somewhere).\r\n\r\nI suggest adding an optional `code_version` to the `Trace` container. Implementations could fill this field with whatever they want. In quic-go, I'd probably use something like `quic-go $(git describe --long --dirty)`.",
      "createdAt": "2021-02-07T11:14:07Z",
      "updatedAt": "2023-03-01T19:38:45Z",
      "closedAt": "2023-03-01T19:38:45Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "A similar argument applies to architecture information. It would be useful to have a field to log OS / architecture / kernel information / compiler version.",
          "createdAt": "2021-02-07T11:36:20Z",
          "updatedAt": "2021-02-07T11:36:20Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree this is useful information, but I'm not 100% sure it makes sense to standardize this, as I'd assume the handling of this field would depend on the company/deployment/tool and as you say, the contents can also differ wildly. Note that it's in my opinion perfectly acceptable to have qvis display a field that isn't defined in the qlog docs as such (i.e., qvis is broader than qlog). \r\n\r\nIf we do want to include this type of thing in qlog proper, I'd propose putting it beneath the existing `configuration` field, or add a new `environment` field. ",
          "createdAt": "2021-02-09T13:45:45Z",
          "updatedAt": "2021-02-09T13:45:45Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> Note that it's in my opinion perfectly acceptable to have qvis display a field that isn't defined in the qlog docs as such\r\n\r\nAre you suggesting that qvis defines additional fields / events? That's an interesting idea.\r\nIn this case though, I'd argue that `environment` (which is a lot better name than the `code_version` I suggested) is something that would be a useful thing to display for a variety of tools, so it would probably make sense to define it here.",
          "createdAt": "2021-02-09T13:57:56Z",
          "updatedAt": "2021-02-09T13:57:56Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, I remain of the opinion that it would not make much sense to standardize this (whether it's Configuration, Summary, Environment or a combination thereof). The proposed new field in #208 as simply a generic text value reinforces that opinion. \r\n\r\nHowever, if we do want to do this, I'd propose to just merge all of this into a single field of a generic object type, i.e.,:\r\n\r\n```\r\nBikesheddedTypeName = {\r\n    * text => any\r\n}\r\n```\r\n\r\nWhere people can go crazy adding `configuration`, `environment`, etc. members as they see fit. This feels more flexible than having a `text` field. \r\n\r\nFinally, #208 only adds this to the Trace object, not TraceSeq. Any chosen solution should be enforced on both trace types. ",
          "createdAt": "2022-09-16T14:39:44Z",
          "updatedAt": "2022-09-16T14:39:44Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on call. Decided to close this and associated PR with no action and keep the `configuration` field for this purpose. ",
          "createdAt": "2023-03-01T19:38:45Z",
          "updatedAt": "2023-03-01T19:38:45Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "MDU6SXNzdWU4MjAxNTgzNDQ=",
      "title": "Prepare for adoption",
      "url": "https://github.com/quicwg/qlog/issues/137",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "List of thinks to keep in mind when preparing for QUIC wg adoption:\r\n- Split QUIC and HTTP/3 event definitions into separate drafts (ensure proper cross-reference)\r\n- Update editor names and affiliations\r\n- Specify which value of `protocol_type` to use for each document (and change to array-based already?)\r\n- Move shared stuff to the main schema document\r\n  - RawInfo (though not 100% sure that's generic enough for all protocols?)\r\n  - The whole \"generic\" category (error, warning, verbose, etc.)\r\n  - Potentially the \"Importance\" indicators (Core, Base, Extra)\r\n- Add more information about \"previous versions\" (e.g., two main versions in production, -01 and -02, those pre-date these adopted documents)\r\n- Define a new version codepoint for the adopted drafts (now it's still draft-03-wip, but we also can't just do draft-00 or we'll overlap soon. Maybe qlog-0x?)\r\n- rename master branch to main #140 \r\n- Send e-mail to mailing list detailing the changes. Chairs will send a separate email with call for adoption afterwards.\r\n\r\nConcrete steps for splitting / preparing the drafts according to @lpardue:\r\n\r\n```\r\ncp draft-marx-qlog-event-definitions-quic-h3.md draft-marx-qlog-quic-events.md\r\ncp draft-marx-qlog-event-definitions-quic-h3.md draft-marx-qlog-h3-events.md\r\n\r\n# add comment into draft-marx-qlog-event-definitions-quic-h3.md saying \"beginning the split\"\r\n\r\ngit add draft-marx-qlog-event-definitions-quic-h3.md draft-marx-qlog-quic-events.md draft-marx-qlog-h3-events.md\r\n\r\ngit commit -m \"starting document split\"\r\n\r\n# then delete all the non-relevant text in draft-marx-qlog-quic-events.md and draft-marx-qlog-h3-events.md, and move necessary text to main-schema, then\r\n\r\ngit -rm draft-marx-qlog-event-definitions-quic-h3.md\r\ngit add draft-marx-qlog-quic-events.md draft-marx-qlog-h3-events.md\r\n\r\ngit commit -m \"complete document split\"\r\n\r\n# then update editors and other metadata in the 3 documents\r\n\r\ngit commit -m \"prepare for adoption\"\r\n\r\n# then submit 03, 00, 00 as individual I-Ds that we can issue a call for adoption on\r\n```\r\n\r\n",
      "createdAt": "2021-03-02T16:04:51Z",
      "updatedAt": "2021-05-15T19:31:24Z",
      "closedAt": "2021-05-15T19:31:24Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I hadn't appreciated you might need to also move stuff into the main schema. If that is too onerous a task at this stage then you could just mark it in the docs and leave it there for the being.\r\n\r\nThe important thing is the get the overall structure in place and agreed. The content of each document can then be evolved through the working group.",
          "createdAt": "2021-03-18T18:21:32Z",
          "updatedAt": "2021-03-18T18:21:32Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "MDU6SXNzdWU4MzQ3MDkwODQ=",
      "title": "How to deal with (aggregated) measurements",
      "url": "https://github.com/quicwg/qlog/issues/139",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "future-versions"
      ],
      "body": "The [spindump project](https://github.com/EricssonResearch/spindump) provides (aggregated) protocol measurements (e.g., RTT, loss, connection count, etc.) from middleboxes. They would like to use qlog as an output format and have [prototyped](https://github.com/EricssonResearch/spindump/blob/master/src/spindump_event_printer_qlog.c) what that [might look like](https://github.com/EricssonResearch/spindump/blob/master/Format.md#qlog-format).\r\n\r\nExample of their current output:\r\n```\r\n$ src/spindump --input-file src/../test/trace_quic_rfc_quant_long_qlog.pcap --textual --format text --not-report-notes --format qlog\r\n\r\n{\"qlog_version\": \"draft-02\", \"qlog_format\": \"JSON\", \"description\": \"Spindump measurements\", \"traces\": [\r\n\r\n { \"vantage_point\": { \"type\": \"network\" }, \"events\": [\r\n\r\n     {\"time\": 1614616215488286, \"protocol_type\": QUIC, \"group_id\": \"sd-0\", \"event\": \"connection_started\", \r\n\r\n      \"ip_version\": \"ipv4\", \"src_ip\": \"10.30.0.167\", \"dst_ip\": \"91.190.195.94\", \"src_port\": \"49702\", \"dst_port\": \"4433\", \"src_cid\": \"041d0cd3\", \"dst_cid\": \"c2e9970d6b5925175646\", \r\n\r\n      \"data\": {\"packets1\": 0, \"packets2\": 0, \"bytes1\": 0, \"bytes2\": 0}},\r\n\r\n     {\"time\": 1614616216598876, \"protocol_type\": QUIC, \"group_id\": \"sd-0\", \"event\": \"connection_started\", \r\n\r\n      \"ip_version\": \"ipv4\", \"src_ip\": \"10.30.0.167\", \"dst_ip\": \"91.190.195.94\", \"src_port\": \"49702\", \"dst_port\": \"4433\", \"src_cid\": \"041d0cd3\", \"dst_cid\": \"0487c887\", \r\n\r\n      \"data\": {\"packets1\": 2, \"packets2\": 1, \"bytes1\": 2728, \"bytes2\": 298, \"bandwidth1\": 1500, \"bandwidth2\": 298}},\r\n\r\n     {\"time\": 1614616216598876, \"protocol_type\": QUIC, \"group_id\": \"sd-0\", \"event\": \"measurement\", \r\n\r\n      \"data\": {\"packets1\": 2, \"packets2\": 1, \"bytes1\": 2728, \"bytes2\": 298, \"bandwidth1\": 1500, \"bandwidth2\": 298, \"right_rtt\": 109806}},\r\n\r\n     {\"time\": 1614616217177621, \"protocol_type\": QUIC, \"group_id\": \"sd-0\", \"event\": \"measurement\", \r\n\r\n      \"data\": {\"packets1\": 7, \"packets2\": 18, \"bytes1\": 3159, \"bytes2\": 21320, \"bandwidth1\": 1500, \"bandwidth2\": 21320, \"right_rtt\": 70432}},\r\n\r\n     {\"time\": 1614616217178198, \"protocol_type\": QUIC, \"group_id\": \"sd-0\", \"event\": \"measurement\", \r\n\r\n      \"data\": {\"packets1\": 7, \"packets2\": 19, \"bytes1\": 3159, \"bytes2\": 21415, \"bandwidth1\": 1500, \"bandwidth2\": 21415, \"left_rtt\": 577}},\r\n\r\n     {\"time\": 1614616217178198, \"protocol_type\": QUIC, \"group_id\": \"sd-0\", \"event\": \"measurement\", \r\n\r\n      \"data\": {\"packets1\": 7, \"packets2\": 19, \"bytes1\": 3159, \"bytes2\": 21415, \"bandwidth1\": 1500, \"bandwidth2\": 21415, \"full_rtt_initiator\": 71009}},\r\n\r\n     {\"time\": 1614616217545056, \"protocol_type\": QUIC, \"group_id\": \"sd-0\", \"event\": \"measurement\", \r\n\r\n      \"data\": {\"packets1\": 9, \"packets2\": 26, \"bytes1\": 3275, \"bytes2\": 30375, \"bandwidth1\": 1500, \"bandwidth2\": 30375, \"right_rtt\": 366858}},\r\n\r\n     {\"time\": 1614616217545056, \"protocol_type\": QUIC, \"group_id\": \"sd-0\", \"event\": \"measurement\", \r\n\r\n      \"data\": {\"packets1\": 9, \"packets2\": 26, \"bytes1\": 3275, \"bytes2\": 30375, \"bandwidth1\": 1500, \"bandwidth2\": 30375, \"full_rtt_responder\": 367435}},\r\n\r\n     {\"time\": 1614616217546034, \"protocol_type\": QUIC, \"group_id\": \"sd-0\", \"event\": \"measurement\", \r\n\r\n      \"data\": {\"packets1\": 9, \"packets2\": 30, \"bytes1\": 3275, \"bytes2\": 34607, \"bandwidth1\": 1500, \"bandwidth2\": 34607, \"left_rtt\": 978}},\r\n\r\n     {\"time\": 1614616217546034, \"protocol_type\": QUIC, \"group_id\": \"sd-0\", \"event\": \"measurement\", \r\n\r\n      \"data\": {\"packets1\": 9, \"packets2\": 30, \"bytes1\": 3275, \"bytes2\": 34607, \"bandwidth1\": 1500, \"bandwidth2\": 34607, \"full_rtt_initiator\": 367836}},\r\n\r\n     {\"time\": 1614616217643280, \"protocol_type\": QUIC, \"group_id\": \"sd-0\", \"event\": \"measurement\", \r\n\r\n      \"data\": {\"packets1\": 11, \"packets2\": 30, \"bytes1\": 3386, \"bytes2\": 34607, \"bandwidth1\": 1775, \"bandwidth2\": 34607, \"right_rtt\": 97246}},\r\n\r\n     {\"time\": 1614616217643280, \"protocol_type\": QUIC, \"group_id\": \"sd-0\", \"event\": \"measurement\", \r\n\r\n      \"data\": {\"packets1\": 11, \"packets2\": 30, \"bytes1\": 3386, \"bytes2\": 34607, \"bandwidth1\": 1775, \"bandwidth2\": 34607, \"full_rtt_responder\": 98224}}  \r\n\r\n ]}]}\r\n```\r\n\r\nThe semantics of logging measurements from a middlebox can differ from logging endpoint events, as the middlebox doesn't have all the contextual information.\r\n\r\nOne example is the `connection_started` event vs possible events like `connection_migrated` or `tuple_changed` (which we don't have yet, but will someday #79). The middlebox can't really tell the difference for a protocol like QUIC, and always logging either `_started` or `_changed` is semantically not 100% correct (it's more like \"first observed\").\r\n\r\nSomething similar can be said for using `recovery:metrics_updated` to log changes to e.g., RTT or loss rates. They have now defined a custom `measurement` event, which I feel is maybe too generic. You could also question if logging all measurement fields together in a single event is optimal (though this is the approach we do take with things like `metrics_updated`. See #85 for more discussion).\r\n\r\nAnother interesting observation is the need to log metrics in two directions, as the middlebox is somewhere in between 2 endpoints in the network. This all seems to indicate measurement-specific events is the way to go (i.e., not re-using existing qlog  endpoint events), as it would be confusing to have those semantics in endpoint events. \r\n\r\nSomething not yet reflected in here are the possibility to log percentiles, which seems interesting as a generic option for (aggregated) measurement logging. \r\n\r\nCC @jariarkko @ihlar\r\n\r\n ",
      "createdAt": "2021-03-18T11:40:32Z",
      "updatedAt": "2022-11-01T10:35:20Z",
      "closedAt": "2022-11-01T10:35:20Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This is interesting but I'm struggling to identify  clear or actionable feedback on the qlog draft. \r\n\r\nRobin said:\r\n\r\n>  This all seems to indicate measurement-specific events is the way to go (i.e., not re-using existing qlog endpoint events), as it would be confusing to have those semantics in endpoint events.\r\n\r\nIf qlog is flexibile enough for their needs and we don't need to do anything, let's close the issue. If people don't agree, please speak up now.",
          "createdAt": "2022-09-08T01:20:03Z",
          "updatedAt": "2022-09-08T01:20:03Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed with Lucas here. There more I've thought about this over time, the more it seems to me this is potentially something perpendicular to qlog itself and/or can be done as a standalone extension later. \r\n\r\nAny indication on progress for this within spindump @jariarkko @ihlar? If not, we'll close this with no action soon. ",
          "createdAt": "2022-09-29T14:19:14Z",
          "updatedAt": "2022-09-29T14:19:14Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "MDU6SXNzdWU4MzQ4NjYwNTY=",
      "title": "Move default git branch from master to main",
      "url": "https://github.com/quicwg/qlog/issues/140",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In preparation of QUIC wg adoption (which plans to take over ownership of this entire repo), we should make \"main\" the default branch instead of \"master\". \r\n\r\nI plan to do this sometime over the coming weeks; this is just a heads-up so people don't suddenly see local checkouts breaking. ",
      "createdAt": "2021-03-18T14:15:03Z",
      "updatedAt": "2021-08-02T13:03:51Z",
      "closedAt": "2021-08-02T13:03:51Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Closing as done",
          "createdAt": "2021-08-02T13:03:51Z",
          "updatedAt": "2021-08-02T13:03:51Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "MDU6SXNzdWU4MzQ5Mzc1ODU=",
      "title": "Fix up TypeScript-based data definition language",
      "url": "https://github.com/quicwg/qlog/issues/141",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "editorial",
        "current-version"
      ],
      "body": "There are some problems with the current definition in -02, mostly identified by @mikkelfj.\r\nIt will depend on if we stick with this approach later whether these comments need to be addressed or not. Some of them are relevant to other data definition languages as well.\r\n\r\n1. we define booleans as strings \"true\" / \"false\", while JSON has native true/false\r\n2. we currently have many mixed-type fields (e.g., things that are string | uint32). While e.g., binary serializers (say protocol buffers/flatbuffers) are free to choose which type/types is/are most appropriate for them to support, we should probably indicate which of the options is the \"main\" type.\r\n3. Similarly to 2., where we use the `any` type, we should indicate a `default` option or example of what might be expected/used in the typical case\r\n4. The packetType enum that uses onertt = \"1RTT\" and zerortt = \"0RTT\" does so for a purely JavaScript-esque reason which shouldn't be reflected in the draft",
      "createdAt": "2021-03-18T15:22:42Z",
      "updatedAt": "2021-08-18T13:33:52Z",
      "closedAt": "2021-08-18T13:33:52Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Duplicate of/related to #143, use that for further tracking",
          "createdAt": "2021-08-18T13:33:50Z",
          "updatedAt": "2021-08-18T13:33:50Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWU4NDYyMTYxNjg=",
      "title": "Provide clear privacy and security guidelines",
      "url": "https://github.com/quicwg/qlog/issues/142",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design",
        "privacy",
        "discuss",
        "ask-3rd-party"
      ],
      "body": "qlog should be specific about which fields are potentially privacy sensitive and the possible actions that can be taken to mitigate these issues (e.g., hashing, exclusion, mapping, ...). \r\n\r\nThe current proposal is to work with multiple sanitization levels, depending on the intended use case. \r\nThe way this is expressed in the drafts depends on the data definition format we end up adopting. \r\n\r\nOne potential source of inspiration is https://www.tracewrangler.com, which anonymizes pcaps. \r\n\r\nOther related considerations are whether to provide options to encrypt qlogs themselves.\r\n\r\nThis is intended to be an overarching summary issue, with sub-issues expected for specific approaches/proposals. ",
      "createdAt": "2021-03-31T08:50:43Z",
      "updatedAt": "2023-11-08T10:18:37Z",
      "closedAt": "2023-11-08T10:18:36Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "On the topic of encrypting the logs themselves, I think that shouldn't be specified. How ever the owner of the log wants to secure the file at rest should be up to them.",
          "createdAt": "2021-03-31T14:07:00Z",
          "updatedAt": "2021-03-31T14:07:00Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that makes sense. I feel some of the remarks on this point were mainly tied to the serialization format selection. i.e., if we use CBOR, we get COSE (https://tools.ietf.org/html/rfc8152) \"for free\", which in turn might be an additional reason to chose CBOR as basic format, as that gives a standard/default option for encryption for people that don't have a specific opinion on how they'd want to do it otherwise. ",
          "createdAt": "2021-03-31T14:13:30Z",
          "updatedAt": "2021-03-31T14:13:30Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Ok. Well, see the other issue on my feelings about a complicated format. :) Keep it simple, IMO.",
          "createdAt": "2021-03-31T14:20:40Z",
          "updatedAt": "2021-03-31T14:20:40Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was discussed again at IETF 113. \r\n\r\nSome of the main notes from queue comments:\r\n\r\n```\r\nBrian Trammell:\r\n\tLet's talk about sec and privacy stuff offline \r\n\tWe semi-tackled it in IPFIX and TCPM wg's \r\n\t\r\nEric Kinnear \r\n\tI advocate for per-field indicators in addition to whatever general guidance we're going to give \r\n\tWe internally found that it's extremely helpful to have local indication of concerns to make sure implementers understand it in-context while looking at qlog \r\n\t\r\nJana Iyengar:\r\n\tAgree with Eric. Per-field indicators are useful.\r\n\tCaution against going too deep in that rabbit hole though. \r\n        Lots of local semantics attached to what data means and what\r\n\tvalue in indicating levels of sensitivity. \r\n        Because you don't have global view of how these traces are being used,\r\n\te.g., in tandem with other logs that are also existing.\r\n\tThere should be considerations and not rules. \r\n\tPer-field indicators are useful, but don't loose yourself in there \r\n```\r\n\r\n@britram is willing to help out on this one.\r\n\r\nHe suggested looking at [RFC 6235](https://www.rfc-editor.org/rfc/rfc6235.html), noting that \"it's primarily digging into how to anonymize fields (using state-of-the-art anonymization of identifers circa 2008) as opposed to the sensitivity of the data itself (it primarily concerns itself with flow-level data, which is a tiny subset of the sensitivity of per-field information in qlog\".\r\n\r\nIf we go with per-field indicators, I myself primarily have the question if we just indicate the \"sensitivity level\" of the field (e.g., IPs are dangerous) or ALSO how to best encode the field (this is how you should encode/hash IPs at various levels of anonymization). \r\n",
          "createdAt": "2022-03-22T11:39:11Z",
          "updatedAt": "2022-03-22T11:39:11Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This topic is important and needs the right level of sensitive treatment. But my 2c are that we shouldn't try to boil the ocean on the first pass. \r\n\r\nPropose we add some well considered text in the short term and ask for an early review from the relevant areas while we work on other design issues in parallel.",
          "createdAt": "2022-09-08T01:23:04Z",
          "updatedAt": "2022-09-08T01:23:04Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed with @LPardue here.\r\n\r\nAlso had a meeting with @britram about this a few weeks ago, who similarly proposes to keep the text in the qlog docs relatively short with high-level guidance (e.g., not tagging sensitive fields per event). \r\n\r\nHe additionally proposes to start a parallel project for (a) new document(s) that discuss in a more general scope how to deal with sensitive information in all types of logs (since we lack such guidance at the IETF atm). If this effort is at least started by last call for qlog, it would help to have something to point to if people worry about a lack of in-depth guidance here.\r\n\r\nWill add some basic text here ASAP, ready for internal review soon, and then have something to bring to the wg for initial review by IETF 115. ",
          "createdAt": "2022-09-29T14:16:48Z",
          "updatedAt": "2022-09-29T14:16:48Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Closing as completed",
          "createdAt": "2023-11-08T10:18:36Z",
          "updatedAt": "2023-11-08T10:18:36Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "MDU6SXNzdWU4NDYyMjQwNzA=",
      "title": "Change data definition format",
      "url": "https://github.com/quicwg/qlog/issues/143",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "editorial",
        "current-version"
      ],
      "body": "We currently use a custom DDL inspired by TypeScript to specify events.\r\nThis should probably be changed to a format already defined by the IETF. This would also potentially remove the need to specify a custom JSON mapping.\r\n\r\nCurrently, YANG and especially CDDL seem to be the most attractive options for this purpose. \r\n\r\nExisting discussion was mainly in https://mailarchive.ietf.org/arch/msg/quic/H_inwB1oLh4fr1-i7JyUb-8U5Gg",
      "createdAt": "2021-03-31T08:55:23Z",
      "updatedAt": "2022-03-20T16:17:57Z",
      "closedAt": "2022-03-20T16:17:57Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I have the following comments on format:\r\n\r\n1. If it's not binary (or extremely efficient to generate and process even at extremely large scale) then I can't use it at run time. The best I can do is support a post processor to convert to qlog later. The tools will likely have problem with large files as well.\r\n2. IMO, it **must** be simple to write a custom converter to the format. Please no super complicated protocols just around format. If I have to include an external library just to deal with the file format, then it's likely it won't be supported.",
          "createdAt": "2021-03-31T14:13:39Z",
          "updatedAt": "2021-03-31T14:13:39Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To clarify, there are two types of formats we need to consider: \r\n1. The data definition format: how we define events and member data types in the drafts (that's what this issue is intended to be about)\r\n2. The serialization format(s): what a qlog file actually looks like in string/binary form (I realized we no longer had an issue to discuss that, so I've made https://github.com/quiclog/internet-drafts/issues/144)\r\n\r\nI think your comments mainly reflect on the 2nd point, though they are of course somewhat tied: for example, CDDL makes it easy to express JSON and CBOR, but potentially more difficult to define other (binary) serialization formats. ",
          "createdAt": "2021-03-31T14:23:39Z",
          "updatedAt": "2021-03-31T14:23:39Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We switched to CDDL in main-schema-02 and h3/quic-events-01. ",
          "createdAt": "2022-03-20T16:17:57Z",
          "updatedAt": "2022-03-20T16:17:57Z"
        }
      ]
    },
    {
      "number": 144,
      "id": "MDU6SXNzdWU4NDY3NjI1MTU=",
      "title": "Revisit serialization format decision",
      "url": "https://github.com/quicwg/qlog/issues/144",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In draft-02, we decided to keep using JSON as the main serialization format, with NDJSON as a streaming option. We did update the data definition language used in the draft to make it easier to define custom serializations into e.g., binary formats, if others want a more performant option. \r\n\r\nIt might be needed to revisit this decision and to still go for a binary format by default. CBOR has so far been named most as a potential option, as it's an IETF standard (as opposed to e.g., protocol buffers or flatbuffers and similar) and has proved itself for other protocol-related use cases as well. \r\n\r\nThe question remains: do we consciously limit ourselves to a select few serialization formats? and even if we don't, which \"default\" formats do we commit to in the texts? \r\n\r\nSeveral people are of the opinion it's enough to stick with for example JSON as the main format in the qlog specification and to have people write converters from/to JSON for more performant options themselves. This because even with something like CBOR, not all applications will want to employ that directly, and converters would still be needed.",
      "createdAt": "2021-03-31T14:22:01Z",
      "updatedAt": "2021-08-18T13:35:17Z",
      "closedAt": "2021-08-18T13:35:16Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another simple way of viewing this (and one of the main questions I feel we need to answer ASAP post-adoption), is what the main goal of qlog is:\r\n\r\n1) Define a logging format that makes it easy for **protocol implementations** to log data (efficiently, at scale)\r\n2) Define a logging format that makes it easy to create **reusable tooling** \r\n\r\n(I think it was @nibanks who put it like this, but for the life of me, I can't find the source). \r\n\r\nIf 1), we probably need to go full binary and optimize for write speed/size. 2) is imo what we have now, with a relatively verbose JSON setup. If we want to go for both at the same time (which I'm not sure is possible, might lead to \"worst of both worlds\") we'd probably end up with something like CBOR. \r\n\r\nIn my personal experience, it's the tooling part that's difficult and something that most parties don't want to invest in themselves/don't have the necessary expertise for in the networking/protocol teams. Making tooling easier (e.g., even using things like `jq` or simple python) and more reusable seems like it should stay the main goal. While the current qvis toolsuite doesn't deal well with larger qlog files, that's mainly because it's web-based, not because JSON can't scale to hundreds of MBs or even Gigabytes in a native tool. Of course, that's just my opinion :) ",
          "createdAt": "2021-04-07T15:20:32Z",
          "updatedAt": "2021-04-07T15:20:32Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I think we can create translation libraries/tools easily enough between formats. The question then becomes what do you want to do?\r\n\r\na) **Optimize for tools** - Standardize around a single format (JSON most likely?) that tools can easily use. QUIC implementations then have the choice to either write directly to that format, or have a custom format, and a custom post processing tool to convert to the tool format.\r\n\r\nb) **Optimize for implementations** - Standardize around a binary format (and helper library(s)?) for QUIC implementations to efficiently write to. Tools can either read from that format or perhaps someone could write a helper library to convert to some more easily consumed format. While I like the idea of trying to optimize for implementations, I wonder if it's just going to open a bigger can of worms. A lot of folks will have strong opinions here, and likely already have some solution they use for other performant logging anyways.\r\n\r\nThe more I think about it, I kind of lean towards a). Implementations can (and will) do what they want. If JSON is optimal enough for them (it seems it is for FB?) then they can use it. If they want something more/different, they can implement a translation layer/tool (what MsQuic partially has). And best of all, it makes the standardization process simpler.\r\n\r\nOne last thought though, is that while web-based solutions are currently the reason the tools are slow, I do expect JSON parsing to be significantly slower than a binary format, especially at GB file sizes. It'd be interesting to see a perf comparison. The best way I could think is to add qlog file format support to WPA, and update MsQuic's qlog translation layer. Then grab a large trace from MsQuic (binary ETW) and convert it to qlog. Then separately open the binary version and the qlog version and measure how long either takes.",
          "createdAt": "2021-04-07T15:42:06Z",
          "updatedAt": "2021-04-07T15:42:06Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One other option to consider is the use of / overlap with the PCAP-NG format typically used for packet captures. \r\n\r\nThis is apparently being considered for adoption on opsawg and might be flexible enough to include the endpoint-specific data we want to add to the mix. \r\n\r\nI still need time to analyze what PCAP-NG actually does, but initial discussion on this was on the mailing list at: https://mailarchive.ietf.org/arch/msg/qlog/2bSRgRdaRleLhTDFv_C4DYZ3zng/\r\n\r\nOne benefit of this would be that we can easily log raw (encrypted) packets along with endpoint data as in normal .pcaps (though I'm not sure how useful that is). A downside is that the format is (AFAIK) barely supported outside of tools like wireshark (e.g., no easy mature open source parsers available, though I could be completely wrong on that count). ",
          "createdAt": "2021-05-19T11:45:02Z",
          "updatedAt": "2021-05-19T11:45:02Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "NONE",
          "body": "It might not be the encrypted packets you are logging, it might be the DNS requests (whether encrypted or not), or even the ICMP packet too big, or the ICMP port unreachables.",
          "createdAt": "2021-05-21T18:24:24Z",
          "updatedAt": "2021-05-21T18:24:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "As in implementer, why would I modify my endpoint to take a packet capture when e.g. tcpdump can already do that?",
          "createdAt": "2021-07-13T15:44:39Z",
          "updatedAt": "2021-07-13T15:44:39Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "NONE",
          "body": "> As in implementer, why would I modify my endpoint to take a packet capture when e.g. tcpdump can already do that?\r\n\r\nBecause tcpdump can't capture (a) the cleartext packets inside the QUIC/TLS, (b) your state transitions.\r\nThe reason you might want it all in pcap-ng format is so that that you can combine an external view of the packets (including DNS requests, ICMPs, and TCP activities) with your internal capture.  \r\nYou'd do a zipper merge on the data so that you can see that your internal state transition followed a failed DNS request, or something like that.\r\n",
          "createdAt": "2021-07-13T16:29:46Z",
          "updatedAt": "2021-07-13T16:29:46Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "In my experience, my QUIC client application fails to resolve a name, I don't even make a UDP socket or QUIC connection object. My client stderr log throws an error message, possibly reporting the error returned by my resolution syscall.\r\n\r\nCombining with wire packet captures seems to have marginal value when those packets don't contain more information than is available to the client.",
          "createdAt": "2021-07-13T16:52:58Z",
          "updatedAt": "2021-07-13T16:52:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Discussed during IETF 111. The feeling in the room was to stick with JSON serialization as the canonical interop format for qlog. Use of JSON does not prevent other serialization formats but we can constrain our scope of work to focus on one in this set of deliverables.",
          "createdAt": "2021-08-02T13:11:21Z",
          "updatedAt": "2021-08-02T13:11:21Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "For clarification, the present specifics of the document's JSON serialization definitions are a starting point for further development should the WG declare consensus on using JSON.\r\n\r\nThe discussion about streaming serialization (whether NDJSON or some other format) is separate, so I've created #172 .",
          "createdAt": "2021-08-02T17:50:46Z",
          "updatedAt": "2021-08-02T17:50:46Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given the consensus, I am closing this issue. The main related subissues are tracked in #172 and #143 going forward. ",
          "createdAt": "2021-08-18T13:35:16Z",
          "updatedAt": "2021-08-18T13:35:16Z"
        }
      ]
    },
    {
      "number": 146,
      "id": "MDU6SXNzdWU4NDkyNjQ4ODk=",
      "title": "Make protocol_type more well defined",
      "url": "https://github.com/quicwg/qlog/issues/146",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "high-level-schema",
        "current-version",
        "discuss"
      ],
      "body": "Currently, `protocol_type` is a single string which typically has the value \"QUIC_HTTP3\". \r\n\r\nHowever, this doesn't particularly scale to aggregated logs down the line (e.g., in #139 we can have a plethora of different protocols represented), and it isn't clear how to define new strings for new protocol types (e.g., is it TCP_HTTP2 or TCP_TLS_HTTP2 and in that case, why isn't it QUIC_TLS_HTTP3? etc.)\r\n\r\nOne direct solution might be to make the field an array of individual values (i.e., `protocol_type = [\"QUIC\", \"HTTP3\"]`), but that potentially adds additional overhead if the field is logged for each event individually. \r\n\r\nAnother option would be to prefix event names with the protocol (e.g., `transport:packet_sent` becomes `quic:transport:packet_sent`) but that reduces the future potential to re-use events across protocols (not a big deal for QUIC vs TCP probably, but higher level logic events (say, `recovery:metrics_updated`) could suffer). \r\n\r\nThis is somewhat tied to #85, as some events will be implicitly tied to a particular protocol anyway. ",
      "createdAt": "2021-04-02T14:55:11Z",
      "updatedAt": "2023-12-09T21:19:31Z",
      "closedAt": "2023-12-09T21:19:31Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Personally, I think events **should** be tied to protocol, and \"sharing\" them should not be a goal. IMO that's going to make things harder and more confusing to interpret, especially if you end up having both protocols in the same log. For Windows, we regularly use well-defined events and they are always specific to a particular component. Even if things might look similar now, that doesn't mean they would stay that way in the future. Forcing things to be the same would then limit the development of the one that wants to evolve.",
          "createdAt": "2021-04-02T15:08:20Z",
          "updatedAt": "2021-04-02T15:08:20Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "And one more data point for you, we generally follow a pattern for events to be named something along the line of <Component/Protocol><Object/Qualifier><Action>, such as `QuicConnVersionSet` and `QuicStreamCreated`. It allows for events to be globally unique and descriptive enough that you don't need too much follow up to explain what it is doing.",
          "createdAt": "2021-04-02T15:13:31Z",
          "updatedAt": "2021-04-02T15:13:31Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This also has a potential impact on how we define the high-level `name` field vs the separate `category` and `event/type` fields, as tracked in #150 and #153. ",
          "createdAt": "2021-08-18T13:41:30Z",
          "updatedAt": "2021-08-18T13:45:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "We changed the spec so now `protocol_type` is an array.\r\n\r\n```\r\n? protocol_type: ProtocolType\r\n```\r\n\r\nand \r\n\r\n```\r\nProtocolType = [+ text]\r\n```\r\n\r\nWe also currently prefix category to event names.\r\n\r\nI'd say the OP issue was resolved and we should close this. \r\n\r\nWhether we should keep `protocol_type` at all is a different question, and we should open a new issue ",
          "createdAt": "2023-01-17T18:35:54Z",
          "updatedAt": "2023-01-17T18:35:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Closing this as done per my previous comment.",
          "createdAt": "2023-12-09T21:19:31Z",
          "updatedAt": "2023-12-09T21:19:31Z"
        }
      ]
    },
    {
      "number": 147,
      "id": "MDU6SXNzdWU4NTE0MjkyNjE=",
      "title": "How to log handshake cancelations?",
      "url": "https://github.com/quicwg/qlog/issues/147",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "design",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "I didn't think of this back when we defined the triggers for `connection_closed`, but this is happening **a lot** in production: When dialing a new peer, libp2p races connections to that peer on all advertised addresses and transports, and uses whichever connection returns first. All the other connection attempts are canceled.\r\n\r\nIt would be nice if there was a trigger \"the user aborted this connection attempt before handshake completion\".",
      "createdAt": "2021-04-06T13:32:43Z",
      "updatedAt": "2025-03-13T14:07:13Z",
      "closedAt": "2025-03-13T14:07:13Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good point!\r\n\r\nDo you think a generic `aborted` trigger is enough, or would it make sense to go with something more fine-grained like `aborted_racing` (potentially having an `aborted` generic as well?)?\r\n\r\nWould it be useful to have a way to indicate to which other connection (6-tuple?) this one \"lost\" in the race (and by how much etc.)? Would that need a separate event or should that be included in the `connection_closed`? I'd tend towards a separate event for that one myself. ",
          "createdAt": "2021-04-07T07:50:37Z",
          "updatedAt": "2021-04-07T07:50:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "+1, sounds useful ",
          "createdAt": "2022-09-08T01:24:30Z",
          "updatedAt": "2022-09-08T01:24:30Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, I'm still of the opinion that a trigger `aborted` or `lost_race` on `connection_closed` is sufficient here. \r\n\r\nWrt to logging the \"other\" connection, a `connection_started` event can be used for the winning connection (also supports indicating they were other protocols like TCP). \r\n\r\nSo for example, at the client, you might have 2 `connection_started` events (1 for TCP ipv4 and 1 for QUIC ipv4) and then 1 `connection_closed` with trigger `aborted` or `lost_race` for either of these to indicate the other was chosen implicitly. Alternatively, you could log 1 `connection_started` for the one that won, and 1 `connection_closed` for the loser (though I'd prefer the other option ;)).\r\n\r\nLet me know what you think @marten-seemann @LPardue. With no further feedback, I'll add both the `aborted` and `lost_race` triggers to `connection_closed` with a PR and call it a day. ",
          "createdAt": "2024-03-04T14:51:49Z",
          "updatedAt": "2024-03-04T14:51:49Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the `aborted` trigger is fine. I'm not sure if we need a `lost_race` trigger at all.\r\n\r\nHow would an application log more details though? I could image that an application might want to add some more details, like \"lost the race to connection XXX\", but I don't think that's something that we need to standardize.",
          "createdAt": "2024-10-21T09:21:16Z",
          "updatedAt": "2024-10-21T09:21:16Z"
        }
      ]
    },
    {
      "number": 148,
      "id": "MDU6SXNzdWU4NTI2NjAzMzg=",
      "title": "Format text to a certain width and avoid inline comments",
      "url": "https://github.com/quicwg/qlog/issues/148",
      "state": "CLOSED",
      "author": "toidiu",
      "authorAssociation": "NONE",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "editorial",
        "current-version"
      ],
      "body": "Inline comments force the reader to scroll sideways and makes it more difficult to read.\r\n\r\nAdditionally while this is possibly fine for html, the rendering in pdf is much worse since scrolling is not supported.\r\n\r\n**html example**: https://quiclog.github.io/internet-drafts/draft-marx-qlog-event-definitions-quic-h3.html#section-a.1\r\n\r\n **pdf example**:\r\n![pdf_rendering](https://user-images.githubusercontent.com/4350690/113912463-00d55d80-9790-11eb-9c05-e5abfea0b81e.png)\r\n",
      "createdAt": "2021-04-07T17:58:36Z",
      "updatedAt": "2022-03-20T16:17:15Z",
      "closedAt": "2022-03-20T16:17:15Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hello @toidiu,\r\n\r\nThank you for this very valid comment. \r\nWe will take this into account when re-formatting the qlog documents after adoption by the QUIC wg. \r\n\r\nI hope it doesn't cause too much of an inconvenience in the mean time? ",
          "createdAt": "2021-04-08T13:28:31Z",
          "updatedAt": "2021-04-08T13:28:31Z"
        },
        {
          "author": "toidiu",
          "authorAssociation": "NONE",
          "body": "Great thanks for the reply and all your work. I can use the html version of the draft in the meanwhile. ",
          "createdAt": "2021-04-08T16:41:48Z",
          "updatedAt": "2021-04-08T16:41:48Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should be fixed in main-schema-02 and h3/quic-events-01 now. \r\n\r\nWe've taken pains to prevent too-long inline comments in code blocks (max 72 characters per line) and to put comments above instead of behind fields. \r\n\r\nFeel free to take a look at the new drafts (e.g., https://www.ietf.org/archive/id/draft-ietf-quic-qlog-h3-events-01.html and https://www.ietf.org/archive/id/draft-ietf-quic-qlog-quic-events-01.html) and let us know if this is still not ideal @toidiu. \r\n\r\nClosing this issue for now, but feel free to re-open/comment if you find further problems.",
          "createdAt": "2022-03-20T16:17:15Z",
          "updatedAt": "2022-03-20T16:17:15Z"
        }
      ]
    },
    {
      "number": 149,
      "id": "MDU6SXNzdWU4NTgyNjM2NjE=",
      "title": "[draft 02] Fix JSON serialization example under the Field name semantics section",
      "url": "https://github.com/quicwg/qlog/issues/149",
      "state": "CLOSED",
      "author": "JorisHerbots",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "**Problem**\r\nThe section about \"Field name semantics\" in draft 02 contains the following example:\r\n```\r\nJSON serialization:\r\n\r\n{\r\n    time: 1553986553572,\r\n\r\n    name: \"transport:packet_sent\",\r\n    event: \"packet_sent\",\r\n    data: { ... }\r\n\r\n    protocol_type:  \"QUIC_HTTP3\",\r\n    group_id: \"127ecc830d98f9d54a42c4f0842aa87e181a\",\r\n\r\n    time_format: \"absolute\",\r\n\r\n    ODCID: \"127ecc830d98f9d54a42c4f0842aa87e181a\", // QUIC specific\r\n}\r\n```\r\nThe QLOG specification lists the use of `category` and `type` fields or their concatenation under the `name` field. The above example, however, seems to hint that there also exists an `event` field. \r\n\r\n**Suggested fix**\r\n ```\r\nJSON serialization:\r\n\r\n{\r\n    time: 1553986553572,\r\n\r\n    name: \"transport:packet_sent\",\r\n    data: { ... }\r\n\r\n    protocol_type:  \"QUIC_HTTP3\",\r\n    group_id: \"127ecc830d98f9d54a42c4f0842aa87e181a\",\r\n\r\n    time_format: \"absolute\",\r\n\r\n    ODCID: \"127ecc830d98f9d54a42c4f0842aa87e181a\", // QUIC specific\r\n}\r\n```\r\nOr\r\n\r\n ```\r\nJSON serialization:\r\n\r\n{\r\n    time: 1553986553572,\r\n\r\n    category: \"transport\",\r\n    type: \"packet_sent\",\r\n    data: { ... }\r\n\r\n    protocol_type:  \"QUIC_HTTP3\",\r\n    group_id: \"127ecc830d98f9d54a42c4f0842aa87e181a\",\r\n\r\n    time_format: \"absolute\",\r\n\r\n    ODCID: \"127ecc830d98f9d54a42c4f0842aa87e181a\", // QUIC specific\r\n}\r\n```",
      "createdAt": "2021-04-14T21:05:37Z",
      "updatedAt": "2021-04-15T09:28:33Z",
      "closedAt": "2021-04-15T09:28:33Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for noticing this. The correct fix is the first (the omission of the `event` field). I will open a PR for that. ",
          "createdAt": "2021-04-15T08:18:26Z",
          "updatedAt": "2021-04-15T08:18:26Z"
        }
      ]
    },
    {
      "number": 150,
      "id": "MDU6SXNzdWU4NTgyNzI5OTA=",
      "title": "[draft 02] \"events\" field minimum requirements",
      "url": "https://github.com/quicwg/qlog/issues/150",
      "state": "CLOSED",
      "author": "JorisHerbots",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "design",
        "high-level-schema",
        "current-version",
        "discuss"
      ],
      "body": "**Issue**\r\nThe specification mentions the following under the \"Field name semantics\" section (ID: field-name-semantics): \r\n\r\n> Each qlog event at minimum requires the \"time\" ({{time-based-fields}}), \"name\" ({{name-field}}) and \"data\" ({{data-field}}) fields.\r\n\r\nAccording to the section \"category and event\" (ID: name-field), `name` is the concatenation of the `category` and `type` fields. This should be reflected in the line above.\r\n\r\n**Suggestion**\r\n> Each qlog event at minimum requires the \"time\" ({{time-based-fields}}), \"name\" (or \"category\" and \"type\") ({{name-field}}) and \"data\" ({{data-field}}) fields.",
      "createdAt": "2021-04-14T21:20:23Z",
      "updatedAt": "2021-08-18T13:46:37Z",
      "closedAt": "2021-08-18T13:46:37Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So this is a bit of a difficult one... As explained in section `name-field`, category+type were used in qlog draft 01 but in 02 it's preferred to use the concatenated version: `As such, the default approach in qlog is to concatenate both field values`\r\n\r\nIt's highly uncertain at this point how/if these fields will continue to exist in this form (see also #146, which means we might go to quic:packet_sent instead of transport:packet_sent in time for example).\r\n\r\nSo for now, I'd like to keep the text as-is (encourage concatenated form). \r\n\r\nNote: qvis -should- still support both category + event for draft02 for easier backwards compat though. If that's not the case, then that should be fixed. ",
          "createdAt": "2021-04-15T08:29:17Z",
          "updatedAt": "2021-04-15T08:29:17Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Duplicate of #153, closing in favor of that. ",
          "createdAt": "2021-08-18T13:46:37Z",
          "updatedAt": "2021-08-18T13:46:37Z"
        }
      ]
    },
    {
      "number": 152,
      "id": "MDU6SXNzdWU4NTg5ODYxNTc=",
      "title": "Add ability to log CPU/threading info",
      "url": "https://github.com/quicwg/qlog/issues/152",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "design",
        "high-level-schema",
        "current-version"
      ],
      "body": "In msquic, events all contain the current CPU ID, Process ID and Thread ID (https://github.com/microsoft/msquic/blob/main/src/plugins/wpa/DataModel/QuicEvent.cs), which allows them to do advanced debugging of threading and CPU allocation issues (https://github.com/microsoft/msquic/blob/main/docs/TSG.md#diagnosing-rss-issues).\r\n\r\nIt would potentially be interesting to have this type of metadata well-defined in qlog as well.\r\n\r\nCC @nibanks",
      "createdAt": "2021-04-15T15:15:55Z",
      "updatedAt": "2023-07-05T18:11:23Z",
      "closedAt": "2023-07-05T18:11:23Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Here's an example scenario where having CPU information per event is key to diagnosing issues: https://github.com/microsoft/msquic/blob/main/docs/TSG.md#diagnosing-rss-issues",
          "createdAt": "2021-04-15T15:33:24Z",
          "updatedAt": "2021-04-15T15:33:24Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At this point, given that we are currently trying to end up with as few \"standard\" qlog events as possible, I wonder if it would make sense to keep this in.\r\n\r\nIt's always possible to add custom fields to indicate this information if needed for a given implementation. Additionally, I'm wondering if it would make sense to log this for each event in qlog instead of have separate events when a connection moves to a new CPU (as we already do that type of logic for other things, like we don't log spinbit in each packet_header but rather have a separate `spin_bit_updated` event). \r\n\r\nSpecifically: I propose not doing this in qlog proper at this time. ",
          "createdAt": "2021-08-18T13:44:42Z",
          "updatedAt": "2021-08-18T13:44:42Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "If this was supported, it would have to be per-event. When you have multiple threads firing off events in parallel, any/every thread may be generating an event at any time, even for the same connection. For instance:\r\n\r\nThread A: Queues a send on connection X, stream Y.\r\nThread B: Queues a send on connection X, stream Z.\r\nThread C: Processes connection X (sending and receiving data for streams Y & Z).\r\n\r\nOne thing to note, WPA **requires** thread and cpu/processor to be supplied for every event.\r\n\r\nAlso, as far as deciding if this is necessary, per-thread/processor scheduling is personally one of the main reasons I need tools for processing logs, and not just look at the raw text. I would find it very surprising if other server deployments don't also have similar experiences.\r\n\r\nPersonally, I'd prefer to at least define this in the spec, but possibly make it optional. If we want tools to be able to generically consume these fields, they can't be custom.",
          "createdAt": "2021-08-18T13:54:07Z",
          "updatedAt": "2021-08-18T13:54:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The qlog direction to log wire events is fine for me. \r\n\r\nBut it seems @nibanks is really discussing the kind of foundation event meta-data that might get logged, and why it is useful. I tend to agree. \r\n\r\nThere's a benefit to considering this information in qlog, we can provide guidance about the data fields as part of security and privacy analysis. For instance, low-level information is useful for local developer analysis but might be too sensitive to share by default.\r\n\r\nWhat would a common platform-independent schema for CPU/thread look like? Is there anything qlog can borrow from?",
          "createdAt": "2021-08-18T14:07:00Z",
          "updatedAt": "2021-08-18T14:07:00Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "FYI, [here](https://github.com/microsoft/msquic/blob/main/src/plugins/trace/dll/DataModel/QuicEvent.cs#L187) is the base (C#) object for events in the WPA event processing code. Generically, every event has at least an ID, timestamp, processor, thread ID, process ID and event-specific payload.",
          "createdAt": "2021-08-18T14:12:36Z",
          "updatedAt": "2021-08-18T14:12:36Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": " It really does seem like endpoint-local data just like the timestamp. I can see cases where all of those could be useful, so optional fields sounds fine to me.\r\n\r\nIf all the info is needed to make sense, I might be tempted to define it as a single tuple rather than individual fields e.g. `hw_info: {processor_id: uint32, process_id: uint32, thread_id: uint32}`\r\n",
          "createdAt": "2021-08-18T14:29:49Z",
          "updatedAt": "2021-08-18T14:29:49Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "@LPardue that works for me.",
          "createdAt": "2021-08-18T15:56:27Z",
          "updatedAt": "2021-08-18T15:56:27Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I can now better grasp the benefits of doing this within the context of qlog, so thanks for the additional discussion.\r\n\r\nWe can bikeshed the exact form this should take. I for example would suggest not putting this as a property of the `data` field (part of the payload) but rather as a top-level field (at the same level as timestamp, name and data itself). \r\n\r\nThis would be something defined in the main schema document, as it's usable across protocols. \r\n\r\nAssigning to @lnicco so he can get his hands dirty with adding something new :) \r\n",
          "createdAt": "2021-08-19T07:24:23Z",
          "updatedAt": "2021-08-19T07:24:23Z"
        }
      ]
    },
    {
      "number": 153,
      "id": "MDU6SXNzdWU4NjM2MDE2OTk=",
      "title": "Revisit category/type/name setup",
      "url": "https://github.com/quicwg/qlog/issues/153",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "high-level-schema",
        "current-version",
        "discuss"
      ],
      "body": "Prior to draft-02, we had separate category and type fields. The idea was that this would be easier to filter on (e.g., show me only events in the `transport` category). I'm still not sure people actually use it this way. \r\n\r\nWith the move to normal JSON in -02, I introduced the `name` field, which concatenates to `category:type`. The motivation for that was mainly reducing JSON overhead by not having to repeat `\"category\"` and `\"type\"` strings for each event. \r\n\r\nNow, we have the discussion around `protocol_type` in #85, indicating it might make more sense to tie events more closely to protocols and not have generic/high-level categories (instead of `transport:packet_sent` and a separate `protocol_type` of QUIC, we would for example have `quic_packet_sent` and `tcp_packet_sent`). \r\n\r\nI guess the main question is if there's value in splitting up events in type + category for high-level filtering, or if that's not necessary in practice. From my experience in qvis, it isn't all that useful, since filtering on category still requires looping over all events (and keeping things in lookup maps is also possible without explicit qlog-level categories).",
      "createdAt": "2021-04-21T08:44:56Z",
      "updatedAt": "2023-07-05T00:43:29Z",
      "closedAt": "2023-07-05T00:43:29Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The utility of importance, type, category (and potentialy privacy-level), is for me being able to configure my logging application. In some cases I need full details for debugging and I can control the environment to ensure there are no privacy concerns. That utility doesn't necessarily need to be reflected into the serialized logs. As a qlog logging library maintainer, I quite like the idea of providing people with the means to configure different logging instances. What would help is for the qlog spec to set the expectations of what events appear in a log for any type of configuration. For uncoordinated logs, putting this detail into the log itself would be useful for the same reason - it can help avoid false positives (e.g. not seeing any data_moved events in a log could be an application failing to read/write data into streams, or it could be a concious choice by an endpoint to *not* log those events.).\r\n\r\nHaving gone through a round of trying to shift to qlog-02, one observation I made is that the way I structured the object model gave me unique events. From those, I could always \"reflect\" the importance, category or type in the serializing code. Importance is very interesting here, it's an invariant property of the event that *is not* sent on the wire. Therefore, I would expect that such reflection is possible in deserializing code too. I think that's what you mean by \"keeping things in lookup maps is also possible without explicit qlog-level categories\".\r\n\r\nAnother way to write your question is,  how important is it to define a logging format that can be acted on by general purpose tools? Tools such as jq can't natively know a qlog event's importance, but if the log included the value, writing queries would be easy. A post-processing step, using a qlog-aware tool, could insert an importance fields, that could be used by other tools. That's a transformation that is easily reversible, and qlog-aware tools should handle unknown fields (so it's a non-destructive transformation).\r\n\r\nquic_packet_sent and tcp_packet_sent will always exist in a category of transport, whether qlog defines it or not. \r\n",
          "createdAt": "2021-07-20T18:11:58Z",
          "updatedAt": "2021-07-20T18:11:58Z"
        },
        {
          "author": "jlaine",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My two cents here would: \"just go with `name`\", as it's unusual to have to key off two fields to know how to interpret an event (think for instance of the JS `Event`).\r\n\r\nI could also live with separate category / type, but what I'd really NOT like is to have an ambiguous spec with two different ways of identifying events.",
          "createdAt": "2021-07-23T10:09:38Z",
          "updatedAt": "2021-07-23T10:09:38Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Based on continued experience, I would just stick with `name`. If we want to define events with different names for different protocols, that fine, but its a tangential question. \r\n\r\nAbsent anyone else supporting the idea of split category and type, I'd close this ticket.",
          "createdAt": "2023-01-17T18:29:29Z",
          "updatedAt": "2023-01-17T18:29:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Hearing no other input, closing this issue.",
          "createdAt": "2023-07-05T00:43:28Z",
          "updatedAt": "2023-07-05T00:43:28Z"
        }
      ]
    },
    {
      "number": 154,
      "id": "MDU6SXNzdWU4NjUzOTY0Njg=",
      "title": "the frames_processed fails to capture received and sent frames",
      "url": "https://github.com/quicwg/qlog/issues/154",
      "state": "CLOSED",
      "author": "toidiu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "design",
        "quic-http3-fields",
        "future-versions"
      ],
      "body": "The [`frames_processed`](https://tools.ietf.org/html/draft-marx-qlog-event-definitions-quic-h3-02#section-5.3.14) event fails to capture the sending and receiving of frames since it only specified a single `packet_number` field.\r\n\r\nAccording to the [transport rfc](https://tools.ietf.org/html/draft-ietf-quic-transport-32#section-12.3):\r\n>  Each endpoint maintains a separate packet number for sending and receiving.\r\n\r\nI feel mirroring the packet events would be consistent and result in two events: `frames_sent` and `frames_received` which will be easier to match on.",
      "createdAt": "2021-04-22T19:31:20Z",
      "updatedAt": "2022-09-08T01:31:25Z",
      "closedAt": "2022-09-08T01:31:25Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So the idea is that send/receive semantics for frames are done in the `packet_sent` and `packet_received` events. These not only log e.g., the packet header, but also the frames and their contents. \r\n\r\nThe `frames_processed` event is an additional one to be used to signify exactly that: when the frames are -processed- (as this does not necessarily happen directly after/before send/receive). This is mostly in the cases where a) the processing code is decoupled heavily from the send/recv code or b) you don't want to log full packets, but are mainly interested in e.g., how stream frames are handled. The `packet_number` is just to have -a- way of correlating this info to the packet carrying the frames for later cross-reference, but not intended to replace the `packet_sent` and `packet_received` events (which log the packet numbers as well of course).\r\n\r\nIf you would only want to log the frames (e.g., have pure `frames_sent` and `frames_received`), you could just use `packet_sent` and `packet_received` and omit packet-level information from these instead. \r\n\r\nFrom your issue, I assume this wasn't clear when reading the draft and that we should clarify it. However, I feel like the setup works as you desire/describe, so I don't think there's a design issue. If you disagree, please let us know.\r\n\r\n(note: it's likely that the `frames_processed` event will be replaced with a number of more specific events like `acks_processed`, see #85)",
          "createdAt": "2021-04-23T07:53:24Z",
          "updatedAt": "2021-04-23T07:54:17Z"
        },
        {
          "author": "toidiu",
          "authorAssociation": "NONE",
          "body": "Thanks for the explanation. The intention of frame_processed makes sense but there is text that added to my confusion. There might still be a good usecase for frame_sent/recv event and I listed the pros/cons for that.\r\n\r\n> Note: in some implementations, it can be difficult to log frames\r\n   directly, even when using packet_sent and packet_received events.\r\n   For these cases, this event also contains the direct packet_number\r\n   field, which can be used to more explicitly link this event to the\r\n   packet_sent/received events.\r\n\r\n**note and packet_number confusion**\r\nThe quote from the draft specifically calls out sending and receiving and how the packet_number can be used to link the event to the packet event.\r\n\r\nIf this event is meant for processing of received events, as you described, then it might be good to call that out explicitly and remove the packet_sent part.\r\n \r\n**difficulty in logging frames in packet event**\r\nThe quote describes our use case pretty well (difficult to log frames directly, even when using packet_sent and packet_received events). So we plan to emit the packet event with sparse info and another event which captures the frame info. Given that I see two options:\r\n\r\n- using packet_sent/recv\r\n  - pros: this will allow us to reuse the event.\r\n  - cons: low granularity of the logs. There is more data in a frame_event vs a packet_event. Customers only wishing to consume packet_events will need to do their own parsing or opt into both events; this can be noisy/cumbersome. \r\n- adding and using new frame_sent/recv\r\n  - pros: this will allow users to easily consume packet_events vs frame_event.\r\n  - cons: more events and possibly duplication.\r\n",
          "createdAt": "2021-04-23T19:07:25Z",
          "updatedAt": "2021-04-23T19:14:34Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for the additional information. I now understand the root of your issue (I think) and agree that there's a semantic mismatch (at minimum in the use of the verb \"processed\" vs parsed/created).\r\n\r\nI also understand the arguments for separate frame_* events, but I'm unsure if it's still possible to make such a change. The packet_* events are at the core of qlog and implemented by all stacks that do qlog (that I know of). All the tooling also utilizes this. Splitting this up by default would mean lots of code churn (one of the reasons we added a separate `frames_processed` in the first place). \r\n\r\nAm I correct in understanding you have a concrete need for this split in your own stack (i.e., it's difficult to emit everything in `packet_sent/received` and you really _need_ separate events?) or this this mainly a theoretical exercise? In the first case, could you provide a few more details on how/why it works that way? Thanks!\r\n",
          "createdAt": "2021-04-26T09:37:30Z",
          "updatedAt": "2021-04-26T09:37:30Z"
        },
        {
          "author": "toidiu",
          "authorAssociation": "NONE",
          "body": "> All the tooling also utilizes this. Splitting this up by default would mean lots of code churn (one of the reasons we added a separate frames_processed in the first place).\r\n\r\nI wanted to make sure we were on the same page. I was suggesting that we keep the `frames` field in the packet_* events and introduce frame_* events. This might introduce duplication but also not break existing tooling.\r\n\r\nWe do have a need for this in our stack. Emitting the packet_* with the `frames` info would force us to have extra allocation; which we need to avoid in a networking library (QUIC). \r\n\r\n---\r\n\r\nIf its not possible to add frame_*:\r\n\r\nThe alternative is that we emit the `packet_*` with just the packet related info and then later on emit another `packet_*` with frames related info. However, I do wonder if qlog tools are flexible enough to expect this behavior and match the 'separated' packet events?\r\n\r\nThis still doesn't address easy filtering of packet vs frame events, so we would likely add a custom field to indicate and filter that easily.\r\n\r\n---\r\n\r\nAside:\r\nI am not familiar with the existing tooling and how easy/difficult they would be to update, but I wonder if there is a way to mark fields as deprecated so that new tools opt into the preferred usage (streamline and remove duplication).\r\n\r\nI also wonder if breaking tools might be acceptable since this is still in draft. But I am new here so defer the decision to you and others; also thats is a much larger conversation.",
          "createdAt": "2021-04-26T19:57:07Z",
          "updatedAt": "2021-04-26T19:59:07Z"
        },
        {
          "author": "toidiu",
          "authorAssociation": "NONE",
          "body": "Hi, wanted to make sure someone saw the above comment. \r\n\r\nWould be good to know which way the draft design will lean so that we can remain compatible.",
          "createdAt": "2021-05-03T18:50:27Z",
          "updatedAt": "2021-05-03T18:50:59Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey toidiu,\r\n\r\nThanks for following up. I did see your previous post, and thanks for confirming this is an issue in your stack.\r\n\r\nAt this point, we are preparing for adoption of the qlog drafts in the IETF QUIC working group, where one of the discussions to be had is indeed the amount and fine-grainedness of events. Your input will be useful then. However, at this time, I cannot guarantee new frame_* events will be added, nor that they won't... It's safe to say they won't be added anytime soon though. \r\n\r\nFor now, I'd say the best approach is to log two `packet_*` events then (as those should be easy to merge automatically by tooling). \r\n\r\nAt this point, there isn't all that much (public/open-source) tooling that I'm aware of. The biggest toolsuite is qvis (https://github.com/quiclog/qvis), which is incidentally also maintained by myself. I can say that currently logging separate `packet_*` events for the same packet (one with, one without frames) won't auto-merge the two in qvis (and I don't expect any other tooling to do this atm). Conceptually this is something I could add, but all that would do is choose either the first or the last and pretend that's the only event in there, loosing timing info (though maybe that's enough for what you need atm?). If that's a needed workaround for you at this time, let me know at https://github.com/quiclog/qvis/issues and I'll add that. \r\n\r\nIn general, I don't worry too much about breaking tooling at this point (since we're still in draft), but I'm not at all certain `frame_*` events will ever be added and re-writing tools to deal with them **properly** would be too much work at the moment (As a quick hack, I would support them by merging them with `packet_*` events, just as I would do when not using separate `frame_*` events).\r\n\r\nI hope that answers your questions. If not, feel free to let us know!  \r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-05-03T19:34:26Z",
          "updatedAt": "2021-05-03T19:34:26Z"
        },
        {
          "author": "toidiu",
          "authorAssociation": "NONE",
          "body": "> For now, I'd say the best approach is to log two packet_* events then (as those should be easy to merge automatically by tooling). \r\n\r\nThanks @rmarx for the reply on how to proceed. Your reasoning makes sense in light of upcoming adoption and the unknowns. \r\n\r\nPlease feel free to close the issue.\r\n\r\n",
          "createdAt": "2021-05-04T04:48:50Z",
          "updatedAt": "2021-05-04T04:48:50Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Sounds like the author found a solution. Closing this ticket but we can reopen if I've gotten the wrong end of the stick.",
          "createdAt": "2022-09-08T01:31:25Z",
          "updatedAt": "2022-09-08T01:31:25Z"
        }
      ]
    },
    {
      "number": 156,
      "id": "MDU6SXNzdWU4OTI1MTg4NzE=",
      "title": "Discuss versioning",
      "url": "https://github.com/quicwg/qlog/issues/156",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "high-level-schema",
        "discuss",
        "ask-3rd-party"
      ],
      "body": "Currently, we have only a single version field in `qlog_version`. This is somewhat inflexible, as it for example doesn't allow indicating updated versions of event definitions for individual protocols (say we have main schema version 2, but HTTP/3's events are already at 5, while you can also use 2, 3 and 4 with main schema 2).\r\n\r\nI'm not entirely sure we need to go very fine-grained in this (e.g., indicating for each event which version it belongs to seems overkill), but a more advanced scheme than what we have currently is probably needed.\r\n\r\nOriginal remark from @lpardue:\r\n\r\n> Do we also need independent versioning of the different schema? How does qlog evolve over the years? For example, say the main schema got published as 1.0, and then work commenced on 2.0. Can there be a QUIC qlog event definitions 1.1 (which is updated say to support QUIC v2) and a 2.1 (which is updated to support QUIC v2 and a new main schema format)?\r\n",
      "createdAt": "2021-05-15T19:17:44Z",
      "updatedAt": "2024-06-27T19:02:42Z",
      "closedAt": "2024-06-27T19:02:42Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I think we might benefit from hearing from folks that have had to maintain versioned schema in the IETF. I doubt we need to reinvent the wheel here.",
          "createdAt": "2022-09-08T01:33:03Z",
          "updatedAt": "2022-09-08T01:33:03Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This should be fixed by #415 (and partly by #417).\r\n\r\nNewer versions of the events would have to register a new URI with IANA (e.g., :qlog:quic would be v1, :qlog:quic2026 would be v2, etc.) and then logging that in `event_schemas` should make it clear which version you're talking about (combined with `qlog_version` for the main schema)",
          "createdAt": "2024-06-27T19:02:42Z",
          "updatedAt": "2024-06-27T19:02:42Z"
        }
      ]
    },
    {
      "number": 157,
      "id": "MDU6SXNzdWU5MTAyMTI3NTE=",
      "title": "PCAPML and metadata integration in general",
      "url": "https://github.com/quicwg/qlog/issues/157",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "high-level-schema",
        "future-versions"
      ],
      "body": "I recently came across this interesting project that tags traffic in pcaps for Machine Learning purposes: https://github.com/nprint/pcapml\r\n\r\nThis general concept of keeping traffic traces and metadata describing that data in the same file is one of the things I had envisioned for qlog at the start as well (i.e., combining traces into a single file, the `configuration` field, the ability to add new fields to events at will, etc.). This goal has diminished somewhat over time, but I'm still a big proponent of it.\r\n\r\nI feel we should take a look at PCAPML to see how they're approaching this and decide if similar setups should be *possible* in qlog (though probably not part of the core spec). ",
      "createdAt": "2021-06-03T07:43:30Z",
      "updatedAt": "2022-09-29T14:12:24Z",
      "closedAt": "2022-09-29T14:12:24Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "hmmm. Anything is possible, right? It's interesting for sure but seems outside our tight scope of work. I'm not seeing much traction on the issue since it got opened. Suggest closing and reopening if someone comes back with a strong use case we can't accomodate, or information about a current implementation of this technique applied to qlog.",
          "createdAt": "2022-09-08T01:37:23Z",
          "updatedAt": "2022-09-08T01:37:23Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree to close without action. ",
          "createdAt": "2022-09-29T14:12:24Z",
          "updatedAt": "2022-09-29T14:12:24Z"
        }
      ]
    },
    {
      "number": 158,
      "id": "MDU6SXNzdWU5MjcyMjUzNTA=",
      "title": "What is the media-type?",
      "url": "https://github.com/quicwg/qlog/issues/158",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "MEMBER",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design",
        "high-level-schema",
        "current-version"
      ],
      "body": "What is the [media-type](https://www.iana.org/assignments/media-types/media-types.xhtml) of the qlog files?",
      "createdAt": "2021-06-22T13:18:18Z",
      "updatedAt": "2022-09-08T01:25:52Z",
      "closedAt": "2022-09-08T01:25:52Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is currently not yet defined...\r\n\r\nAt first instinct, I'd say `application/qlog+json`, but I'm not sure how we'd indicate the difference between normal JSON and newline-delimited JSON (if we even decide to keep that). Maybe `application/qlog+ndjson` and then something like `application/qlog+cbor` down the line?\r\n\r\nNot sure how easy/difficult that would be to deal with for qlog tooling / how media-type parsers typically deal with this type of thing. ",
          "createdAt": "2021-06-22T13:28:46Z",
          "updatedAt": "2021-06-22T13:28:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Thank you for the response.\r\n\r\nFor context, the reason I asked is because h2o has a well-known URI for serving traces, see https://mailarchive.ietf.org/arch/msg/quic/VHyaEIHxYylfg5NAKBxccycqnvc/.\r\n\r\nAt the moment, we use a custom ndjson format, but if we are to use qlog, there has to be a media-type.",
          "createdAt": "2021-08-13T06:42:12Z",
          "updatedAt": "2021-08-13T06:42:12Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Fixed as far as I can tell, closing.",
          "createdAt": "2022-09-08T01:25:52Z",
          "updatedAt": "2022-09-08T01:25:52Z"
        }
      ]
    },
    {
      "number": 159,
      "id": "MDU6SXNzdWU5MzM5Mjg3MjA=",
      "title": "Consider renaming HTTP/3 \"frame_type\" to \"type\"",
      "url": "https://github.com/quicwg/qlog/issues/159",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "design",
        "quic-http3-fields",
        "current-version",
        "discuss"
      ],
      "body": "If I understand the schema correctly, I would produce something like this\r\n\r\n```\r\n[\"42.797\",\"http\",\"frame_created\",{\"stream_id\":\"12345\",\"frame\":{\"frame_type\":\"data\"},\"length\":\"6789\"}]\r\n```\r\n\r\nsince `frame_type` is a property of the `frame` object, it seems redundant. Can we just use `type` instead?",
      "createdAt": "2021-06-30T17:16:43Z",
      "updatedAt": "2021-08-18T14:47:33Z",
      "closedAt": "2021-08-18T14:47:33Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We used to have just `type` or `id` for all similar fields, then (I think when moving to -02 or slightly before) I changed everything to have a more declarative name to make fields less reliant on context. \r\n\r\nYou could argue this is not needed for `frame_type` because it is indeed encapsulated in a top-level `frame` field, while it **is** still needed for `stream_id` because that's not immediately clear. Still, I personally somewhat prefer consistency here myself.\r\n\r\nWhat would be your main argument for not keeping `frame_type`? ",
          "createdAt": "2021-07-01T09:01:44Z",
          "updatedAt": "2021-07-01T09:01:44Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ping @LPardue ",
          "createdAt": "2021-08-18T13:49:29Z",
          "updatedAt": "2021-08-18T13:49:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I can live without this change, lets close it",
          "createdAt": "2021-08-18T14:18:52Z",
          "updatedAt": "2021-08-18T14:18:52Z"
        }
      ]
    },
    {
      "number": 160,
      "id": "MDU6SXNzdWU5MzQwNDIwNzk=",
      "title": "GoAway contains a \"stream_id\" field",
      "url": "https://github.com/quicwg/qlog/issues/160",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://quicwg.org/qlog/draft-ietf-quic-qlog-h3-events.html#section-a.1.6\r\n\r\nWhen this became usable by clients, the ID changed to also apply to pushes. Suggest the field name \"id\" instead.",
      "createdAt": "2021-06-30T19:20:04Z",
      "updatedAt": "2021-07-01T12:48:29Z",
      "closedAt": "2021-07-01T12:48:29Z",
      "comments": []
    },
    {
      "number": 163,
      "id": "MDU6SXNzdWU5Mzc0OTkyMTA=",
      "title": "Aggregating stream_frame",
      "url": "https://github.com/quicwg/qlog/issues/163",
      "state": "CLOSED",
      "author": "kuroa-me",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "quic-http3-fields",
        "future-versions"
      ],
      "body": "I am currently implementing qlog for video streaming using quiche.\r\nDue to the nature of video streaming, there are a lot of back and forth of `STREAM` and `ACK` frames, and they are not very useful to log.\r\nFrom the `server` vantage point, `ACK`s can be aggregated by either `packets_acked` or `frames_processed` event. However, I did not find a way to aggregate `STREAM` frames the server send out. Is there a good way to solve this problem?",
      "createdAt": "2021-07-06T04:06:03Z",
      "updatedAt": "2024-02-19T03:52:11Z",
      "closedAt": "2024-02-19T03:52:11Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hello @incfex,\r\n\r\nThanks for opening an issue. \r\n\r\nIIUC, you're basically asking for a `frames_created` event, in which you would aggregate ACK and STREAM frames that are sent over multiple packets into a single event. Is that correct? This is indeed something we currently don't have, but that I feel would be logical to add. \r\n\r\nFor the ACK-frame special case, maybe we can add an endpoint discriminator to `packets_acked` so it can be re-used when either sending/receiving (though this kind of depends on how uniformly we end up doing qlog events down the line: it might make more sense to add that to `frames_processed` too and rename it to `frames_info` or something). \r\n\r\nexample (though not very happy with the semantics of \"owner\" here):\r\n```\r\npackets_acked {\r\n  owner?:\"local\"|\"remote\",\r\n\r\n  packet_number_space?:PacketNumberSpace,\r\n  packet_numbers?:Array<uint64>\r\n}\r\n```\r\n\r\nI am however a bit confused by your motivation saying \r\n> there are a lot of back and forth of STREAM and ACK frames, and they are not very useful to log.\r\n\r\naren't you still logging them all in the `frames_processed` (or potential `frames_created`)? or how does your approach make that specifically better than using `packet_sent` and `packet_received`? Do you mean you don't want to log the packet info and just the frame details? or are you logging select ACKs/STREAM frames (but how do you decide which to log then?)? or is there something else going on?",
          "createdAt": "2021-07-09T08:36:47Z",
          "updatedAt": "2021-07-09T08:36:47Z"
        },
        {
          "author": "kuroa-me",
          "authorAssociation": "NONE",
          "body": "Sorry for the confusion, my current situation is: on the SERVER side, it is sending a lot of STREAM frames and receiving similar amount of ACK frames.\r\n> IIUC, you're basically asking for a frames_created event, in which you would aggregate ACK and STREAM frames that are sent over multiple packets into a single event.\r\n\r\n\r\nThis is basically what I am asking for, but only log ACK or STREAM frames, and with a little twist.\r\n\r\nQlog currently requires STREAM frame to have `frame_type` and `stream_id` field. In my case when I am logging every `packet_sent`, each of `packet_sent` only have a single stream frame in it. There are usually 50 consecutive `packet_sent` events like this. Thus, I am purposing a `frames_created` event with `default_frame` field inside. When frames in the array did not specify their `frame_type`, we could assume that they have the same field values with the default.\r\n\r\npurposed `frames_created` example:\r\n```\r\nframes_created {\r\n  default_frame?:QuicFrame,\r\n  frames?:Array<QuicFrame>,\r\n  packet_numbers?:Array<uint64>\r\n}\r\n```\r\n\r\n\r\ncurrent example of logging all the STREAM frames with `packet_sent`(json format): \r\n```\r\n{\r\n  \"events\": [\r\n    {\r\n      \"time\": \"1\",\r\n      \"name\": \"transport:packet_sent\",\r\n      \"frames\": [\r\n        {\r\n          \"fin\": false,\r\n          \"frame_type\": \"stream\",\r\n          \"length\": 1000,\r\n          \"offset\": 2000,\r\n          \"stream_id\": 0\r\n        }\r\n      ],\r\n      \"header\": {\r\n        \"packet_number\": 3,\r\n        \"packet_size\": 1024\r\n      },\r\n      \"packet_type\": \"1RTT\",\r\n      \"transmission_type\": \"not_retransmission\"\r\n    },\r\n    {\r\n      \"time\": \"100\",\r\n      \"name\": \"transport:packet_sent\",\r\n      \"frames\": [\r\n        {\r\n          \"fin\": false,\r\n          \"frame_type\": \"stream\",\r\n          \"length\": 1000,\r\n          \"offset\": 3000,\r\n          \"stream_id\": 0\r\n        }\r\n      ],\r\n      \"header\": {\r\n        \"packet_number\": 4,\r\n        \"packet_size\": 1024\r\n      },\r\n      \"packet_type\": \"1RTT\",\r\n      \"transmission_type\": \"not_retransmission\"\r\n    },\r\n    {\r\n      \"time\": \"200\",\r\n      \"name\": \"transport:packet_sent\",\r\n      \"frames\": [\r\n        {\r\n          \"fin\": false,\r\n          \"frame_type\": \"stream\",\r\n          \"length\": 500,\r\n          \"offset\": 4000,\r\n          \"stream_id\": 0\r\n        }\r\n      ],\r\n      \"header\": {\r\n        \"packet_number\": 5,\r\n        \"packet_size\": 524\r\n      },\r\n      \"packet_type\": \"1RTT\",\r\n      \"transmission_type\": \"not_retransmission\"\r\n    }\r\n  ]\r\n}, \r\n...\r\n```\r\n\r\nExample of logging with the `frames_created` event:\r\n```\r\n{\r\n  \"events\":[\r\n    {\r\n      \"time\":\"1\",\r\n      \"name\":\"transport:packet_sent\",\r\n      \"data\":{\r\n        \"default_frame\":{\r\n          \"frame_type\":\"stream\",\r\n          \"stream_id\":0,\r\n          \"length\": 1000\r\n        },\r\n        \"frames\":[\r\n          {\"offset\": 2000},\r\n          {\"offset\": 3000},\r\n          {\"offset\": 4000, \"length\": 500}],\r\n        \"packet_number\": [3, 4, 5]\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nThis approach could also applies to ACK frames, becomes a dumb version of `packets_acked` event that does not care repeated ACKs.\r\n\r\nWhat do you think of this?\r\n",
          "createdAt": "2021-07-12T07:49:43Z",
          "updatedAt": "2021-07-12T07:49:43Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the additional information, that's much clearer now. \r\n\r\nWhile I agree with the use case for a `frames_created` event, I'm quite skeptical about the proposed design, primarily the `default_frame` setup. I'm having a hard time imagining many implementers wanting to use it like that in a general-purpose setup.\r\n\r\nFor example, you'd have to check if per-frame values deviate from the default, and you'd have to keep multiple of these events \"alive\"/buffered, 1 for each frame type you might care about (and demux frame data to the correct one). It would also require some quite more advanced logic in tools. I feel that would work in your specialized use case (only STREAM/ACK, many similar frame instances), but IMO that's not what should be **standardized**: this would be better suited for a \"custom\", application-specific qlog event, which is perfectly allowed by the spec as well. \r\n\r\nThis is partly because IIUC, one of the main reasons to do this is to reduce log verbosity. qlog has a long history of trying different ways to combat this (e.g., a convoluted csv-alike setup in draft-01 with columns). For draft-02, we took the decision to care less about (textual) verbosity/repetition, since this can be dealt with using either compression or a binary serialization format (see #30 for some earlier discussion and #144 for the current issue on this). I think moving from pure `packet_sent` to a general `frames_created` (where you still log each frame (in-full), without `default_frame`) already helps a lot in this regard. Going further should imo be application-specific. \r\n\r\nSo what I'd propose is add something like this:\r\n```\r\nframes_created : \r\n{\r\n       frames:Array<QuicFrame>,\r\n\r\n       packet_numbers?:Array<uint64>\r\n}\r\n```\r\n\r\nI think probably @marten-seemann also has some opinions on this. ",
          "createdAt": "2021-07-12T14:52:29Z",
          "updatedAt": "2021-07-12T14:52:29Z"
        },
        {
          "author": "kuroa-me",
          "authorAssociation": "NONE",
          "body": "Thanks for your response!\r\n\r\nI agree that this would advanced logic in tools to achieve `default_frame`. My original intend is to only apply this field to STREAM/ACK frames, since they are the most likely ones to appear consecutivly. Also only maintain/buffer 1 `frames_created` for both frame types. As long as the next frame is different from the `default_frame` maintained, current `frames_created` will be concluded and a new one will be created. This way, we do not have to buffer multiple of these events.\r\n\r\n> I'm having a hard time imagining many implementers wanting to use it like that in a general-purpose setup.\r\n\r\nAbout this, if a website have video playback or file download, it will have bulk consecutive STREAM/ACK frames. Having a video on the website is not that uncommon this days.\r\n\r\nMaybe change the `default_frame` to `common_frame_type`, and only declare the `frame_type:string` inside it would reduce the amount of advance logic, whilst saving space to store the qlog.",
          "createdAt": "2021-07-13T03:11:15Z",
          "updatedAt": "2021-07-13T03:11:15Z"
        },
        {
          "author": "kuroa-me",
          "authorAssociation": "NONE",
          "body": "After applying `frames_created` and `frames_processed` to only consecutive STREAM and ACK frames, I have observed 70~80% space save in the final qlog. These event types prove to be very useful in the situation where large objects are transferred (e.g. streaming, downloading).",
          "createdAt": "2021-08-05T07:14:19Z",
          "updatedAt": "2021-08-05T07:14:19Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hello @incfex,\r\n\r\nThanks for keeping us updated on this. \r\n\r\nIIUC, you have now created a custom `frames_created` event that makes use of your proposed `default_frame` field, right? And that approach saves you 70 to 80% of qlog size. Would it be possible to upload an example of such a resulting file here so I can better interpret what exactly you're doing?\r\n\r\nDuring the [recent discussion on this at the IETF](https://youtu.be/R7q8cWIAIDQ?t=3267), I proposed **not** adding events like `frames_created` to qlog to keep the qlog spec more straightforward. In order to reduce qlog size, I argued that 1) it doesn't matter -that- much in practice (some large deployments like Facebook use verbose JSON directly) and 2) it can largely be solved using (on-the-fly/streaming) compression (see also #30). \r\n\r\nAs such, it would help me to get some insight into your specific use case and the reasons why keeping qlog size down (if that is indeed the main motivation) is crucial to your setup and why that's difficult to achieve by using compression instead. I'm not arguing having additional size optimizations would be useless, but I am debating if the complexity of adding these events to the qlog **standard** are worth their benefits.\r\n\r\nRelatedly, I wonder how you are using the logged information concretely. No longer having specific timestamps and packet associations for individual ACKs/STREAM frames reduces debuggability in some ways. How are you currently processing the qlogs in practice to e.g., find bugs/inefficiencies or how do you plan to do so? \r\n\r\nThank you in advance for this additional insight!\r\n",
          "createdAt": "2021-08-17T14:56:50Z",
          "updatedAt": "2021-08-17T14:56:50Z"
        },
        {
          "author": "kuroa-me",
          "authorAssociation": "NONE",
          "body": "> IIUC, you have now created a custom frames_created event that makes use of your proposed default_frame field, right? And that approach saves you 70 to 80% of qlog size. Would it be possible to upload an example of such a resulting file here so I can better interpret what exactly you're doing?\r\n\r\nAbsolutely, here is the qlog format we are currently using.\r\n[f576620f4936d820.qlog.zip](https://github.com/quicwg/qlog/files/7004174/f576620f4936d820.qlog.zip)\r\nThis is a fork to the Facebook's mvfst implementation, and still a work in progress. Since we are only logging on the server-side, it is only aggregating outgoing STREAM and incoming ACK frames. You might be noticing repeated \"packetNums\" for ACK, that is for the PADDING frame attached to the ACK frames.\r\n\r\n> During the recent discussion on this at the IETF, I proposed not adding events like frames_created to qlog to keep the qlog spec more straightforward. In order to reduce qlog size, I argued that 1) it doesn't matter -that- much in practice (some large deployments like Facebook use verbose JSON directly) and 2) it can largely be solved using (on-the-fly/streaming) compression (see also #30).\r\n\r\nI have watched that session and learnt a lot from that. I now agrees with that if we are trying to make qlog a logging format, sticking to the wire-format is the way. However, writing qlog is hammering on our disk IO, increasing the IO latency and thus lowered our bandwidth. Also, our QUIC server works in edge computing, the disk space to store and bandwidth to transfer qlog cost a lot, so we cannot use verbose JSON directly. (on-the-fly/streaming) does help, and we are using it now to further reducing the size of our qlog.\r\n\r\n> As such, it would help me to get some insight into your specific use case and the reasons why keeping qlog size down (if that is indeed the main motivation) is crucial to your setup and why that's difficult to achieve by using compression instead. I'm not arguing having additional size optimizations would be useless, but I am debating if the complexity of adding these events to the qlog standard are worth their benefits.\r\n\r\nReasons as explained before:\r\n1. high cost to store and transfer the qlog.\r\n2. writing un-aggregated qlog impacts our disk IO, caused lower network bandwidth.\r\n3. compression is used with aggregated qlog.\r\n\r\nOur current observation is that if you try to implement qlog on the machine that running quic fine right now might cause performance impact. And to mitigate this, you have to increase the budget. \r\n\r\n> Relatedly, I wonder how you are using the logged information concretely. No longer having specific timestamps and packet associations for individual ACKs/STREAM frames reduces debuggability in some ways. How are you currently processing the qlogs in practice to e.g., find bugs/inefficiencies or how do you plan to do so?\r\n\r\nWe are just starting to use qlog, and trying to see what we could use it for. Specific timestamps can be added using time delta just like other events. Currently we have a parser that parse our aggregated qlog back into standard qlog.\r\n\r\nThere might be some place I did not explain clearly, if you have any question, just shoot it. This also helps us a lot.\r\n",
          "createdAt": "2021-08-18T03:39:24Z",
          "updatedAt": "2021-08-18T03:39:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This custom optimization seems completely fine to do if people want to add the complexity. However, for the reasons outlined, I don't see a reason to try and design this into base qlog specification.\r\n\r\nPerhaps the original poster has had time to learn from deployment since the issue was opened. But absent any followup I think this can be safely punted into a qlog extension.",
          "createdAt": "2023-07-05T00:52:39Z",
          "updatedAt": "2023-07-05T00:52:39Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Closing as timed out.",
          "createdAt": "2024-02-19T03:52:11Z",
          "updatedAt": "2024-02-19T03:52:11Z"
        }
      ]
    },
    {
      "number": 164,
      "id": "MDU6SXNzdWU5MzgxMDIyNDk=",
      "title": "units of src_port, dst_port, minimum_congestion_window",
      "url": "https://github.com/quicwg/qlog/issues/164",
      "state": "CLOSED",
      "author": "junhochoi",
      "authorAssociation": "NONE",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "editorial",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "While I read the some of the event definitions, I have some questions:\r\n\r\nhttps://github.com/quicwg/qlog/blob/main/draft-ietf-quic-qlog-quic-events.md#L312\r\n\r\n```\r\n    src_port?: uint32,\r\n    dst_port?: uint32,\r\n```\r\n`uint16` for udp port numbers (https://datatracker.ietf.org/doc/html/rfc768) looks good enough.\r\n\r\nhttps://github.com/quicwg/qlog/blob/main/draft-ietf-quic-qlog-quic-events.md#L1106\r\n\r\n```\r\n    initial_congestion_window?:uint64, // in bytes\r\n    minimum_congestion_window?:uint32, // in bytes // Note: this could change when max_datagram_size changes\r\n```\r\n\r\nSince both are congestion window values, using `uint64` for both makes sense to me.\r\n\r\n",
      "createdAt": "2021-07-06T17:14:31Z",
      "updatedAt": "2023-01-18T19:57:07Z",
      "closedAt": "2023-01-18T19:57:07Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hello Junho,\r\n\r\nThanks for opening the issue. \r\n\r\n`uint16` for UDP ports seems sensible.\r\n\r\nNot sure if we need `uint64` at all for congestion windows though... I'd rather think that using `uint32` for the initial cwnd would be better? (or are there systems doing +4GB bursts on new connections somewhere? :P)\r\n",
          "createdAt": "2021-07-09T09:39:17Z",
          "updatedAt": "2021-07-09T09:39:17Z"
        },
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "`congestion_window` is also `uint64`, so I just think that `initial_congestion_window` and `minimal_congestion_window` need to be a same type. In practice it will fit into 32bit (10 x mss and 2 x mss, respectively), but no need to assign a different type for them only because they are small?",
          "createdAt": "2021-07-09T18:12:49Z",
          "updatedAt": "2021-07-09T18:12:49Z"
        }
      ]
    },
    {
      "number": 165,
      "id": "MDU6SXNzdWU5NDE0NDg1ODc=",
      "title": "Some JSON serialization examples are examples of broken JSON",
      "url": "https://github.com/quicwg/qlog/issues/165",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "editorial",
        "current-version"
      ],
      "body": "In the main logging schema, about half of the `JSON serialization` examples don't encapsulate field names in double quotes. So passing these verbatim into a parser will yield errors. ",
      "createdAt": "2021-07-11T13:03:10Z",
      "updatedAt": "2022-09-09T13:35:29Z",
      "closedAt": "2022-09-09T13:35:29Z",
      "comments": []
    },
    {
      "number": 166,
      "id": "MDU6SXNzdWU5NDE0NTQ3MjY=",
      "title": "Inconsistencies when talking about the \"trigger\" field",
      "url": "https://github.com/quicwg/qlog/issues/166",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "Across the qlog docs, the text seems inconsistent when it mentions the \"trigger\" field, and whether that is a property of Event of Event:Data. For example\r\n\r\n```\r\nFor each event type, its importance and data definition is laid out, often accompanied by possible values for the optional \"trigger\" field.\r\n```\r\n\r\nIIUC, \"trigger\" is supposed to be only defined for Event:Data that cares to define it. It would help to sweep the docs to ensure consistency in this area.",
      "createdAt": "2021-07-11T13:36:36Z",
      "updatedAt": "2023-07-05T01:13:20Z",
      "closedAt": "2023-07-05T01:13:20Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Current plan is to address this by including triggers directly in the event data definition instead of separately.\r\n\r\nSee https://github.com/quiclog/qlog/tree/master/CDDL/schema#triggers. ",
          "createdAt": "2022-02-18T14:20:58Z",
          "updatedAt": "2022-02-18T14:20:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "over taken by other editorial changes, so closing.",
          "createdAt": "2023-07-05T01:13:20Z",
          "updatedAt": "2023-07-05T01:13:20Z"
        }
      ]
    },
    {
      "number": 167,
      "id": "MDU6SXNzdWU5NDE0NTcwODE=",
      "title": "Qlog events section-3.1.7 diagram is misformatted",
      "url": "https://github.com/quicwg/qlog/issues/167",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "editorial",
        "current-version"
      ],
      "body": "Looks like it is showing the markdown rather than getting rendered as a diagram.",
      "createdAt": "2021-07-11T13:49:33Z",
      "updatedAt": "2022-03-20T16:14:36Z",
      "closedAt": "2022-03-20T16:14:36Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should be fixed in the latest drafts (though not 100% sure, since \"qlog events section 3.1.7\" is somewhat vague :P ",
          "createdAt": "2022-03-20T16:14:36Z",
          "updatedAt": "2022-03-20T16:14:36Z"
        }
      ]
    },
    {
      "number": 168,
      "id": "MDU6SXNzdWU5NDIxNDgyNTc=",
      "title": "Allow multiple packet_numbers in frames_processed",
      "url": "https://github.com/quicwg/qlog/issues/168",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "Currently, `frames_processed` only allows indicating a single packet_number.\r\n\r\nHowever, discussion in #163 has shown that you might want to aggregate frames across multiple packets for some use cases, so it makes sense to make this into an `Array<uint64>` instead. ",
      "createdAt": "2021-07-12T14:54:16Z",
      "updatedAt": "2023-07-05T18:19:20Z",
      "closedAt": "2023-07-05T18:19:20Z",
      "comments": [
        {
          "author": "kuroa-me",
          "authorAssociation": "NONE",
          "body": "About this structure\r\n```\r\nframes_processed : \r\n{\r\n       frames:Array<QuicFrame>,\r\n       packet_numbers?:Array<uint64>\r\n}\r\n```\r\nHow do we log the packet_numbers when we have multiple frames in one packet? My suggestion is we log them one to one.\r\n\r\nExample (suppose fr1 and fr2 are in the same packet):\r\n```\r\n{\r\n       frames:[fr1, fr2, fr3, fr4],\r\n       packet_number:[1, 1, 2, 3]\r\n}\r\n```\r\n\r\nThis way we don't have to do any search when the packets arrive out of order.\r\n",
          "createdAt": "2021-07-14T03:10:19Z",
          "updatedAt": "2021-07-14T03:10:19Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good point and your suggestion seems sensible :) ",
          "createdAt": "2021-07-14T13:15:27Z",
          "updatedAt": "2021-07-14T13:15:27Z"
        }
      ]
    },
    {
      "number": 169,
      "id": "MDU6SXNzdWU5NTE0MTQ5NzQ=",
      "title": "Bad code block formatting for some events",
      "url": "https://github.com/quicwg/qlog/issues/169",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "editorial",
        "current-version"
      ],
      "body": "Some events, like connection_state_updated and packets_acked don't have properly rendered \"data\" fields because there is no empty line between the \"Data:\" text and the start of the code block indicator \"~~~\".\r\n\r\nThis causes the code to be treated as a normal, contiguous text block",
      "createdAt": "2021-07-23T09:37:12Z",
      "updatedAt": "2022-03-20T16:13:38Z",
      "closedAt": "2022-03-20T16:13:37Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This should be fixed in main-schema-02 and h3/quic-events-01",
          "createdAt": "2022-03-20T16:13:37Z",
          "updatedAt": "2022-03-20T16:13:37Z"
        }
      ]
    },
    {
      "number": 170,
      "id": "MDU6SXNzdWU5NTE0MjEyMDY=",
      "title": "Discuss how to approach extensions short term",
      "url": "https://github.com/quicwg/qlog/issues/170",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "current-version",
        "discuss"
      ],
      "body": "With several extensions to QUIC and HTTP/3 being developed, we should have some way of defining qlog events for them.\r\n\r\nGiven that most of these extensions are not RFC's in their own right, it doesn't make much sense to add them to the main documents at this time (or ever). \r\n\r\nConcrete examples:\r\n- WebTransport having new stream types that impact the existing H3 `stream_type_set` event\r\n- DATAGRAM and CAPSULE frames that should be defined\r\n- CONNECT-UDP related metadata etc. \r\n\r\nProposal:\r\n- Specify qlog events for these in separate documents **in a separate repository** (potentially a new aggregate one at https://github.com/quiclog? Assuming people won't want to make separate docs themselves).\r\n\r\nLong term, we need a proper way to do this, but for now I think something like this might suffice.\r\n\r\ncc @LPardue  \r\n",
      "createdAt": "2021-07-23T09:44:32Z",
      "updatedAt": "2024-06-24T13:29:57Z",
      "closedAt": "2024-06-24T13:29:57Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "So I don't think we need to concern the current QUIC WG qlog docs with work being done outside the group.\r\n\r\nI do think we should probably accommodate QUIC DATAGRAMS in the qlog schema (because that draft will be done before qlog). \r\n\r\nH3 DATAGRAMS and Capsules should be out of scope here. We could entertain the idea of defining them as part of the h3 datagram spec itself, but with the open questions about schema format etc that's probably not really feasible.",
          "createdAt": "2021-07-23T10:08:18Z",
          "updatedAt": "2021-07-23T10:08:18Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related to #124 ",
          "createdAt": "2021-08-18T10:18:57Z",
          "updatedAt": "2021-08-18T10:18:57Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Solved by #417 ",
          "createdAt": "2024-06-24T13:29:46Z",
          "updatedAt": "2024-06-24T13:29:46Z"
        }
      ]
    },
    {
      "number": 171,
      "id": "MDU6SXNzdWU5NTE0MzEwOTQ=",
      "title": "packet_number should not be required for vneg/retry packets",
      "url": "https://github.com/quicwg/qlog/issues/171",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "editorial",
        "current-version"
      ],
      "body": "Currently, the PacketHeader struct makes the `packet_number` field required.\r\n\r\nWe must add a comment that this is only true if `packet_type` is not version negotiation or retry (similar to how we define other optional fields there).\r\n\r\ncc @jlaine ",
      "createdAt": "2021-07-23T09:58:41Z",
      "updatedAt": "2022-11-01T10:37:01Z",
      "closedAt": "2022-11-01T10:37:00Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was apparently a duplicate of #133 and fixed recently in https://github.com/quicwg/qlog/commit/b4e3f2634b27bdbb4566eceeeae6c79342a1efe8",
          "createdAt": "2022-11-01T10:37:00Z",
          "updatedAt": "2022-11-01T10:37:00Z"
        }
      ]
    },
    {
      "number": 172,
      "id": "MDU6SXNzdWU5NTgzNzQ5NjA=",
      "title": "Decide if streaming serialization needs to be defined",
      "url": "https://github.com/quicwg/qlog/issues/172",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design",
        "high-level-schema",
        "current-version"
      ],
      "body": "The document includes considerations about streaming serialization and specifies a way to do this using NDJSON (new-line delimited JSON).\r\n\r\nThere's two things that the Working Group should consider:\r\n\r\n1) Does streaming serialization need to be defined as part of the qlog main schema?\r\n2) If the answer to 1 is yes, what format should be used.\r\n\r\nDuring IETF 111, it was noted that https://datatracker.ietf.org/doc/html/rfc7464 is an IETF-defined format that achieves similar streaming properties as NDJSON.  There might be a preference for using RFC 7464 pending the outcome of #144.",
      "createdAt": "2021-08-02T17:50:26Z",
      "updatedAt": "2022-03-20T16:06:02Z",
      "closedAt": "2022-03-20T16:06:01Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed previously, I have now experimented with the \"JSON text sequences\" format described in https://datatracker.ietf.org/doc/html/rfc7464. \r\n\r\nWhile it is a bit annoying to have to add the RecordSeparator (RS, %x1E, U+001E) character before each event, in practice it was easy enough to integrate the new format with tools like [qvis ](https://github.com/quiclog/qvis/commit/9eaf25b67fa7a5128874f1e0dc3f1f623908439a)and use it with existing tools like jq, grep, sed and awk. \r\n\r\nAs such, we propose to indeed replace the NDJSON format in draft-00 with the RFC 7464 format. This has several advantages, among which: \r\n1. having an existing RFC to refer to instead of having to define the format in qlog itself (since NDJSON is not an official standard anywhere)\r\n2. having an existing mime-type `application/json-seq`  (see also #158)\r\n3. supporting \"pretty printed\" JSON (records/events can span multiple lines), while NDJSON does not support \\n characters in an event\r\n\r\nI will create a PR to make this change in the text. Below are some example files and practical guidelines for those who wish to start experimenting with this themselves. cc @marten-seemann \r\n\r\n------------\r\n\r\n[This zip file](https://github.com/quicwg/qlog/files/7374539/json-seq.zip) contains 2 files in both NDJSON, line-based json-seq and pretty-printed json-seq formats. \r\n\r\nThese were generated by taking quic-go NDJSON outputs from https://interop.seemann.io and then adding the RecordSeparator character to them using the following sed monstrosity: \r\n\r\n```\r\n# adapted from https://blog.jpalardy.com/posts/handling-broken-json-with-jq/#an-example\r\n\r\ncat ndjsoninput1.qlog | sed -e 's/^{/'$(printf \"\\x1e\")'{/' -e '$a\\\\n' | jq -c --seq . > textseqoutput1.qlog\r\n\r\n# NOTE: if the last record isn't properly closed with a LineFeed \\n, then jq will SILENTLY drop the final event in the file...\r\n# this is why we add the  -e '$a\\\\n'  command, which selects the final line with $, enters append mode with a, and then adds \\n\r\n# if we have too many \\n's, they are discarded, so this is safe\r\n\r\n# jq -c is used to pretty-print the output. If that's not needed, the jq command can be left out. \r\n```\r\n\r\nI then also changed the \"qlog-format\" field on the first line to \"JSON-SEQ\" (instead of \"NDJSON\"). That should be enough to get the files to load in qvis (\"qlog-version\" is currently still \"draft-02\", we'll probably want to change that for the upcoming ietf-draft-01).\r\n\r\nOf course, implementations that output the new format should just output the \\x1E character directly instead of post-processing the files like this... how to do that depends on the programming language of course.\r\n\r\n\r\nI then also tested the json-seq files with some common tooling, especially `jq`. `jq` has built-in support for text-sequences by passing in the option `--seq`. With the option on, `jq` should also still be able to process normal JSON and NDJSON, so it should be safe to \"leave it on\", no matter which qlog format you're processing.\r\n\r\nFor example:\r\n```\r\ncat textseqoutput1.qlog | jq --seq -c '. | select(.data.header?.packet_type? == \"handshake\")'\r\n``` \r\n\r\nFeel free to test this out yourselves and let me know if you find problems with the new format!\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-10-19T15:25:48Z",
          "updatedAt": "2021-10-19T15:25:48Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "I've been using NDJSON and I like the simplicity, but the inability to have newlines in the JSON output was a point of contention for me. The ability to add some newlines to make events more readable would be nice.\r\n\r\nThe addition of the `\\x1E` character is gross but solves the problem while using an existing IETF standard.",
          "createdAt": "2021-10-20T21:04:00Z",
          "updatedAt": "2021-10-20T21:04:00Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "My two cents would go to using NDJSON rather than JSON Text Sequences (RFC 7464), because the former is more widespread, easy to use with existing line-oriented tools, and because I do not think we need the properties being provided by RFC 7464 (e.g., process dataset in the middle, as discussed in [Section 1 of RFC 7464]{https://datatracker.ietf.org/doc/html/rfc7464#section-1}).\r\n\r\nI would not mind too strongly about switching to JSON Text Sequences, as it is possible to convert from that to NDJSON, but my preference goes to using something more widespread - that was the reason we chose JSON instead of some binary format, after all.",
          "createdAt": "2021-10-20T21:58:17Z",
          "updatedAt": "2021-10-20T21:58:17Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "As an individual: I prefer to base the streaming output on an IETF standard. Building something for general purpose tools is useful and valuable today but I would like to set up qlog to be something that integrates well into IETF paradigms in the long term.\r\n\r\nThe transformation to newline-only delimitation is trivial. If its useful, I think we can mention that without referring to NDJSON explicitly.",
          "createdAt": "2021-10-20T22:19:57Z",
          "updatedAt": "2021-10-20T22:19:57Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks all for the additional input. We decided to try the JSON Text Sequences for now and see how it goes (doesn't mean we can't later switch to something else if Text Sequences turn out horrible somehow). \r\n\r\nThe new approach is detailed in the new draft-01 of the main schema here: https://datatracker.ietf.org/doc/html/draft-ietf-quic-qlog-main-schema-01.\r\n\r\nFeel free to implement the new format and let us know results, remarks, feedback, etc. Thanks!",
          "createdAt": "2021-10-25T12:07:00Z",
          "updatedAt": "2021-10-25T12:07:00Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We haven't heard major pushback against this since the introduction, so I'm going to close this issue for now.",
          "createdAt": "2022-03-20T16:06:01Z",
          "updatedAt": "2022-03-20T16:06:01Z"
        }
      ]
    },
    {
      "number": 173,
      "id": "MDU6SXNzdWU5NjI4MTExMzg=",
      "title": "RawInfo doesn't play well with UDP datagram headers",
      "url": "https://github.com/quicwg/qlog/issues/173",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "Currently, we re-use the RawInfo struct to give a simple re-usable way to log raw packet/frame/datagram contents.\r\n\r\nIn the struct, we have two length-fields: the full `length` and `payload_length`, assuming the header length can be calculated from those two. \r\n\r\nHowever, we do not have a way to log e.g., only the payload without the header (we can only log the full value truncated, but not indicate it starts at the payload).\r\n\r\nThis isn't a problem for QUIC/H3 packets/frames, but as @jlaine pointed out, it is a problem for UDP datagrams. In most stacks, you don't get the pure UDP packet header and so can't log it (so you'd always start with the payload).\r\n\r\nThis can be solved in several different ways:\r\n1. disallow usage of RawInfo for datagrams\r\n2. make explicit that datagram-related events start at the payload\r\n3. log a fixed-value/fixed-size dummy UDP datagram (e.g., 8 bytes of zeroes)\r\n4. extend RawInfo to make it more flexible\r\n\r\nI'm currently most in favor of 2, as I don't see many people logging full UDP datagrams instead of logging the QUIC packets. \r\n\r\n",
      "createdAt": "2021-08-06T14:55:06Z",
      "updatedAt": "2023-01-19T11:20:15Z",
      "closedAt": "2023-01-19T11:20:15Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by #274 ",
          "createdAt": "2023-01-19T11:20:11Z",
          "updatedAt": "2023-01-19T11:20:11Z"
        }
      ]
    },
    {
      "number": 174,
      "id": "MDU6SXNzdWU5NzM0ODkzNzA=",
      "title": "Editorial update to RFCs/draft-34 + rawInfo + general consistency",
      "url": "https://github.com/quicwg/qlog/issues/174",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "editorial",
        "high-level-schema",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "since qlog started early on in the quic/H3 design process, we have some leftovers from early drafts in the docs.\r\n\r\nWe've updated most things over time as they were changed, but some aspects (e.g., most of the quic recovery events mention draft-23/27, `stream_state_updated` mentions draft-23, `packet_sent` triggers refer draft-23/19, etc.)\r\n\r\nWe need to go through each event and match it to terminology used in the final versions of the documents. \r\nFor most things, this would just require removing mentions of old drafts, but in some cases this might require further changes. \r\n\r\nFinally, many events in the quic/H3 docs incorrectly use the pre-draft-02 way of logging raw information (e.g., as bytes fields directly), instead of properly using the new `raw:RawInfo` type. This should be updated.\r\n\r\nSubsumes #46. ",
      "createdAt": "2021-08-18T09:57:41Z",
      "updatedAt": "2024-03-04T14:45:30Z",
      "closedAt": "2024-03-04T14:45:29Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related to #113 as well.",
          "createdAt": "2021-08-18T10:12:34Z",
          "updatedAt": "2021-08-18T10:12:34Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related to #129 ",
          "createdAt": "2021-08-18T10:20:57Z",
          "updatedAt": "2021-08-18T10:20:57Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related to #166 ",
          "createdAt": "2021-08-18T13:51:53Z",
          "updatedAt": "2021-08-18T13:51:53Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed during the editors' meeting, it makes sense to keep this work until when we do the major pass over the full documents when updating to the new Data Definition format (#143). It makes sense to check these things when going through all event definitions piece-by-piece. ",
          "createdAt": "2021-08-18T14:48:45Z",
          "updatedAt": "2021-08-18T14:48:45Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Is there any more work remaining here? If so, recommend creating new more-specific tickets. Either way time to close this monolith.",
          "createdAt": "2023-11-30T01:07:18Z",
          "updatedAt": "2023-11-30T01:07:18Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, there's definitely more work remaining here, e.g., references to old drafts in https://www.ietf.org/archive/id/draft-ietf-quic-qlog-quic-events-06.html#section-4.6 and https://www.ietf.org/archive/id/draft-ietf-quic-qlog-quic-events-06.html#section-5.5. \r\n\r\nFiguring out what's what and creating separate tickets is probably more work than just going through the doc and fixing stuff though... I'd rather do the latter ;) ",
          "createdAt": "2023-12-08T15:27:33Z",
          "updatedAt": "2023-12-08T15:27:33Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I already fixed that in the editors copy.\r\n\r\nThis is my point, the general job of editing a document doesn't need a ticket. If there's easy things to fix we just do them. If there's bigger things, an issue to have the discussion makes sense. This ticket is no longer specific and actionable.",
          "createdAt": "2023-12-08T15:42:32Z",
          "updatedAt": "2023-12-08T15:42:32Z"
        }
      ]
    },
    {
      "number": 175,
      "id": "MDU6SXNzdWU5ODUxMDI4NDQ=",
      "title": "h3 parameters: s/max_header_list_size/max_field_section_size",
      "url": "https://github.com/quicwg/qlog/issues/175",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "editorial",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "The name of the setting was changed in draft 28",
      "createdAt": "2021-09-01T12:40:41Z",
      "updatedAt": "2023-01-18T20:00:36Z",
      "closedAt": "2023-01-18T20:00:36Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks Lucas, good catch!\r\n\r\nI'm trying to track all of these minor changes in #174 and we plan to do them in bulk when going over all the definitions when switching them to CDDL. \r\n\r\nFeel free to report other similar changes, as individual issues with a reference to #174 or as comments on that issue directly. ",
          "createdAt": "2021-09-01T15:01:28Z",
          "updatedAt": "2021-09-01T15:01:28Z"
        }
      ]
    },
    {
      "number": 176,
      "id": "I_kwDOCrLn6M47dVO2",
      "title": "Define means for strong extensibility of TPs",
      "url": "https://github.com/quicwg/qlog/issues/176",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://quicwg.org/qlog/draft-ietf-quic-qlog-quic-events.html#name-parameters_set defines some of the core QUIC TPs and then says\r\n\r\n> Additionally, this event can contain any number of unspecified fields. This is to reflect setting of for example unknown (greased) transport parameters or employed (proprietary) extensions.\r\n\r\nThat's fine but is it weak and doesn't help interoperability much. We know this is going to be an area of innovation - new extensions and grease values. The spec would be improved by having a well-defined \"extension bucket\" field that TPs can go in, an array of integers tuples would be fine, for example.\r\n\r\nThis would help something like the qlog crate accomodate different users https://github.com/cloudflare/quiche/blob/master/tools/qlog/src/lib.rs#L1712 and parse input from different loggers.\r\n\r\n",
      "createdAt": "2021-09-15T21:43:26Z",
      "updatedAt": "2024-03-04T11:42:32Z",
      "closedAt": "2024-03-04T11:42:32Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, this turned out to be slightly easier than expected, see #400. ",
          "createdAt": "2024-02-29T15:27:55Z",
          "updatedAt": "2024-02-29T15:27:55Z"
        }
      ]
    },
    {
      "number": 178,
      "id": "I_kwDOCrLn6M48g4Le",
      "title": "support for DATAGRAMS in data_moved events",
      "url": "https://github.com/quicwg/qlog/issues/178",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "Slightly related to #124\r\n\r\nhttps://quicwg.org/qlog/draft-ietf-quic-qlog-quic-events.html#section-3.3.15 defines the data_moved event. The stream_id field is optional. It isn't clear if the type of data I'm moving is stream data (and I don't have the stream ID) or if its datagram data (and I'll never have the stream ID).\r\n\r\nAn non-exhaustive list of options to address this are:\r\n\r\n1) leave it as is, and let tools assume that omitting the stream ID field implies datagram. (That breaks down for implementations that can't populate the stream ID for whatever reason)\r\n2) add a field to describe the type of data moved\r\n3) Be more clear that `data_moved` is only for stream data.Then possibly:\r\n  a) rename the event to `stream_data_moved`\r\n  b) add a new `datagram_data_moved` event\r\n\r\n",
      "createdAt": "2021-10-04T14:25:25Z",
      "updatedAt": "2023-07-06T14:54:38Z",
      "closedAt": "2023-07-06T14:54:38Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "If we accept that we'll punt detailing DATAGRAMS in the base qlog specs, then any of these options would still fundamentally work. \r\n\r\nIt think its a crapshoot between option 2 and 3, and comes down to ergonomics. Is it easier for consumers of qlog to index off an event type, or a field in an event? Or is it totally neutral?",
          "createdAt": "2022-09-08T00:26:52Z",
          "updatedAt": "2022-09-08T00:26:52Z"
        }
      ]
    },
    {
      "number": 179,
      "id": "I_kwDOCrLn6M486GE_",
      "title": "Figures contain lines that are too long",
      "url": "https://github.com/quicwg/qlog/issues/179",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "current-version"
      ],
      "body": "An editorial issue, but one that is good to get solved with a general approach that will avoid nit blocking eventual publication.\r\n\r\nHere's an example of the nits from the main schema draft\r\n\r\n```\r\n  Checking nits according to https://www.ietf.org/id-info/checklist :\r\n  ----------------------------------------------------------------------------\r\n\r\n  ** There are 30 instances of too long lines in the document, the longest\r\n     one being 329 characters in excess of 72.\r\n```\r\n\r\nWe had a similar problem in the Digest draft, some things like hashes or JSON objects are too long. Here's what we did https://httpwg.org/http-extensions/draft-ietf-httpbis-digest-headers.html#appendix-C\r\n\r\n> Some examples include JSON objects in the content. For presentation purposes, objects that fit completely within the line-length limits are presented on a single line using compact notation with no leading space. Objects that would exceed line-length limits are presented across multiple lines (one line per key-value pair) with 2 spaced of leading indentation.",
      "createdAt": "2021-10-10T02:44:06Z",
      "updatedAt": "2022-03-20T16:11:38Z",
      "closedAt": "2022-03-20T16:11:38Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We plan to tackle this in the move to CDDL. ",
          "createdAt": "2021-10-20T14:35:51Z",
          "updatedAt": "2021-10-20T14:35:51Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should be fixed in main-schema-02 and h3/quic-events-01 (I'm no longer getting any ID-nits errors on the documents). ",
          "createdAt": "2022-03-20T16:11:36Z",
          "updatedAt": "2022-03-20T16:11:36Z"
        }
      ]
    },
    {
      "number": 180,
      "id": "I_kwDOCrLn6M49Pv9z",
      "title": "consider an alternative to the .qlog file extension for streaming serilization",
      "url": "https://github.com/quicwg/qlog/issues/180",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "design",
        "current-version"
      ],
      "body": "The `qlog_format` field is part of the QlogFile and QlogFileNDJSON, so it's a bit circular to decide how to parse the object. When processing large files, it can be a pain to decide,\r\n\r\nOne technique would be to look at the first line of a file to determine the qlog format before attempting to parse it. But that seems like a hack. It also doesn't help if a large qlog is written into a file as a single line.\r\n\r\nKnowing the format up front, such as by unique file extensions, would mean that tools or applications can make more assumptions about how to deal with the file. For instance, I could simply use `split` https://man7.org/linux/man-pages/man1/split.1.html to safely slice up NDJSON files today, without requireing deep knowledge of qlog formats.",
      "createdAt": "2021-10-15T15:08:43Z",
      "updatedAt": "2022-02-18T17:29:51Z",
      "closedAt": "2022-02-18T17:29:51Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems like a general issue wider than just qlog, and one that IIUC has traditionally been solved by a combination of looking at extensions AND the first few bytes/line of the file in question (e.g., image format headers). \r\n\r\nWhile we could indicate a specific extension for the different qlog serialization types in the spec, tools probably would still want to just support `.json` as a valid `.qlog` file in any format. In qvis for example, we do [look at the first few characters of a file](https://github.com/quiclog/qvis/blob/14351bc11602d04c04a6ecae038172a28f26cef7/visualizations/src/components/filemanager/data/FileLoader.ts#L204) to guess its format, so we support both options for a `.qlog` before actual parsing. As such, I feel it's one of those cases that we could/should spec, but that it wouldn't have full impact IRL for reusable tooling. \r\n\r\nAn additional aspect is using mime-types when transferring over e.g., HTTP, see #158, where I do also think we should define the media types in the draft. \r\n\r\nSo, I'd propose to indeed recommend (SHOULD, not MUST) .qlog for normal JSON and .sqlog (for \"streaming\" qlog) for json-seq.  What do you think? \r\n\r\n\r\n",
          "createdAt": "2021-10-20T14:45:03Z",
          "updatedAt": "2021-10-20T14:45:03Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "We picked `.sqlog`. This issue can be closed now.\r\n",
          "createdAt": "2022-01-21T18:25:18Z",
          "updatedAt": "2022-01-21T18:25:18Z"
        }
      ]
    },
    {
      "number": 182,
      "id": "I_kwDOCrLn6M49rugR",
      "title": "What are the units of \"relative_time\"?",
      "url": "https://github.com/quicwg/qlog/issues/182",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The example in https://quicwg.org/qlog/draft-ietf-quic-qlog-main-schema.html#common-fields suggests the field is a string. Elsewhere, timestamps seem to be integers https://quicwg.org/qlog/draft-ietf-quic-qlog-main-schema.html#section-3.4.1 but in Event the `time` is a double https://quicwg.org/qlog/draft-ietf-quic-qlog-main-schema.html#section-3.4",
      "createdAt": "2021-10-25T09:07:31Z",
      "updatedAt": "2022-10-05T14:46:24Z",
      "closedAt": "2022-10-05T14:46:24Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since we now require all times to be in `ms`, I think the `double` is the only correct one. \r\n\r\nThe string is a leftover from earlier times, when we forced string for something that could be >2^53 (JavaScript number limit), but when moving to CDDL, all of that will be unnecessary and we'll have doubles for this.\r\n\r\n(this obviously doesn't mean all qlog files actually use doubles at this time ;) qvis is a bit too lacks and allows both numbers and strings, so people can get away with either most times) ",
          "createdAt": "2021-10-25T09:50:51Z",
          "updatedAt": "2021-10-25T09:50:51Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This has been fixed in the meantime. ",
          "createdAt": "2022-10-05T14:46:24Z",
          "updatedAt": "2022-10-05T14:46:24Z"
        }
      ]
    },
    {
      "number": 183,
      "id": "I_kwDOCrLn6M4-VGpW",
      "title": "QUIC relies on ApplicationError, which is defined only for HTTP/3",
      "url": "https://github.com/quicwg/qlog/issues/183",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "design",
        "editorial",
        "quic-http3-fields"
      ],
      "body": "I recently refactored quiche's qlog implementation to split events into their own modules for general, QUIC and HTTP/3. In follow up work, I realised our implementation of the ConnectionClose frame was stale and I attempted to fix it up here https://github.com/cloudflare/quiche/pull/1079/commits/866292b923ce2fe236fcced0a641607e3be60bec. The definition of that frame at the time of writing is below, and a far as I can tell, `ApplicationError` is only defined in the HTTP/3 spec.\r\n\r\n```\r\nclass ConnectionCloseFrame{\r\n    frame_type:string = \"connection_close\";\r\n\r\n    error_space?:ErrorSpace;\r\n    error_code?:TransportError | ApplicationError | uint32;\r\n    raw_error_code?:uint32;\r\n    reason?:string;\r\n\r\n    trigger_frame_type?:uint64 | string; // For known frame types, the appropriate \"frame_type\" string. For unknown frame types, the hex encoded identifier value\r\n}\r\n```\r\n\r\nIn code review, it was highlighted that including an HTTP/3 enumeration in my QUIC module code is a bit strange (feels like a priority inversion). Also, it doesn't seem to scale to support other applications. I think perhaps what is needed is for there to be an \"externalised\" ApplicationError union type like `type ApplicationError = Http3Error | NewStuff`, or maybe even that doesn't work well for supporting new application protocols...",
      "createdAt": "2021-11-05T11:14:54Z",
      "updatedAt": "2022-03-20T16:10:59Z",
      "closedAt": "2022-03-20T16:10:59Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Is there a reason to expose the semantics of application protocol in at QUIC level?\r\n\r\nIMO, trying to expose HTTP3Error at QUIC level is no less strange than asking to decode the HTTP headers being transported by the STREAM frames, or the HTTP/3 stream type.\r\n\r\nI would hope that the QUIC-level traces would just show the error codes in numbers, much like they just log the stream IDs / bytes being exchanged.",
          "createdAt": "2021-11-06T04:51:41Z",
          "updatedAt": "2021-11-06T04:51:41Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "That would work too. We could invent new application error event types that sit in H3, and then correlate to QUIC frames bearing the integer value",
          "createdAt": "2021-11-06T11:28:28Z",
          "updatedAt": "2021-11-06T11:28:28Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good catch, and I feel this is primarily an oversight of mine in forgetting to change this when splitting up QUIC and H3 events...\r\n\r\nI agree it doesn't make sense to have the ApplicationError class in the QUIC events doc and that we should revert to just having `string | uint32` there, with some extra guidance that application-specific qlog docs should make that more explicit (e.g., with the ApplicationError enum that maps to strings in the H3 doc). \r\n\r\nHaving separate error events at the H3 layer is imo perpendicular to this, but certainly also not a bad idea. ",
          "createdAt": "2021-11-09T16:00:45Z",
          "updatedAt": "2021-11-09T16:00:45Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "String | uint32 works for me and means we likely never have to revisit this space ",
          "createdAt": "2021-11-09T16:03:58Z",
          "updatedAt": "2021-11-09T16:03:58Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With CDDL, we will be able to do better than `string | uint32` as it can define extension points (called sockets/plugs in CDDL) with `$`. \r\n\r\nWill probably look something like:\r\n```\r\n# in QUIC document:\r\n$ApplicationErrorType\r\n\r\n# in HTTP/3 document:\r\n$ApplicationErrorType \\= H3ApplicationError\r\n\r\n# in future WebTransport document\r\n$ApplicationErrorType \\= WTApplicationError\r\n\r\n```",
          "createdAt": "2022-02-18T14:18:50Z",
          "updatedAt": "2022-02-18T14:18:50Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was added in h3-events-01 as such:\r\n\r\n```\r\nHTTPApplicationError =  \"http_no_error\" /\r\n                        \"http_general_protocol_error\" /\r\n                        \"http_internal_error\" /\r\n                        \"http_stream_creation_error\" /\r\n                        \"http_closed_critical_stream\" /\r\n                        \"http_frame_unexpected\" /\r\n                        \"http_frame_error\" /\r\n                        \"http_excessive_load\" /\r\n                        \"http_id_error\" /\r\n                        \"http_settings_error\" /\r\n                        \"http_missing_settings\" /\r\n                        \"http_request_rejected\" /\r\n                        \"http_request_cancelled\" /\r\n                        \"http_request_incomplete\" /\r\n                        \"http_early_response\" /\r\n                        \"http_connect_error\" /\r\n                        \"http_version_fallback\"\r\n\r\n; ensure HTTP errors are properly validate in QUIC events as well\r\n; e.g., QUIC's ConnectionClose Frame\r\n$ApplicationError /= HTTPApplicationError\r\n```\r\n\r\nWith the quic-events-01 properly exposing the `$ApplicationError` CDDL extension socket. ",
          "createdAt": "2022-03-20T16:10:59Z",
          "updatedAt": "2022-03-20T16:10:59Z"
        }
      ]
    },
    {
      "number": 184,
      "id": "I_kwDOCrLn6M4-YHxH",
      "title": "The `Summary` type is too poorly defined",
      "url": "https://github.com/quicwg/qlog/issues/184",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "editorial"
      ],
      "body": "QlogFile and QlogFileSeq contain `summary?: Summary`. However, https://quicwg.org/qlog/draft-ietf-quic-qlog-main-schema.html#section-3.1 states \r\n\r\n> As the summary field is highly deployment-specific, this document does not specify any default fields or their semantics.\r\n\r\nIt's not a problem to leave the Summary type open as you suggest. But it's not clear how I would represent this in an implementation. Is it an array of `(String, Any)` tuples, or something else?",
      "createdAt": "2021-11-06T13:34:24Z",
      "updatedAt": "2023-07-05T01:59:37Z",
      "closedAt": "2023-07-05T01:59:37Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The original idea was to have this as a generic JSON Object (so not quite an array of (string, any) but rather a key-value object, which is kind of the same thing conceptually), as suggested by the example.  \r\n\r\nSo in TypeScript, it might be better defined as `summary?: Object` or if we want to keep the Summary type, we'd get something like:\r\n\r\n```\r\ninterface Summary {\r\n  [key: string]: any;\r\n}\r\n```\r\n(according to https://remarkablemark.org/blog/2021/08/19/typescript-type-plain-old-javascript-object/)\r\n\r\nNot sure what that'll look like in CDDL, but will make sure to keep it into account when we do that work. ",
          "createdAt": "2021-11-09T16:08:18Z",
          "updatedAt": "2021-11-09T16:08:18Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Sgtm will review it once we get there",
          "createdAt": "2021-11-09T16:14:37Z",
          "updatedAt": "2021-11-09T16:14:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Closing this since we want to delete the entire field, which resolves the comment.",
          "createdAt": "2023-07-05T01:59:37Z",
          "updatedAt": "2023-07-05T01:59:37Z"
        }
      ]
    },
    {
      "number": 185,
      "id": "I_kwDOCrLn6M5DMQMn",
      "title": "key_retired should be key_discarded",
      "url": "https://github.com/quicwg/qlog/issues/185",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "editorial",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "Apparently, what was once (colloquially) known as key \"retire\" is now called key \"discard\" in [RFC 9001](https://www.rfc-editor.org/rfc/rfc9001.html#name-discarding-unused-keys). \r\n\r\nAs such, we should update the event definition's name (and probably add some more information in the qlog spec as well, since it's a bit barebones atm). \r\nI'm also not sure anymore what the difference is in the triggers with \"tls\" vs \"local/remote update\"...\r\n\r\ncc @kosekmi\r\n\r\n",
      "createdAt": "2022-02-08T13:51:06Z",
      "updatedAt": "2022-09-09T13:39:00Z",
      "closedAt": "2022-09-09T13:39:00Z",
      "comments": []
    },
    {
      "number": 186,
      "id": "I_kwDOCrLn6M5DekYc",
      "title": "Add a way to indicate sent-but-unacked data",
      "url": "https://github.com/quicwg/qlog/issues/186",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design",
        "quic-http3-fields",
        "current-version"
      ],
      "body": "Once data for a stream is sent in a packet, it has to remain in some form of retransmission buffer (either a separate buffer or as ranges in the main stream buffer or ...) until the data is ACKed as received, only then can it be discarded completely. \r\n\r\nAt this time, there is no way to track how much sent-but-unacked data is outstanding for a given stream. \r\n\r\nThe most organic way to do this seems to be to add a new target to the `data_moved` event. We currently have `\"user\",\"application\",\"transport\",\"network\"`, where we might regard \"network\" as being \"sent but unacked\", but then we still lack a \"discarded\" state. \r\n\r\nBikeshedding is possible on the name: \"discarded\", \"resolved\", \"acknowledged\", ... as conceptually we could even replace the \"user\" target with this one as well, and saying that indicates the data has left the \"network protocol stack\" (either on the sender or receiver side), terming it as \"handled\"/\"resolved\" would make sense there.\r\n\r\ncc @LPardue ",
      "createdAt": "2022-02-11T08:39:33Z",
      "updatedAt": "2024-11-05T19:45:54Z",
      "closedAt": "2024-11-05T19:45:54Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "There's two transitions here:\r\n\r\nSend side: transport -> $foo\r\nReceive side: application -> $bar\r\n\r\n$bar I think is sufficiently expressed by \"user\" in my opinion. \r\n\r\nFor $foo, it's a bit tricky because the current values are all entities, while you've proposed non-entity terms here. Some additional suggestions would be \"null\", \"free\", or \"terminal\" (as in terminal state, not a bash terminal). \r\n\r\nThe nice thing about modelling a discarding transition is that it can also be used for stream resets. Helps to understand the point in time a transport implementation actually frees any buffers, independent of the RESET_STREAM frame.",
          "createdAt": "2022-02-11T08:54:11Z",
          "updatedAt": "2022-02-11T08:54:11Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems related (at least a bit) to https://github.com/quicwg/qlog/pull/396.\r\n\r\nI'm not sure we still want to go down this road (also don't remember what first triggered opening this issue). \r\nAs it is, it seems like this is something that can be done on a per-implementation basis if needed (using the mechanism I described above), which probably makes most sense since this is mostly for debugging internal memory management, which is unlikely to be the same across stacks (and unlikely to be able to properly use generalized tooling). \r\n\r\nProposal: close without action. What do you think @LPardue ?",
          "createdAt": "2024-02-28T10:59:12Z",
          "updatedAt": "2024-02-28T10:59:12Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some final thoughts on this @LPardue or I'll close with no action :) ",
          "createdAt": "2024-06-24T15:22:52Z",
          "updatedAt": "2024-06-24T15:22:52Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I checked the quiche implementation again, we actually extend `$DataLocation` with a `dropped` value. When processing acks, we'll trigger a stream_data_moved event from `transport` to `dropped`.\r\n\r\nI don't currently actively use this in my tooling but I could (and now I've been reminded it exists, I'm excitied). \r\n\r\nGiven that DataLocation is extensible , I have a custom solution that works for my needs. I'm not hearing any other interest in this right now. It would be easy enough for someone to standardize in future if they wanted.\r\n\r\nPropose to close with no action.",
          "createdAt": "2024-11-04T16:51:33Z",
          "updatedAt": "2024-11-04T16:51:33Z"
        }
      ]
    },
    {
      "number": 187,
      "id": "I_kwDOCrLn6M5DyXiK",
      "title": "Remove Summary and Configuration",
      "url": "https://github.com/quicwg/qlog/issues/187",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design",
        "high-level-schema",
        "discuss"
      ],
      "body": "We currently have the `summary` (in QlogFile) and `configuration` (in Trace) fields.\r\n\r\nThese fields made sense when qlog was viewed as a file format that would primarily be used to aggregate multiple traces into a single file, which would then be transferable between different tools (e.g., in research settings). \r\n\r\nHowever, with most implementations shifting to streaming logging (1 trace per file) and no tools emerging that rely on interoperability via the `summary` and `configuration` fields, I feel it makes sense to just remove them from the spec. This is further motivated by the fact that Summary is defined as just a generic JSON object and Configuration only has 2 recommended fields, 1 of which is `original_uris`, which again only makes sense if we see this as a grouping format. \r\n\r\nSee also #184, cc @LPardue ",
      "createdAt": "2022-02-14T13:07:01Z",
      "updatedAt": "2023-07-05T18:30:37Z",
      "closedAt": "2023-07-05T18:30:37Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "+1 to simplicity. \r\n\r\nIt seems like it's going to be straightforward for anyone to add such fields in future if they really need them. Being judicious with we things we include in the base spec will make it more straightforward for people to focus on the valuable items.",
          "createdAt": "2022-02-14T13:36:20Z",
          "updatedAt": "2022-02-14T13:36:20Z"
        }
      ]
    },
    {
      "number": 188,
      "id": "I_kwDOCrLn6M5DyiNs",
      "title": "Force line length to 72",
      "url": "https://github.com/quicwg/qlog/issues/188",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "editorial",
        "future-versions"
      ],
      "body": "According to the official IETF draft guidelines, line length should not be longer than 72 ASCII characters (https://www.ietf.org/how/ids/guidelines/#format, and https://www.ietf.org/how/ids/guidelines/).\r\n\r\nFor some reason, I had previously understood this to be 82 characters, and so the current texts are 10 characters too wide...\r\n\r\nSince this will be somewhat of a tedious process (which can be done largely automatically but with manual checks) which will impact allmost all parts of the documents, I propose we do this in a single burst somewhere down the line. \r\n\r\ncc @LPardue ",
      "createdAt": "2022-02-14T13:38:36Z",
      "updatedAt": "2022-03-20T16:09:41Z",
      "closedAt": "2022-03-20T16:09:41Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Chatted a bit with rmarx offline. The errors that xml2rfc moans about are about artwork, not body text etc.\r\n\r\nOver the 3 PRs I created, there might look like a lot of churn but it is all constrained to the artwork pieces. In my opinion, it's better to fix these now (or nullify the json validation errors) so that we don't start ignoring things that exist or get newly introduced.",
          "createdAt": "2022-02-14T18:52:54Z",
          "updatedAt": "2022-02-14T18:52:54Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This should be fixed as of main-schema-02 and h3/quic-events-01. \r\n\r\nFor future reference: hard limit of 72 is only needed inside \"figures\" (including code blocks!). Running text paragraphs/lists/etc. can be done by the tooling itself. ",
          "createdAt": "2022-03-20T16:09:41Z",
          "updatedAt": "2022-03-20T16:09:41Z"
        }
      ]
    },
    {
      "number": 192,
      "id": "I_kwDOCrLn6M5EPB8i",
      "title": "Rework $ProtocolEventBody",
      "url": "https://github.com/quicwg/qlog/issues/192",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design",
        "high-level-schema",
        "discuss"
      ],
      "body": "The new CDDL approach uses a CDDL extension point to be more strict about which values are allowed in the `Event:data` field. \r\n\r\nCurrently, it's defined as:\r\n\r\n```\r\n; The ProtocolEventBody is any key-value map (e.g., JSON object)\r\n; only the optional trigger field is defined in this document\r\n$ProtocolEventBody /= {\r\n    ? trigger: text\r\n    * text => any\r\n}\r\n; event documents are intended to extend this socket by using:\r\n; NewProtocolSpecificEvents = EventType1 / EventType2 / ... / EventTypeN\r\n; $ProtocolEventBody /= NewProtocolSpecificEvents\r\n```\r\n\r\nHowever, this effectively still allows just about any JSON object as ProtocolEventBody, as we're just extending the $ProtocolEventBody.\r\n\r\nIf we want to be (slightly) more strict, we could do something like this:\r\n```\r\n; main doc\r\nProtocolEventBodyPrototype = {\r\n    ? trigger: text\r\n    * text => any\r\n}\r\n\r\nProtocolEventBody = ProtocolEventBodyPrototype / $ProtocolEventBodies\r\n\r\n; event docs\r\nNewProtocolSpecificEvents = EventType1 / EventType2 / ... / EventTypeN\r\n$ProtocolEventBodies /= NewProtocolSpecificEvents\r\n```\r\n\r\nAlternatively, we can just NOT allow the general form (the `ProtocolEventBodyPrototype`) and just include that as an example and require event bodies to provide at least 1 defined event. ",
      "createdAt": "2022-02-19T17:03:09Z",
      "updatedAt": "2024-06-24T13:32:21Z",
      "closedAt": "2024-06-24T13:32:20Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I don't see any problem with the current level of extensibility. What benefit(s) would being more restrictive bring?",
          "createdAt": "2023-12-09T21:25:07Z",
          "updatedAt": "2023-12-09T21:25:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "After understanding how to apply CDDL types better, I now support more rigidity in extensibility.",
          "createdAt": "2024-05-13T13:51:41Z",
          "updatedAt": "2024-05-13T13:51:41Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Solved by #417 ",
          "createdAt": "2024-06-24T13:32:20Z",
          "updatedAt": "2024-06-24T13:32:20Z"
        }
      ]
    },
    {
      "number": 196,
      "id": "I_kwDOCrLn6M5FZSGN",
      "title": "Should custom CDDL types be defned externally?",
      "url": "https://github.com/quicwg/qlog/issues/196",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "In https://www.ietf.org/archive/id/draft-ietf-quic-qlog-main-schema-02.html#section-1.1.1 you define `uint8`, `uint16`, `uint32`, `uint64` and `hexstring`types.\r\n\r\nHave you considered if these types should be defined in their own document? This seems like something where direction from the CBOR WG would be good. ",
      "createdAt": "2022-03-09T17:49:02Z",
      "updatedAt": "2023-12-09T21:27:09Z",
      "closedAt": "2023-12-09T21:27:09Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree guidance from the CBOR WG would be good, but I do feel they can just remain in the main qlog document, since there are so few and they are very straightforward.\r\n\r\nI still have to explore some examples Carsten Bormann sent me of other RFCs using CDDL; maybe I can find some prior work that shows best practices in this. ",
          "createdAt": "2022-03-10T08:27:05Z",
          "updatedAt": "2022-03-10T08:27:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Yes agreed. Let's try and lock this down so we don't have to revisit it later when it might be more awkward and become a blocker to finishing.",
          "createdAt": "2022-03-10T09:15:16Z",
          "updatedAt": "2022-03-10T09:15:16Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I don't want to do this, so I'm closing the issue.",
          "createdAt": "2023-12-09T21:27:09Z",
          "updatedAt": "2023-12-09T21:27:09Z"
        }
      ]
    },
    {
      "number": 197,
      "id": "I_kwDOCrLn6M5FZWOD",
      "title": "Scope of draft-ietf-quic-qlog-main-schema",
      "url": "https://github.com/quicwg/qlog/issues/197",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Editorial work on draft-ietf-quic-qlog-main-schema has been a lower priority than the design work. That's fine. But as we look ahead, we should think a bit about what the scope or pitch of the document is. Right now the document is titled \"Main logging schema for qlog\" and the abstract says:\r\n\r\n> This document describes a high-level schema for a standardized logging format called qlog. This format allows easy sharing of data and the creation of reusable visualization and debugging tools. The high-level schema in this document is intended to be protocol-agnostic. Separate documents specify how the format should be used for specific protocol data. The schema is also format-agnostic, and can be represented in for example JSON, csv or protobuf.\r\n\r\nIn reality the document speaks to both the schema and all of the ways that applications might use qlog.Editorial questions to ask for this draft are:\r\n\r\nDoes it need to do both of these things in the same document?\r\nIs there stale text that can be deleted to improve focus?\r\nMore drastically, is there any benefit in splitting the document into schema and usage drafts?\r\n",
      "createdAt": "2022-03-09T18:06:27Z",
      "updatedAt": "2023-11-30T00:50:30Z",
      "closedAt": "2023-11-30T00:50:30Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with the general sentiment here, and I would indeed go a step further in suggesting we should remove some parts (mainly 6.3 the \"other optimized formatting options\", and some smaller stuff here and there).\r\n\r\nOther than that, I feel that especially section Section 7 (\"Methods of a access and generation\") and 8 (\"Tooling requirements\") might be split up into a separate document. A long time ago I discussed this with @britram and he seemed to feel that sort of thing belonged more in the ops area (though we might want to keep it in quic wg just for consistency, idk). \r\n\r\nIs that the split you had in mind @LPardue, or would you group things differently? ",
          "createdAt": "2022-03-10T08:33:15Z",
          "updatedAt": "2022-03-10T08:33:15Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Yeah something along those lines feels right. Thanks. Not urgent to do it yet but good tp start thinking ahead.",
          "createdAt": "2022-03-10T09:13:05Z",
          "updatedAt": "2022-03-10T09:13:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I'm feeling pessimistic about creating any new documents. Editorial improvements to the adopted drafts can be tracked in other issues - closing this issue.",
          "createdAt": "2023-11-30T00:50:30Z",
          "updatedAt": "2023-11-30T00:50:30Z"
        }
      ]
    },
    {
      "number": 198,
      "id": "I_kwDOCrLn6M5F_kBC",
      "title": "Logging events and dealing with clock drift",
      "url": "https://github.com/quicwg/qlog/issues/198",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "We had a question about quiche's logging on https://github.com/cloudflare/quiche/issues/1197 this got me thinking some more about representations of time in qlog.\r\n\r\nIn quiche, we use a monotonic non-decreasing clock. When a trace is started, we store a monotonic start time internally and don't put that in the qlog. As events are created, we calculate a relative time since the start and record that.\r\n\r\nI've now realised this behaviour seems to differ from what the qlog draft states in https://quicwg.org/qlog/draft-ietf-quic-qlog-main-schema.html#name-timestamps\r\n\r\n> Relative: Specify a full \"reference_time\" timestamp (typically this is done up-front in \"common_fields\", see [Section 3.4.7](https://quicwg.org/qlog/draft-ietf-quic-qlog-main-schema.html#common-fields)) and include only relatively-encoded values based on this reference_time with each event. The \"reference_time\" value is typically the first absolute timestamp. This approach uses a medium amount of characters.\r\n\r\nThe problem is that clock drift can occur. The spec mentions this briefly but I wonder if the problem is larger than people give consideration to. For the relative and base time formats, you'd potentially end up smaller or negative values, which might break qlog tooling.\r\n\r\nI don't have much insight into solving clock drift problems but could we consider adding a monotonic time format type in addition?",
      "createdAt": "2022-03-19T15:31:19Z",
      "updatedAt": "2024-10-21T19:48:20Z",
      "closedAt": "2024-10-21T19:48:19Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "@rmarx asked me to explain this further or more clearly. So lets try a different angle.\r\n\r\nHere is what qlog says\r\n\r\n> The \"time\" field indicates the timestamp at which the event occurred. Its value is typically the Unix timestamp since the 1970 epoch (number of milliseconds since midnight UTC, January 1, 1970, ignoring leap seconds). However, qlog supports two more succinct timestamps formats to allow reducing file size. The employed format is indicated in the \"time_format\" field, which allows one of three values: \"absolute\", \"delta\" or \"relative\".\r\n\r\nEach event has a timestamp, whose value is calculated according to the format. qlog hints that the UNIX epoch is \"typical\", which leaves the door open to other epoch. But qlog doesn't really support expressing what the epoch is explicitly. \r\n\r\nThe `relative` encoding is described as:\r\n\r\n> specify a full \"reference_time\" timestamp (typically this is done up-front in \"common_fields\", see [Section 3.4.7](https://quicwg.org/qlog/draft-ietf-quic-qlog-main-schema.html#common-fields)) and include only relatively-encoded values based on this reference_time with each event. The \"reference_time\" value is typically the first absolute timestamp. This approach uses a medium amount of characters.\r\n\r\nIf wishing to not use the unix epoch as the relative format's epoch, the spec if not clear how to represent that. `reference_time` is just a float64. If qlog producers are free to insert any value into this, it is not clear how qlog consumers are expected to consume the value. One use case could be in tooling to convert the relative-encoded timestamps back to into an absolute time for the purposes of converting into a human-readable format like a string, such a tool might assume the value of `relative_time` is the number of seconds since the unix epoch and, if it isn't, the calculation would be wrong.\r\n\r\nA common producer use case is to want to log events starting with a timestamp of 0, and then to progress forward in ascending time durations. For this use case, the reference_time field does not add much value. Setting a `reference_time` of 0 could be confused with \"0 seconds since the unix epoch\" because the qlog specification is not tight enough.\r\n\r\nAn implied reference clock based on e.g. the unix clock, sets up other caveats. In some environments, it is possible to operate in abstract time durations, where the epoch cannot be serialized to a value that makes sense for any other system.  For example, Rust provides an [Instant](https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.duration_since) type against which monotonic time durations can be calculated. The alternative would be to use SystemTime time, where durations do not have the same guarantee due the possibility of clocks being moved forward or backwards; see https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.duration_since\r\n\r\n Finally, qlog recommends \r\n \r\n > Events in each individual trace SHOULD be logged in strictly ascending timestamp order (though not necessarily absolute value, for the \"delta\" format). Tools CAN sort all events on the timestamp before processing them, though are not required to (as this could impose a significant processing overhead). This can be a problem especially for multi-threaded and/or streaming loggers, who could consider using a separate post-processor to order qlog events in time if a tool do not provide this feature.\r\n \r\n While it alludes to some of the problems of time-synchronization, it could probably be clearer. This is especially true if using a relative time format based on a wall clock reference where clock changes could cause a negative value to be logged in the timestamp. Naively sorting these logs based on the relative timestamp would produce an incorrect view of the connection's events. Instead, a tool trying to do some log consolidation and sorting needs to be very date-time aware. That probably extends to qlog consumers, for example, if they convert to a human-friendly representation then it should not be unexpected that clocks go backward or forward.",
          "createdAt": "2023-03-01T21:09:05Z",
          "updatedAt": "2023-03-01T21:09:37Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "NONE",
          "body": "If all we care about is the duration of events, why not log the first event at time zero and go from there? Then we avoid any synchronization issues. The frequency control should be 10ppm or better just about everywhere so there's not any real sync issues with any monotonic clock.  ",
          "createdAt": "2024-07-25T20:03:46Z",
          "updatedAt": "2024-07-25T20:03:46Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The use case for timestamps varies. I believe some folks like the ability to log a timestamp value that can, on its own, be converted into a full date. Whereas for quiche, we already do everything using a monotonic clock, so using a timestamp relative to log start time is useful. With the changes proposed on https://github.com/quicwg/qlog/pull/433 I think we can more accurately support all use cases.",
          "createdAt": "2024-07-31T15:50:16Z",
          "updatedAt": "2024-07-31T15:50:16Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "With #433 merged, I'm closing this issue as completed.",
          "createdAt": "2024-10-21T19:48:19Z",
          "updatedAt": "2024-10-21T19:48:19Z"
        }
      ]
    },
    {
      "number": 199,
      "id": "I_kwDOCrLn6M5GAuJ1",
      "title": "Take a long hard look at QPACK events",
      "url": "https://github.com/quicwg/qlog/issues/199",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "lnicco"
      ],
      "labels": [],
      "body": "At the moment, the QPACK events very closely mimic the QPACK instructions as defined in the draft (Or at least, they should... the current definitions are somewhat outdated wrt the final QPACK draft, mostly in terms of naming).\r\n\r\nHowever, to my knowledge, not a single QPACK implementation has actually implemented qlog output. Additionally, the QPACK instructions are likely not the easiest to understand or use for debugging outside of the key QPACK implementers. Put differently: higher-level events (e.g., indicating when things were HOL blocked on QPACK, when `SETTINGS_QPACK_BLOCKED_STREAMS` or `SETTINGS_QPACK_MAX_TABLE_CAPACITY` are reached, when errors occur, when a header is added/removed to the dynamic table, etc.) might be more interesting overall. \r\n\r\nThis would however require someone with considerable QPACK experience to come in an help define these events, preferably in tandem with a QPACK/H3 implementation also outputting qlog events for this. CC @afrind ",
      "createdAt": "2022-03-20T15:53:06Z",
      "updatedAt": "2023-12-09T21:01:19Z",
      "closedAt": "2023-12-09T21:01:18Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "I think the kind of blocked events you are talking about are the most likely to be of general use, since one doesn't really need to be a QPACK expert to understand that latency at the HTTP layer is being introduced because of a QPACK dependency. \r\n\r\nI can also imagine somewhat more detailed error information being useful when QPACK hits an error.\r\n\r\nWe had a jump in QPACK errors last year that required a significant bit of debugging (and as you note, we don't have QPACK QLOG events).  I'm trying to recall the debugging steps and I think it might have been helpful to have every QPACK instruction logged at both the encoder and decoder.  To exonerate QPACK in this instance, the issue turned out to be transport related.  However, this is likely to be produce a lot of data that is not generally useful, and can be especially sensitive for PII reasons compared to generic QLOG transport data.  So I can see implementations not using this detailed mode all the time or by default.",
          "createdAt": "2022-03-21T09:24:17Z",
          "updatedAt": "2022-03-21T09:24:17Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "**A proposal for QPACK events** -- @afrind \r\n\r\nThe current QLOG events for QPACK focus on 3 main event types: \r\n\r\nHeader block encoded/decoded, state updates, and raw instructions.\r\n\r\nThe most common reasons to examine QPACK interactions in detail are to investigate correctness or performance issues. This is a proposal for a restructuring of the QPACK events to represent higher level conditions that would be most useful to that end, rather than a pure instruction-by-instruction log.\r\n\r\nWe also propose an event with a summary of QPACK stats for the whole connection.\r\n\r\n--- \r\n**Encoder Events:**\r\n\r\n* **Encoded a field section block**:\r\n\r\n      [required] Application bytes\r\n      [required] Compressed bytes sent\r\n           In this block\r\n           On the encoder stream, directly attributable to this block\r\n      [required] Number of field lines in the block\r\n      [required] Blocking Risk (bool) \u2013 (references an unacknowledged dynamic table entry)\r\n      Number of dynamic table inserts triggered by encoding this block\r\n      Number of Static table references (names & values)\r\n      Number of Static table name references with literal values\r\n      Number of Dynamic table references (names & values)\r\n      Number of Dynamic table name references with literal values\r\n      Number of entries with literal names and values\r\n      Number of application bytes sent as literals\r\n      Number of bytes sent as huffman literals (To compute compression ratio from huffman)\r\n      Minimum dynamic table reference\r\n      Maximum dynamic table reference\r\n\r\n\r\n* **Blocked Insertion**: Wanted to insert an entry into the dynamic table, but eviction was blocked due to unacknowledged references\r\n \r\n* **Avoided Reference**: Wanted to reference an older entry in the dynamic table but chose not to because doing so might result in blocking future evictions\r\n\r\n* **Blocked Reference**: Wanted to reference the dynamic table but reached max blocking\r\n\r\n* **Encoder Stream Flow Control Blocked**: Ran out of Encoder Stream flow control\r\n\r\n--- \r\n**Decoder Events:**\r\n\r\n* **Decoded a field section block:**\r\n\r\n      [required] Application bytes\r\n      [required] Compressed bytes received in this block\r\n      [required] Number of field lines in this block\r\n      Number of dynamic table inserts triggered by encoding this block\r\n      Number of Static table references (names & values)\r\n      Number of Static table name references with literal values\r\n      Number of Dynamic table references (names & values)\r\n      Number of Dynamic table name references with literal values\r\n      Number of entries with literal names and values\r\n      Number of application bytes sent as literals\r\n      Number of bytes sent as huffman literals (To compute compression ratio from huffman)\r\n      Queue time (how long blocked waiting for dynamic table)\r\n\r\n* **Decoding Blocked**: Received block that could not be decoded because it depends on dynamic table entries that have not arrived\r\n\r\n* **Insert Count Increment**: - indicates delayed block arrival or processing, or speculative inserts\r\n\r\n---\r\n**Connection End Event (summary):**\r\n\r\nShould have an encoder and decoder section\r\n\r\n    Total application header bytes\r\n    Total compressed header bytes sent or received (including encoder/decoder bytes)\r\n    Num Static table name/value references \r\n    Static table name references \r\n    Dynamic table name/value references\r\n    Dynamic table name references\r\n    Num insertions\r\n    Num evictions\r\n    Num duplications\r\n    [optional] QPACK Connection Error Detail\r\n    [encoder only] Num blocked insertions\r\n    [decoder only] Num queued decodes\r\n    [decoder only] Total queued decode latency\r\n    [decoder only] Num QPACK Stream Errors\r\n",
          "createdAt": "2023-03-26T20:35:16Z",
          "updatedAt": "2023-03-26T20:35:16Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Dumb question 1 - can these events be generalised to cover HPACK and QPACK? I think the blocking bits probably mean no but figured I'd ask.\r\n\r\nDumb question 2 - what does `Num QPACK Stream Errors` mean? Isn't a single error a terminal problem for the connection, or can there be more than one?",
          "createdAt": "2023-03-27T02:34:49Z",
          "updatedAt": "2023-03-27T02:34:49Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "We looked hard and decided to remove them and let someone else do the work in a separate draft. Closing this now.",
          "createdAt": "2023-12-09T21:01:18Z",
          "updatedAt": "2023-12-09T21:01:18Z"
        }
      ]
    },
    {
      "number": 200,
      "id": "I_kwDOCrLn6M5GIA_v",
      "title": "TLS alert error code is larger",
      "url": "https://github.com/quicwg/qlog/issues/200",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "lnicco"
      ],
      "labels": [
        "editorial",
        "current-version"
      ],
      "body": "Currently, we define the TLS_ALERT error codes as 0x100 to 0x199, while apparently in RFC9000 it's [0x0100, 0x01ff] (see https://datatracker.ietf.org/doc/html/rfc9000#section-22.5).\r\n\r\nShould be tackled as part of #174.",
      "createdAt": "2022-03-22T09:29:23Z",
      "updatedAt": "2022-09-09T13:38:45Z",
      "closedAt": "2022-09-09T13:38:45Z",
      "comments": []
    },
    {
      "number": 201,
      "id": "I_kwDOCrLn6M5JwOhC",
      "title": "UnknownFrame in QUIC and HTTP/3 events.",
      "url": "https://github.com/quicwg/qlog/issues/201",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "In https://quicwg.org/qlog/draft-ietf-quic-qlog-h3-events.html#appendix-A.3.9 you say\r\n\r\n> HTTP/3 qlog re-uses QUIC's UnknownFrame definition, since their values and usage overlaps\r\n\r\nThis is ambiguous to me. Are you saying the defined object - QUIC `UnknownFrame` - is reused, or that the structure of the object - HTTP/3 `UnknownFrame - is identical.\r\n\r\nI think it has to be the latter, because some HTTP/3 events carry `HTTPFrame`. If this is the case, I would just fully define the frame in the HTTP/3 specification to avoid confusion.",
      "createdAt": "2022-05-16T16:07:33Z",
      "updatedAt": "2022-10-05T14:31:48Z",
      "closedAt": "2022-10-05T14:31:48Z",
      "comments": []
    },
    {
      "number": 202,
      "id": "I_kwDOCrLn6M5JwtXY",
      "title": "Add support for HTTP/3 PRIORITY_UPDATE",
      "url": "https://github.com/quicwg/qlog/issues/202",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This will be RFC soon, I'd like for the HTTP/3 schema to include this event formally. Spec: https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#section-7.2",
      "createdAt": "2022-05-16T17:57:45Z",
      "updatedAt": "2022-09-08T01:45:34Z",
      "closedAt": "2022-09-08T01:45:34Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "An alternative approach might be define this extension frame in it's own very short standalone document",
          "createdAt": "2022-05-23T15:03:03Z",
          "updatedAt": "2022-05-23T15:03:03Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Just say no to extensions. ",
          "createdAt": "2022-09-08T01:45:34Z",
          "updatedAt": "2022-09-08T01:45:34Z"
        }
      ]
    },
    {
      "number": 204,
      "id": "I_kwDOCrLn6M5JxHhI",
      "title": "HTTPStreamType::Data",
      "url": "https://github.com/quicwg/qlog/issues/204",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "What is this type supposed to represent? If it's a request stream, lets just call it that.",
      "createdAt": "2022-05-16T19:28:28Z",
      "updatedAt": "2022-09-28T14:42:56Z",
      "closedAt": "2022-09-28T14:42:56Z",
      "comments": []
    },
    {
      "number": 205,
      "id": "I_kwDOCrLn6M5JxH0_",
      "title": "HTTPStreamType needs an unknown enumeration",
      "url": "https://github.com/quicwg/qlog/issues/205",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "It's possible that a peer would open stream types of unknown type, and not in the reserved range. So let's fix that up.",
      "createdAt": "2022-05-16T19:29:37Z",
      "updatedAt": "2022-09-28T14:45:07Z",
      "closedAt": "2022-09-28T14:45:07Z",
      "comments": []
    },
    {
      "number": 212,
      "id": "I_kwDOCrLn6M5Ofa9N",
      "title": "add ECN events",
      "url": "https://github.com/quicwg/qlog/issues/212",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "discuss",
        "ask-3rd-party"
      ],
      "body": "Endpoints using ECN will perform validation of ECN, as described in https://datatracker.ietf.org/doc/html/rfc9000#section-13.4.2. There are a few different conditions that can lead to a failure of ECN validation, which in turns leads to disabling of ECN for that path. We should have an event that tells us _that_ ECN validation failed and _why_.",
      "createdAt": "2022-07-25T13:41:10Z",
      "updatedAt": "2023-10-22T03:46:39Z",
      "closedAt": "2023-10-22T03:46:39Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This sounds good. I'd like to pull in people with more ECN experience to be part of the discussion. Asking on the list seems like the best way to do that.",
          "createdAt": "2022-09-08T01:47:07Z",
          "updatedAt": "2022-09-08T01:47:07Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed we could use another perspective on this. \r\n\r\nMaybe @huitema has input on this? Probably also @goelvidhi, who's been working with L4S etc. at Apple and also has used qlog?",
          "createdAt": "2022-09-29T14:08:41Z",
          "updatedAt": "2022-09-29T14:08:41Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Yes, having an event stating that ECN negotiation failed would be nice.\r\n\r\nECN negotiation is per path, and whatever logging we do has to reflect that. A connection can migrate from a path that supports ECN to one that does not; nodes are supposed to perform the validation after each migration event, or in the case of multipath after each path setup.\r\n\r\nI don't remember whether we are logging the ECN bits in the \"datagram_sent\" and \"datagram_received\" events. That might be a good idea.\r\n",
          "createdAt": "2022-09-29T15:15:01Z",
          "updatedAt": "2022-09-29T15:15:01Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Another question is how ECN probing works. I haven't managed to come with a good algorithm yet (that's why quic-go isn't sending ECN marks). \r\nDo you start the handshake with ECN marks, run into a timeout, conclude that ECN is blackholed, and restart the handshake? Or do you occasionally send packets with ECN marks after handshake completion, and switch on ECN marking once you've received an ACK for such a probe packet? That would be very similar to the DPLPMTUD probing logic.",
          "createdAt": "2022-09-30T09:26:21Z",
          "updatedAt": "2022-09-30T09:26:21Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I managed to sync with @goelvidhi during the last IETF meeting. The ECN validation mechanism described in A.4 of RFC 9000 apparently is sound, and can be safely implemented with little modifications.\r\n\r\nGiven that ECN probing is a state machine, it would make sense to log it as such:\r\n```\r\necn_state_updated {\r\n   new ECNState\r\n   ? old ECNState\r\n}\r\n\r\nECNState = {\r\n    \"testing\" / \"unknown\" / \"failed\" / \"capable\"\r\n}\r\n```\r\n\r\nMaybe we should also add a state before \"testing\", as I think it's a valid implementation strategy to not bother with ECN during the handshake, and only apply ECN markings after completion of the handshake.\r\n\r\n---\r\n\r\nRegarding L4S / Prague, there will be more details needed on this event. Given that these are still draft / experimental RFCs, maybe we can punt this though?",
          "createdAt": "2023-08-11T16:06:26Z",
          "updatedAt": "2023-08-11T16:06:26Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree with punting details for L4S / Prague to later documents. But, as I mentioned on the PR, I would make the ECN field contents explicitly extensible already.",
          "createdAt": "2023-08-14T09:11:43Z",
          "updatedAt": "2023-08-14T09:11:43Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "Sorry for late reply. But I don't think L4S/Prague should be punted. Even though the RFCs are experimental, L4S is getting deployed (with Apple shipping it and Comcast currently doing user trials). ",
          "createdAt": "2023-08-16T23:53:41Z",
          "updatedAt": "2023-08-16T23:53:41Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I think we need to see implementer interest in adding qlog support for l4s / Prague. The qlog editor team doesn't have enough expertise and we need to prioritize the work we already have left to do.",
          "createdAt": "2023-08-17T03:06:40Z",
          "updatedAt": "2023-08-17T03:06:40Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree with Lucas here. I agree L4S is useful of course (and congrats on the live experiments!), but if people want it in qlog it should be an extension, not part of the core documents at this point. ",
          "createdAt": "2023-08-17T08:52:21Z",
          "updatedAt": "2023-08-17T08:52:54Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi Do we need anything special for L4s? As far as my limited understanding goes, the only thing required on the wire is using the other ECT code point, which we can already encode when this PR is merged.\r\n\r\nWhere we'd need additional events is when we want to log events specific to the Prague state machine (that don't map to NewReno). But this is a problem that already exists today, for example, the qlog documents don't tell you how to log BBR events.",
          "createdAt": "2023-08-17T09:01:12Z",
          "updatedAt": "2023-08-17T09:01:12Z"
        }
      ]
    },
    {
      "number": 216,
      "id": "I_kwDOCrLn6M5RfCDy",
      "title": "Use QUIC and H3 RFCS",
      "url": "https://github.com/quicwg/qlog/issues/216",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "qlog alreaady refers to the -34 drafts. Nominally this change should be easy. Although some section references might need double checking.",
      "createdAt": "2022-09-08T23:24:35Z",
      "updatedAt": "2022-09-09T13:34:22Z",
      "closedAt": "2022-09-09T13:34:22Z",
      "comments": []
    },
    {
      "number": 218,
      "id": "I_kwDOCrLn6M5RfGNM",
      "title": "Gratuitous use of \"Note:\"",
      "url": "https://github.com/quicwg/qlog/issues/218",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "There's almost 60 notes spread across the three documents. This is too many.\r\n\r\nI suspect some of these are note to author, and should be resolved with due process. However, many just seem to be prose that applies directly to the subject matter. Qlog is a bit odd in so far as it's a data scheme definition with few normative requirements but I don't think that warrents us explicitly marking things as notes. Let's just write clear text inside.",
      "createdAt": "2022-09-08T23:56:11Z",
      "updatedAt": "2023-06-07T14:12:43Z",
      "closedAt": "2023-06-07T14:12:43Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed. I could use a \"how to write prose for IETF documents\"-guide though. Does something like that exist?",
          "createdAt": "2022-09-29T13:59:12Z",
          "updatedAt": "2022-09-29T13:59:12Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "There's RFC editor pages like https://www.rfc-editor.org/styleguide/ which has some links to things like https://www.rfc-editor.org/rfc/rfc7322.txt. But I suspect they don't target the kind of advice you're aiming for. Style comes from borrowing from other comtemporary drafts, and taking suggestions from co-editors, the WG, the IETF and the RFC editor.\r\n\r\nIf these notes would be similar to footnotes in a book, it probably isn't acceptable to readers open a blank chapter and see multiple footnotes. Putting normative statements in RFC notes just seems bad, because they could be missed or ignored by a reader.\r\n\r\nA quick win is remove all `note:` prefixes unless they specifically relate to an editorial or design matter with the document. Then convert all editorial or design notes into actual issues before deleting them.",
          "createdAt": "2022-09-29T14:56:37Z",
          "updatedAt": "2022-09-29T14:56:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Furthermore, a subjective opinion is that an RFC doesn't need to justify every decision in the document. \r\n\r\nSo take for example these notes from https://quicwg.org/qlog/draft-ietf-quic-qlog-quic-events.html#section-3.3.15\r\n\r\n> Note: we do not for example use a \"direction\" field (with values \"up\" and \"down\") to specify the data flow. This is because in some optimized implementations, data might skip some individual layers. Additionally, using explicit \"from\" and \"to\" fields is more flexible and allows the definition of other conceptual \"layers\" (for example to indicate data from QUIC CRYPTO frames being passed to a TLS library (\"security\") or from HTTP/3 to QPACK (\"qpack\")).\r\n\r\n> Note: this event type is part of the \"transport\" category, but really spans all the different layers. This means we have a few leaky abstractions here (for example, the stream_id or stream offset might not be available at some logging points, or the raw data might not be in a byte-array form). In these situations, implementers can decide to define new, in-context fields to aid in manual debugging.\r\n\r\nThis could possibly be simplified down to a statement like:\r\n\r\n> The data_moved event is defined in the transport category but the \"from\" and \"to\" fields can be extended with values to provide flexibility for logging data movements between layers that don't involve the transport. For example, moving data between the HTTP/3 and QPACK components that both reside in the application layer.",
          "createdAt": "2022-09-29T15:06:11Z",
          "updatedAt": "2022-09-29T15:06:11Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Removed 99% of `note:`s as they stick out. We can fix more-specific concerns as followup",
          "createdAt": "2023-06-07T14:12:41Z",
          "updatedAt": "2023-06-07T14:12:41Z"
        }
      ]
    },
    {
      "number": 220,
      "id": "I_kwDOCrLn6M5RfKVT",
      "title": "State document structure more accurately",
      "url": "https://github.com/quicwg/qlog/issues/220",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In qlog and h3 event definitions, there's a pattern in section 2 to say \"each subsecion and subsubsection defines xyz\". However, the definitions are actually in section 3. Suggest that we make this more accurate.",
      "createdAt": "2022-09-09T00:24:26Z",
      "updatedAt": "2023-06-07T14:11:05Z",
      "closedAt": "2023-06-07T14:11:04Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed in the editor's meeting yesterday, it should indeed be made clearer how (sub)section names map to event names etc. without it being (purely) implicit in the document structure.\r\n\r\nI think your existing PRs #226 and #237 go a ways towards that @LPardue. \r\n\r\nI would maybe argue we should also either add an explicit entry/comment for each of the events showing its full serialized name (e.g., the `version_information` Section in quic-events would have an explicit indication saying it's `name` field should be `transport:version_information`). Though maybe that's overkill if we list it in a \"TOC\" and make the text mentioned in this issue clearer ?",
          "createdAt": "2022-09-29T13:52:57Z",
          "updatedAt": "2022-09-29T13:52:57Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I think things are ok in editors copy. Closing and will make new issues for more specific concerns,",
          "createdAt": "2023-06-07T14:11:04Z",
          "updatedAt": "2023-06-07T14:11:04Z"
        }
      ]
    },
    {
      "number": 221,
      "id": "I_kwDOCrLn6M5RfLV_",
      "title": "Putting event data definitions in the appendix doesn't feel right",
      "url": "https://github.com/quicwg/qlog/issues/221",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This also relates to https://github.com/quicwg/qlog/issues/220\r\n\r\nIn both the QUIC and H3 documents, the interesting data of each event is defined in the appendix. Typically, appendicesare used for only additional or informative content. \r\n\r\nSince the data is part of the normative schema, I'd suggest the definitions need to be promoted into the main body of the text.",
      "createdAt": "2022-09-09T00:32:11Z",
      "updatedAt": "2022-10-24T15:50:36Z",
      "closedAt": "2022-10-24T15:50:36Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed this shouldn't be in appendix.\r\n\r\nDo want to keep the data definitions together though, instead of e.g., defining each where they are first used in an event. \r\n\r\nSince you are splitting the event categories into a Section per Category @LPardue, would this mean 1 new top-level Section for the data definitions (so just lift them up from appendices as they are) or split out more? ",
          "createdAt": "2022-09-29T13:49:04Z",
          "updatedAt": "2022-09-29T13:49:04Z"
        }
      ]
    },
    {
      "number": 229,
      "id": "I_kwDOCrLn6M5RrX-9",
      "title": "Section on I-JSON seems to confusingly redefine uint64",
      "url": "https://github.com/quicwg/qlog/issues/229",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "editorial"
      ],
      "body": "The section on I-JSON notes serialization concerns about 64-bit numbers that might be required for protocols like QUIC or HTTP/3.\r\n\r\nIt then says:\r\n\r\n> Concretely, the following definition of uint64 should override the original and (web-based) tools should take into account that a uint64 field can be either a number or string.\r\n\r\n> uint64 = text / uint .size 8\r\n\r\nI find this confusing. This document defines a custom `unit64` itself. It's not entirely clear when the above override applies or not.",
      "createdAt": "2022-09-12T18:13:17Z",
      "updatedAt": "2024-02-19T09:25:00Z",
      "closedAt": "2024-02-19T09:25:00Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree it can be confusing. \r\n\r\nThe intent is to say that, when outputting qlog intended for web browser-based tools (like qvis), implementers MAY also use text instead of uint when encoding uint64 values, because of the I-JSON restrictions.\r\n\r\nSimilarly, web based tool builders SHOULD take into account that uint64 values can be encoded as text values. \r\n\r\nI'm not sure how to best alter the text to make that clearer though...",
          "createdAt": "2022-09-16T15:00:47Z",
          "updatedAt": "2022-09-16T15:00:47Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The constraints make sense, I just think they could be missed by implementers, which might be unfortunate. \r\n\r\nTo match that intent, maybe it would be clearer to put the optionalilty only in the single definition of uint64 in Section 1.1.1 and explain to people the considerations in user integer types with respect to serialization. Something like\r\n\r\n> Serialization formats and/or serialization/parsing implementations may not be able to handle the full range of values permitted by a 64-bit number. For example, JavaScript without BigInt extensions supports a maximum value of (2**53)-1; see Appendix E of [CDDL]. Some protocols, such as QUIC and HTTP/3, support integer values up to (2^62)-1. In order to represent these large values in qlog, the value can be encoded as a string.\r\n\r\nStructured fields describes the constraint in a similar way - https://www.rfc-editor.org/rfc/rfc8941.html#section-3.3.1-6",
          "createdAt": "2022-09-16T15:26:19Z",
          "updatedAt": "2022-09-16T15:26:19Z"
        }
      ]
    },
    {
      "number": 230,
      "id": "I_kwDOCrLn6M5RrarD",
      "title": "Restating CDDL syntax is not necessarily a good thing",
      "url": "https://github.com/quicwg/qlog/issues/230",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "In the main schema document, there's a a chunk of text that says:\r\n\r\n> The main general CDDL syntax conventions in this document a reader should be aware of for easy reading comprehension are:\r\n>\r\n> // list of things\r\n\r\nThe danger with restating things like this is that there is some subtle problem or incompatibility with the canonical CDDL source citation. I appreciate the QUIC WG might not be familiar with this syntax, so it's handy. But the long-term problems a more insidious. Consider replacing it with deep links to CDDL syntax, or sticking it behind a note that it will be removed prior to publication.",
      "createdAt": "2022-09-12T18:23:05Z",
      "updatedAt": "2022-10-05T14:45:24Z",
      "closedAt": "2022-10-05T14:45:24Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, the intent is to remove this prior to publication. It's just there to make early adoption easier for now. \r\n\r\nWill look up how to properly add such a note (not sure if there's something default in the kramdown for that) and add it.",
          "createdAt": "2022-09-16T15:02:05Z",
          "updatedAt": "2022-09-16T15:02:05Z"
        }
      ]
    },
    {
      "number": 233,
      "id": "I_kwDOCrLn6M5RrnHD",
      "title": "Gratuitous use of \"we\"",
      "url": "https://github.com/quicwg/qlog/issues/233",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Across the qlog docs, there's ~50 instances of the word \"we\", compared to 1 in RFC 9000.\r\n\r\nWe (pun intended) need to rephrase the specification to move away from that style. \r\n\r\nFor example,\r\n\r\n> To aid in this decision making, we recommend that each event SHOULD have an\r\n\"importance indicator\" with one of three values, in decreasing order of importance\r\nand expected usage:\r\n\r\ncan be rewritten as\r\n\r\n> To aid in this decision making, each event SHOULD have an\r\n\"importance indicator\" with one of three values, in decreasing order of importance\r\nand expected usage:\r\n\r\nOr, this example\r\n\r\n> ; but for many protocol fields we want to be more restrictive\r\n; and explicit\r\n\r\ncan be rewritten as\r\n\r\n> but many qlog fields benefit from more restrictive integer types\r\n\r\nPS. a lot of these are in text that might be due to the cutting room floor anyway. But tidying up the style sooner everywhere is a faster way to resolve the problem while we think about what to keep or cut.",
      "createdAt": "2022-09-12T19:07:23Z",
      "updatedAt": "2023-06-07T13:55:26Z",
      "closedAt": "2023-06-07T13:55:26Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I of course fully agree. A lot of the prose is written in faux academic paper style and should be updated to RFC-style. I could definitely use some pointers on how to best approach that, and the examples above help with that!",
          "createdAt": "2022-09-16T14:44:41Z",
          "updatedAt": "2022-09-16T14:44:41Z"
        }
      ]
    },
    {
      "number": 236,
      "id": "I_kwDOCrLn6M5SEQy6",
      "title": "HTTPStreamType: why do we have an `old` and a `new` fields? .",
      "url": "https://github.com/quicwg/qlog/issues/236",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Sorry if that's a stupid question, but why do we have an `old` and a `new` field here? I thought you can only set it once.\r\n\r\n_Originally posted by @marten-seemann in https://github.com/quicwg/qlog/pull/227#pullrequestreview-1111456120_",
      "createdAt": "2022-09-17T18:57:41Z",
      "updatedAt": "2022-10-05T14:30:22Z",
      "closedAt": "2022-10-05T14:30:22Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is a fair question.\r\n\r\nThis is most likely a copy-paste from one of the `*Updated` events (can't find evidence that this was once called StreamTypeUpdated though...)\r\n\r\nFor updates this makes sense, but if the StreamType is only ever set once after becoming known, it would be better to change the definition to e.g., (note, `raw_stream_type` is from #227) :\r\n\r\n```\r\nHTTPStreamTypeSet = {\r\n    ? owner: Owner\r\n    stream_id: uint64\r\n\r\n    stream_type: HTTPStreamType\r\n    ? raw_stream_type: uint64\r\n\r\n    ; only when stream_type === \"push\"\r\n    ? associated_push_id: uint64\r\n}\r\n```\r\n",
          "createdAt": "2022-09-28T12:51:33Z",
          "updatedAt": "2022-09-28T12:51:33Z"
        }
      ]
    },
    {
      "number": 239,
      "id": "I_kwDOCrLn6M5Sz3XJ",
      "title": "Clean up connection states in connection_state_updated",
      "url": "https://github.com/quicwg/qlog/issues/239",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "This QUIC event currently has a long list of possible connection states (both \"simple\" and \"full\"), but it hasn't been validated if these states are correct/logical wrt the final RFCs (list has been in there for a long while since early drafts). \r\n\r\n```\r\nConnectivityConnectionStateUpdated = {\r\n    ? old: ConnectionState / SimpleConnectionState\r\n    new: ConnectionState / SimpleConnectionState\r\n}\r\n\r\nConnectionState =\r\n    ; initial sent/received\r\n    \"attempted\" /\r\n    ; peer address validated by: client sent Handshake packet OR\r\n    ; client used CONNID chosen by the server.\r\n    ; transport-draft-32, section-8.1\r\n    \"peer_validated\" /\r\n    \"handshake_started\" /\r\n    ; 1 RTT can be sent, but handshake isn't done yet\r\n    \"early_write\" /\r\n    ; TLS handshake complete: Finished received and sent\r\n    ; tls-draft-32, section-4.1.1\r\n    \"handshake_complete\" /\r\n    ; HANDSHAKE_DONE sent/received (connection is now \"active\", 1RTT\r\n    ; can be sent). tls-draft-32, section-4.1.2\r\n    \"handshake_confirmed\" /\r\n    \"closing\" /\r\n    ; connection_close sent/received\r\n    \"draining\" /\r\n    ; draining period done, connection state discarded\r\n    \"closed\"\r\n\r\nSimpleConnectionState =\r\n    \"attempted\" /\r\n    \"handshake_started\" /\r\n    \"handshake_confirmed\" /\r\n    \"closed\"\r\n```\r\n\r\nUnlike for [Stream states](https://www.rfc-editor.org/rfc/rfc9000.html#name-stream-states) there doesn't seem to be a clear flow graph for Connection states in RFC9000, so it's not easy to distill something \"RFC-esque\". \r\n\r\nMy gut feeling would be to just keep the SimpleConnectionState and remove the rest, but that does miss some info...\r\n\r\nThis could use input from someone with deployment experience that wants to track connection state in this way. CC @LPardue @marten-seemann @lnicco ",
      "createdAt": "2022-09-28T13:05:45Z",
      "updatedAt": "2024-06-28T15:08:47Z",
      "closedAt": "2024-06-28T15:08:47Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Seems like the qlog crate didn't implement this properly, at the time of writing I only support the `ConnectionState` type. We don't actually generate any connectivity event types is quiche yet but could in future. If we did, I suspect having the option to log a value from `ConnectionState` would be useful. Especially the draining to closed transition, which seems to catch people out.\r\n\r\nI'd probably be in favor of a single `ConnectionState` type and we can bikeshed some more on what values are actually kept inside that. Having both types seems odd, especially as one is a subset of the other.",
          "createdAt": "2022-09-28T13:18:42Z",
          "updatedAt": "2022-09-28T13:18:42Z"
        }
      ]
    },
    {
      "number": 241,
      "id": "I_kwDOCrLn6M5Sz_HT",
      "title": "Check that we can log version mismatch errors appropriately",
      "url": "https://github.com/quicwg/qlog/issues/241",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As noted in https://github.com/quicwg/qlog/pull/138#issuecomment-801995115, version mismatch problems causing a connection close are logged in 3 ways currently:\r\n\r\n1. with a `version_mismatch` trigger value in `connection_closed`\r\n2. by logging the on the wire versions in `packet_sent` and `packet_received` `.supported_versions`\r\n3. by emitting a separate `version_information` event grouping both external and internal (see below)\r\n\r\n```\r\nTransportVersionInformation = {\r\n    ? server_versions: [+ QuicVersion]\r\n    ? client_versions: [+ QuicVersion]\r\n    ? chosen_version: QuicVersion\r\n}\r\n```\r\n\r\nThis feels clunky, but probably gets the job done, with 1 proposed change:\r\nCurrently QuicVersion is defined as `: hexstring` and I would define it as `: hexstring / \"none\"` to support the mismatch case explicitly in that event as well (currently you'd omit the `chosen_version` field to signal the same). \r\n\r\nAnother change we could do is to add `? supported_versions: [+ QuicVersion]` to the `server_listening` event to make it more explicit which versions a server supports at startup (currently no real way to indicate that). Not sure this is crucial though.\r\n\r\n-------------------\r\n\r\nOne of the main points however is that I'm not sure this:\r\n\r\n1. allows logging of all the possible flows with the [VersionNegotiation extension ](https://www.ietf.org/archive/id/draft-ietf-quic-version-negotiation-10.html). Maybe someone who's implemented that logic can give some insight? CC @huitema\r\n \r\n2. should even be an issue for the qlog documents (as we're [leaning towards](https://github.com/quicwg/qlog/issues/124#issuecomment-1240048715) having separate qlog documents for separate QUIC features/extensions). CC @LPardue \r\n\r\n\r\n\r\n",
      "createdAt": "2022-09-28T13:25:39Z",
      "updatedAt": "2024-06-24T15:20:35Z",
      "closedAt": "2024-06-24T15:20:34Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "We closed the PR that was linked to this (https://github.com/quicwg/qlog/pull/138) so can we just close the issue? ",
          "createdAt": "2023-12-09T23:30:27Z",
          "updatedAt": "2023-12-09T23:30:27Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looking into it a bit more, I think the canonical way for this can (should) indeed just be:\r\n\r\n1. Log `TransportVersionInformation` **without** the `chosen_version` field set\r\n2. Log `connection_closed` with a trigger value of `version_mismatch`\r\n\r\nGiven that we're not explicitly supporting https://datatracker.ietf.org/doc/rfc9368/ and that this can easily be added by adding a new transport parameter (which is now perfectly possible with #417), I will indeed close with no action now. \r\n\r\n\r\n",
          "createdAt": "2024-06-24T15:20:35Z",
          "updatedAt": "2024-06-24T15:20:35Z"
        }
      ]
    },
    {
      "number": 242,
      "id": "I_kwDOCrLn6M5S0nSQ",
      "title": "revisit old / new fields in various events",
      "url": "https://github.com/quicwg/qlog/issues/242",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "One might argue that having an `old` field doesn\u2019t make any sense, since you can just have a look at the last event to see what the value was.\r\n\r\nWe should consider removing the `old` field (and maybe renaming the `new` field).",
      "createdAt": "2022-09-28T15:03:56Z",
      "updatedAt": "2024-02-19T09:16:14Z",
      "closedAt": "2024-02-19T09:16:14Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For context: I chose the old/new approach for `*Updated` events because:\r\n\r\n1. You often start with a \"default\" value (e.g., for MTU) that you update later, but you wouldn't log the initial value (as that's part of the standard config), or at least not as an `Updated` event (though you -should- in that case)\r\n2. When streaming logs in e.g., a \"ring buffer\" style, you might loose earlier events, making it impossible to track full history. Having both old and new in 1 event would help with this. This is a use case sometimes mentioned by @nibanks \r\n\r\nOne of the main things I dislike is the naming of the `new` field. It would be nicer to have a name matching the semantics better (e.g., `stream_state` instead of `new` in `stream_state_updated` event). \r\n\r\nAt this time, I don't have a strong preference for keeping old/new or changing to another scheme. ",
          "createdAt": "2022-09-29T12:36:51Z",
          "updatedAt": "2022-09-29T12:36:51Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I assume my answer was satisfactory @marten-seemann? I'm still in favor of keeping the ability to log older values though, and lacking a better proposal, I'll close this for now.",
          "createdAt": "2024-02-19T09:16:14Z",
          "updatedAt": "2024-02-19T09:16:14Z"
        }
      ]
    },
    {
      "number": 243,
      "id": "I_kwDOCrLn6M5S5fT2",
      "title": "Properly use RawInfo everywhere",
      "url": "https://github.com/quicwg/qlog/issues/243",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "Currently, most events use `RawInfo`, but some still use a separate `raw: hexstring` + `raw_length: uint32` setup. \r\n\r\n1. Figure out why (probably just forgot to update all when making the change)\r\n2. Change to `RawInfo` where appropriate, or add comment why `RawInfo` isn't used",
      "createdAt": "2022-09-29T12:39:17Z",
      "updatedAt": "2023-01-19T10:56:50Z",
      "closedAt": "2023-01-19T10:56:50Z",
      "comments": []
    },
    {
      "number": 246,
      "id": "I_kwDOCrLn6M5TouXl",
      "title": "Should congestion_state_updated define some values for old and new?",
      "url": "https://github.com/quicwg/qlog/issues/246",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "congestion_state_updated fields include an `old` and `new` field that takes a `text` type. The prose that explains this event includes examples \"slow_start, congestion_avoidance, application_limited, recovery\"\r\n\r\nPerhaps we should make these actual values in CDDL, add the BBR CC phases, and support general text too.",
      "createdAt": "2022-10-10T13:31:01Z",
      "updatedAt": "2024-03-06T10:32:19Z",
      "closedAt": "2024-03-06T10:32:19Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, from this recent discussion https://github.com/quicwg/qlog/issues/377 it seems @LPardue might not hold the same opinion anymore as he did 2 years ago when asking for this? :) \r\n\r\nI agree with the newer view that it doesn't make too much sense to define congestion control names/parameter values/phases/etc. because they're often different between implementations.\r\n\r\nPropose to close this issue without action. ",
          "createdAt": "2024-03-04T14:44:24Z",
          "updatedAt": "2024-03-04T14:44:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I can live with this. However, I think we should adjust the examples to talk about abstract events rather than use strings. The reason being that the values suggest something that is standard, when we explicitly aren't doing that. So in other words let's talk about Slow Start and Application limited but refrain from using stingified renderings of them",
          "createdAt": "2024-03-04T15:19:57Z",
          "updatedAt": "2024-03-04T15:19:57Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Took a stab at this at https://github.com/quicwg/qlog/pull/408. PTAL @LPardue ",
          "createdAt": "2024-03-04T15:44:46Z",
          "updatedAt": "2024-03-04T15:44:46Z"
        }
      ]
    },
    {
      "number": 250,
      "id": "I_kwDOCrLn6M5UDfsG",
      "title": "Remove the Design Variations sections",
      "url": "https://github.com/quicwg/qlog/issues/250",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "These might have been useful during the document development but as part of an RFC don't seem that helpful, so suggest we remove them.",
      "createdAt": "2022-10-15T15:30:31Z",
      "updatedAt": "2022-10-19T14:32:18Z",
      "closedAt": "2022-10-19T14:32:18Z",
      "comments": []
    },
    {
      "number": 259,
      "id": "I_kwDOCrLn6M5VTmnF",
      "title": "Security and Privacy: general structure and content",
      "url": "https://github.com/quicwg/qlog/issues/259",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "editorial"
      ],
      "body": "The version of the [Security and Privacy Considerations in main-schema-draft-04](https://www.ietf.org/archive/id/draft-ietf-quic-qlog-main-schema-04.html#name-security-and-privacy-consid) was intended to be a first proposal that can be iterated upon.\r\n\r\nIn particular, @martinthomson has already [proposed an alternative approach](https://github.com/quicwg/qlog/pull/252#pullrequestreview-1152379427):\r\n\r\n> This is a lot of text. I like the enumeration of the types of risk, but I fear that the extrapolation from there is both incomplete and a little long-winded.\r\n>\r\n> The focus on anonymization is not one that I would emphasize. I know that [Christian has toyed with the concept](https://huitema.wordpress.com/2020/07/21/scrubbing-quic-logs-for-privacy/), but that was idle speculation, not anything rigorous.\r\n> \r\n> In the end, this text should be very clear that qlog files present a privacy risk to those participating in the connection. They should therefore be treated accordingly. Any notion that these files might be sanitized in a way that might remove that risk should be changed to focus more on defense in depth. That is, look at access control and retention limits as primary means of protection, not anonymization.\r\n> \r\n> I would instead structure this roughly as follows:\r\n> \r\n> - A brief introductory piece.\r\n> - An articulation of the types of privacy risk that might be presented by capture, storage, and use of qlog data. This part is fairly lengthy and could probably be a subsection.\r\n> - A description of the operational implications and potential actions that might be taken first from a security standpoint, then for privacy remediation. qlog files that are records of interactions with peers are data that those peers (or users) potentially have rights over (I like this point, so make it prominently, but do not refer to laws; do not refer to the GDPR especially).\r\n> 1. Access controls required to enable qlog or to expand the information that is captured.\r\n> 2. Access controls required to access stored qlog files.\r\n> 3. Limits to retention of qlog files.\r\n> 4. Finally, observe that limiting what is captured or anonymization might be possible, but that this could either be insufficient from a privacy perspective, reduce the usefulness of the data, or (highly likely) both.\r\n> \r\n> It's easy to focus on the point about not being able to link qlog data with people. But it's safer to treat that as an open research problem than invite implementations and deployments to indulge in amateur research on the topic.\r\n\r\nThis issue serves to collect further thoughts and comments from the WG post IETF-115. It is a continuation of #142. \r\n\r\n_Note that we are explicitly trying to keep this part of the qlog documents quite concise. A deeper investigation on how to properly handle sensitive data in logs is a more general topic that we hope to tackle in the IETF in the near future. These initial qlog docs should provide just enough guidance to make users aware of the risk and to recommend best practices._ \r\n",
      "createdAt": "2022-11-01T10:24:04Z",
      "updatedAt": "2023-12-09T20:58:35Z",
      "closedAt": "2023-12-09T20:58:35Z",
      "comments": []
    },
    {
      "number": 260,
      "id": "I_kwDOCrLn6M5VToPR",
      "title": "Security and Privacy: mentioning user consent and preferences",
      "url": "https://github.com/quicwg/qlog/issues/260",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "The version of the [Security and Privacy Considerations in main-schema-draft-04](https://www.ietf.org/archive/id/draft-ietf-quic-qlog-main-schema-04.html#name-security-and-privacy-consid) contains a discussion on end-user preference and privacy control systems. This was included because a) I found it an important aspect to discuss and b) it mirrors the approach in [RFC6973](https://www.rfc-editor.org/rfc/rfc6973), which I've used initially as a baseline for the section. \r\n\r\nAs @martinthomson noted in [an initial review of that paragraph](https://github.com/quicwg/qlog/pull/252#discussion_r1002779120), we should be quite careful about the terminology here and the recommendations we make. For the text in -04 I already removed direct mentions of things like the GDPR; it's likely other changes are needed to get this text into proper shape. \r\n\r\nRelated to #259. \r\n\r\n",
      "createdAt": "2022-11-01T10:29:27Z",
      "updatedAt": "2023-05-31T20:07:31Z",
      "closedAt": "2023-05-31T20:07:31Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The SECDIR did an early review and did not note any concerns. Closing this issue for now since its easy enough to revist later on.",
          "createdAt": "2023-05-31T20:07:31Z",
          "updatedAt": "2023-05-31T20:07:31Z"
        }
      ]
    },
    {
      "number": 261,
      "id": "I_kwDOCrLn6M5VTvrZ",
      "title": "Approach for CDDL extension points",
      "url": "https://github.com/quicwg/qlog/issues/261",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It is expected that the initial 3 qlog documents will be extended in the future with new events and frames (e.g., for QUIC and H3 extensions like DATAGRAM or Multipath, but also for other protocols like H2, TLS and TCP).\r\n\r\nThe proposed approach is to define these qlog extensions in their own documents (either standalone or integrated into the docs that define the protocol extensions themselves). Ideally, these new documents wouldn't just extend qlog in prose only, but also properly extend the existing CDDL event and data type definitions. \r\n\r\nTo this end, the current documents define a few [CDDL plugs/sockets/extension points](https://www.rfc-editor.org/rfc/rfc8610.html#section-3.9) to make this possible:\r\n- [`$ProtocolEventBody`](https://www.ietf.org/archive/id/draft-ietf-quic-qlog-main-schema-04.html#name-data)\r\n- [`$QuicFrame`](https://www.ietf.org/archive/id/draft-ietf-quic-qlog-quic-events-03.html#name-quic-frames)\r\n- [`$HTTPFrame`](https://www.ietf.org/archive/id/draft-ietf-quic-qlog-h3-events-03.html#name-httpframe)\r\n\r\nHowever, when trying to define [a simple extension for the QUIC and H3 DATAGRAM frames](https://github.com/rmarx/draft-marx-quic-qlog-datagram), I found we might need more extension points, specifically for QUIC Transport Parameters and HTTP SETTINGS (the DATAGRAM RFCs use those to negotiate support). These currently don't exist and the extension document uses some not-really-compatible CDDL at this point. \r\n\r\nWhile it's not a big problem to define new extension points for those two things, it begs the question if that would be enough. Do we need even more extension points down the line (e.g., for the `ConnectionState` in [connection_state_updated](https://www.ietf.org/archive/id/draft-ietf-quic-qlog-quic-events-03.html#name-connection_state_updated)? For `StreamState` in [stream_state_updated](https://www.ietf.org/archive/id/draft-ietf-quic-qlog-quic-events-03.html#name-stream_state_updated)? For data handling points in [data_moved](https://www.ietf.org/archive/id/draft-ietf-quic-qlog-quic-events-03.html#name-data_moved)? For metrics in [metrics_updated](https://www.ietf.org/archive/id/draft-ietf-quic-qlog-quic-events-03.html#name-metrics_updated)? etc.)\r\n\r\nConceptually, we can make EVERYTHING a CDDL extension point, but I'm not sure that's the best approach either. So the real question is: where do we draw the line? and what happens if it turns out we made the wrong decision/missed an important extension point down the line? \r\n\r\nRelated to #176, #170 and #124\r\n",
      "createdAt": "2022-11-01T10:55:45Z",
      "updatedAt": "2024-06-24T13:22:36Z",
      "closedAt": "2024-06-24T13:22:36Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I think we should provide strong support for every formal extension point in the protocols: frames, TPs, settings, error codes, etc.\r\n\r\nThe other type of extension point is for flexibility. qlog is very flexible for new/custom/undefined fields. As an implementer and user of qlog, sometimes I have a need of adding a new ad-hoc enumeration value (say, to StreamState). On the deserialization side, what I want to support the strongly-typed enumeration values and also any adhoc values that might be in there. One way I've though about supporting this is to add an \"any\" field to pretty much everything (probably text, or json). So fields that aren't primitive types end up as field = EnumerationType / any. The deserialization code would then try to match the strong type, and if needed fall back to a generic container holding \"any\", whereby my user-specific application code can manage the adhoc stuff I added.",
          "createdAt": "2022-11-01T12:18:43Z",
          "updatedAt": "2022-11-01T12:18:43Z"
        }
      ]
    },
    {
      "number": 262,
      "id": "I_kwDOCrLn6M5VU78f",
      "title": "Split up HTTP/3 and QPACK into separate documents",
      "url": "https://github.com/quicwg/qlog/issues/262",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, H3 and QPACK events are in the same document. However, they are separate RFCs and (relatively) separate concepts as well. \r\n\r\nFor other related documents, such as RFC9218, we would have a separate qlog document anyway, instead of integrating it into the same doc. \r\n\r\nFinally, editorially it also makes sense to be consistent with the QUIC events doc in terms of structure (now, the H3/QPACK doc already seems like 2 docs appended together in an ad-hoc fashion). \r\n\r\nHowever, arguments can of course also be made to just keep them together as they are somewhat related and we already have 3 base qlog documents without the split. ",
      "createdAt": "2022-11-01T14:45:22Z",
      "updatedAt": "2022-11-30T15:35:56Z",
      "closedAt": "2022-11-30T15:35:56Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I support splitting the documents up. The documents will be short and dry, but that seems fine for specifications defining schema based on other RFCs.",
          "createdAt": "2022-11-01T15:21:17Z",
          "updatedAt": "2022-11-01T15:21:17Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Feedback from the WG meeting session was don't do this to avoid overhead and proliferation of documents.",
          "createdAt": "2022-11-30T15:27:50Z",
          "updatedAt": "2022-11-30T15:27:50Z"
        }
      ]
    },
    {
      "number": 273,
      "id": "I_kwDOCrLn6M5akagV",
      "title": "remove note containing equation to calculate header length",
      "url": "https://github.com/quicwg/qlog/issues/273",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2023-01-04T19:53:14Z",
      "updatedAt": "2024-03-08T15:28:20Z",
      "closedAt": "2024-03-08T15:28:20Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "This also applies to the next note \u201cIn some cases\u2026\u201d",
          "createdAt": "2023-01-04T19:54:33Z",
          "updatedAt": "2023-01-04T19:54:33Z"
        }
      ]
    },
    {
      "number": 275,
      "id": "I_kwDOCrLn6M5bKsGP",
      "title": "Would an is_ack_eliciting flag be helpful for packet_sent events?",
      "url": "https://github.com/quicwg/qlog/issues/275",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This came up in discussion I had with someone about calculating timing between packets that require acks and the packets that ack them. Not all packets are ack-eliciting and although it can be determined by looking at the frames inside a packet, that's potentially a bit labourious. \r\n\r\nThere's prior art here, packet_sent already includes `is_mtu_probe_packet: bool .default false`, which seems like a similar use case.",
      "createdAt": "2023-01-11T18:59:36Z",
      "updatedAt": "2023-11-08T10:25:33Z",
      "closedAt": "2023-11-08T10:25:32Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Not sure if `is_mtu_probe_packet` can be considered prior art. There's no definitive way to tell that a packet is a MTU probe packet without this flag (you can only have heuristics, checking if this packet is larger than the packets sent so far).\r\n\r\nAlso, `is_mtu_probe_packet` would only be set on a very small number of packets per connection (O(1)), whereas `is_ack_eliciting` would be set on O(N) packets.",
          "createdAt": "2023-01-11T21:15:25Z",
          "updatedAt": "2023-01-11T21:15:25Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Fair point. \r\n\r\nI was also thinking that extension frames that are not eliciting and are not supported by tools would also cause those tools to draw the wrong conclusions.\r\n\r\nIf we flipped it and had an optional non-ack-eliciting field, I'd expect the impact to be lessened but still maybe too much for some people to bear.",
          "createdAt": "2023-01-11T21:21:31Z",
          "updatedAt": "2023-01-11T21:21:31Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Given that we're adding things like ack frequency to make ack rates more flexible, I don't think such a field has tremendous value and I'm not hearing anyone else ask. Closing now. Maybe someone wants to revist this as part of future work in a new document.",
          "createdAt": "2023-11-08T10:25:32Z",
          "updatedAt": "2023-11-08T10:25:32Z"
        }
      ]
    },
    {
      "number": 280,
      "id": "I_kwDOCrLn6M5bWNYb",
      "title": "Commentary on H3 frames and data_moved events",
      "url": "https://github.com/quicwg/qlog/issues/280",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The DATA frame section includes some commentary on H3, frames and streams. In reviewing a PR, I made the following observations:\r\n\r\n> This seems like it can be genericised and moved somewhere else: there is no tight coupling between H3 and QUIC frame boundaries meaning a H3 frames could span many packets, or many frames could be in a single packet.\r\n\r\n> Implementations can deploy streaming strategies to any H3 frame parsing. I agree that DATA frames are the most likely, but really any frame could be larger than a packet. \r\n\r\n> Furthermore, due to varint H3 frame fields and the lack of preserved boundaries, some implementations might generate data_moved events before frame_parsed events. Cloudflare quiche does this, for example. \r\n\r\n_Originally posted by @LPardue in https://github.com/quicwg/qlog/pull/274#discussion_r1069621693_\r\n            ",
      "createdAt": "2023-01-13T16:04:17Z",
      "updatedAt": "2024-06-25T09:44:41Z",
      "closedAt": "2024-06-25T09:44:41Z",
      "comments": []
    },
    {
      "number": 281,
      "id": "I_kwDOCrLn6M5bfcHn",
      "title": "Revisit use of datagram_id",
      "url": "https://github.com/quicwg/qlog/issues/281",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, we have a mechanism for tracking QUIC packet coalescing in a single UDP datagram by means of the `datagram_id` field. This was originally added as per #91. \r\n\r\nMain intended use: when a UDP payload is received containing multiple coalesced QUIC packets, those QUIC packets are given the same \"datagram ID\" (which is a receiver-side chosen number that's unique per received datagram, which is needed because UDP datagrams don't have a packet number or similar). As such, when 2 separate packets are logged in 2 separate `packet_received` events, but they have the same value for the `datagram_id` field, it's clear they were coalesced. Similarly, 2 `packet_sent` events with the same `datagram_id` indicate sender-side coalescing. \r\n\r\nAs the original issue #91 indicates, this can be deduced from the `datagram_*` events as well, but those are often too chatty to leave on. The `datagram_ids` fields on the `datagram_*` events are for completeness / ability to track coalesced packets across the different events. \r\n\r\nI'm personally not the biggest fan of this solution (did you eventually implement this in quic-go, @marten-seemann?), but I don't immediately see a better approach.\r\n\r\nCC @LPardue as he indicated the use of `datagram_id` wasn't clear to him, which means we either need to revisit or clarify its use.",
      "createdAt": "2023-01-16T13:46:43Z",
      "updatedAt": "2023-03-02T09:57:38Z",
      "closedAt": "2023-03-02T09:57:38Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I'll try to summarise my understanding. \r\n\r\nThe `datagram_id` is specified for the following events\r\n\r\n* packet_sent\r\n* packet_received\r\n* packet_buffered\r\n* packet_dropped\r\n* datagrams_sent (an array here, but same purpose)\r\n* datagrams_received (an array here, but same purpose)\r\n\r\nThe use of the ID is given in https://quicwg.org/qlog/draft-ietf-quic-qlog-quic-events.html#name-datagrams_sent and currently says:\r\n\r\n> Note: QUIC itself does not have a concept of a \"datagram_id\". This field is a purely qlog-specific construct to allow tracking how multiple QUIC packets are coalesced inside of a single UDP datagram, which is an important optimization during the QUIC handshake. For this, implementations assign a (per-endpoint) unique ID to each datagram and keep track of which packets were coalesced into the same datagram. As packet coalescing typically only happens during the handshake (as it requires at least one long header packet), this can be done without much overhead.\r\n\r\nI don't mind the motivating use case. I'm not sure exactly how my implementations could use it for packet sending events because we generate the packet and qlog it before we get into UDP datagram realms. Changes might address that but I'm not sure it's worth overhead. Other implementations might find it far more natural to use though.\r\n\r\nThe main part I find confusing is the part about `implementations assign a per-endpoint unique ID`. This is vague and quite specific at the same time. How unique does something need to be? Can I just use a counter like datagram_id = 0, datagram_id=1 for the packets sent on a connection? Or is the expectation that the identifier is more like a UUID, so that  packets are uniquely traceable? Maybe it depends if we are capturing single connections or traces that span mutliple things, so perhaps a reword to state the requirements and expectations of the datagram_id value could help. E.g. \"Since QUIC traces may contain many UDP events, unique identifiers are required for each datagram in order to avoid them being confused. Identifiers are not exchanged on the wire, they are only relevant to the logging endpoint. Selecting identifier values is left to implementations that should consider how to generate unique values within the scope of the traces they generate\"",
          "createdAt": "2023-01-16T15:35:38Z",
          "updatedAt": "2023-01-16T15:35:38Z"
        }
      ]
    },
    {
      "number": 283,
      "id": "I_kwDOCrLn6M5blUhK",
      "title": "Versioning for additional schema",
      "url": "https://github.com/quicwg/qlog/issues/283",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We presently have 3 documents: main schema, quic schema, HTTP/3 and QPACK schema.\r\n\r\nWe presently have 1 version field `qlog_version` to express changes in any of these documents.\r\n\r\nWe  make efforts to keep these things in lock step, but the relationship is quite implicit and not explicitly stated. That's not brilliant and adds some friction.\r\n\r\nOne proposal I have is to articulate the schema(s) used in the log. I don't think we need to go as far as XML does (e.g. https://www.oreilly.com/library/view/xml-in-a/0596007647/re168.html) but we could just include the I-D or RFC name as a string. Then each additional schema document can express what version of qlog main schema it depends on. I'll write this up as a PR.",
      "createdAt": "2023-01-17T14:48:29Z",
      "updatedAt": "2024-07-08T20:28:11Z",
      "closedAt": "2024-07-08T20:27:12Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed on the call yesterday, everyone generally likes this concept on how to tackle versioning. Additionally, it can help replace `protocol_type` together with #286. \r\n\r\nOne thing I personally did not really love in current PR #284 is that we use a separate approach for the main schema version (indicated via `qlog_version`) and the protocol event defintion versions (indicated via the new `additional_schema` field). Another option would be to treat the main schema as just another one in the list.\r\n\r\nPut differently, this is what the PR currently proposes: \r\n```\r\n\"qlog_version\": \"0.3\",\r\n\"qlog_format\": \"JSON\",\r\n\"additional_schema\": [\r\n  \"draft-ietf-quic-qlog-quic-events-03\",\r\n  \"draft-ietf-quic-qlog-quic-h3-events-03\"\r\n],\r\n```\r\nWhile a more consistent option would be:\r\n```\r\n\"qlog_format\": \"JSON\",\r\n\"qlog_schemas\": [\r\n  \"draft-ietf-quic-qlog-main-schema-04\",\r\n  \"draft-ietf-quic-qlog-quic-events-03\",\r\n  \"draft-ietf-quic-qlog-quic-h3-events-03\"\r\n],\r\n```\r\n\r\nDownsides I could find:\r\n- We're stuck with the `qlog_schemas` field and its definition forever. No way to e.g., refactor it to a list of protocols and their versions (e.g., instead of `\"draft-ietf-quic-qlog-quic-events-03\"` it could say `[\"HTTP/3\", \"v5.1\"]`). This is true for the `qlog_version` field as well, but that seems like much less of an issue.\r\n- For parsers that can handle multiple different versions, it's easier to do a quick check on `qlog_version`, rather than having to parse the full `qlog_schemas` field to find the main-schema entry and decide if they support it or not.\r\n\r\nI think those downsides are sufficient to go with the original proposal, but in that case, I'd rename `additional_schema` to `protocol_schemas` or `event_schemas` (or the `qlog_version` field to `qlog_schema_version` ;))\r\n",
          "createdAt": "2023-01-19T11:05:50Z",
          "updatedAt": "2023-01-19T11:05:50Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "So the issue with a list of name and value tuples is, you'd need to go to the effort of defining  naming strategy and a registry to hold those names to avoid conflicts. That's overhead I'd like to avoid.\r\n\r\n`qlog_schema_version` sounds fine to me.\r\n\r\nI'd stuck with something like `additional_schemas` though. There's no restriction I can think of that means new schema are constrained about what they can extend.",
          "createdAt": "2023-01-19T13:12:42Z",
          "updatedAt": "2023-01-19T13:12:42Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking about this more and comparing with other similar projects, I think keeping the original proposal is fine, but that we should probably use the term \"namespace\" instead of \"schema\" (seems to be used quite consistently across XML, YAML, even [CDDL 2.0](https://www.ietf.org/archive/id/draft-bormann-cbor-cddl-2-draft-00.html#name-explicitly-interacting-with)). \r\n\r\nThus:\r\n```\r\n\"qlog_version\": \"0.3\", # version of the \"default\" namespace, which is the \"main-schema\" document\r\n\"qlog_format\": \"JSON\",\r\n\"namespaces\": [\r\n  \"draft-ietf-quic-qlog-quic-events-03\",\r\n  \"draft-ietf-quic-qlog-quic-h3-events-03\"\r\n],\r\n```\r\n",
          "createdAt": "2023-03-01T15:53:12Z",
          "updatedAt": "2023-03-01T15:53:12Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "qlog doesn't define the term namespace anywhere, so it would have to do that. Realistically, I think that pushes us towards making this all much more explicit. I.e. providing guidelines defining namespaces and registering them in a new  IANA registry. That's not far off what we talked about earlier with the tuple suggestion but I don't see a good reason to have a separate version field. ",
          "createdAt": "2023-03-01T16:51:48Z",
          "updatedAt": "2023-03-01T16:51:48Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the call: namespaces has some implicit connotations that imply things like versioning and uniqueness, which we don't want because they need IANA support. Keep `additional_schema` and make clear the entries refer to datatracker documents only. Basically Merge the PR after doublechecking it's good :) ",
          "createdAt": "2023-03-01T19:50:05Z",
          "updatedAt": "2023-03-01T19:50:05Z"
        },
        {
          "author": "JonathanLennox",
          "authorAssociation": "NONE",
          "body": "I don't love naming protocol elements after drafts or RFCs ... it gets very confusing if you ever publish a compatible update of a spec.  (E.g.: what RFC defines the content of the media format `message/rfc822`?). Also there should be a sensible way for people to define proprietary schemas that aren't defined by an IETF document.\r\n\r\nIt's maybe moderately annoying, but I'd suggest a `urn:ietf:params:qlog:` namespace for these, with proprietary extensions taking whatever URI its creator wants to put in.",
          "createdAt": "2023-04-06T17:43:42Z",
          "updatedAt": "2023-04-06T18:19:48Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "That's a fair point Lennox. Have you got any links to resources for registering and maintaining such a namespace?",
          "createdAt": "2023-04-06T17:55:47Z",
          "updatedAt": "2023-04-06T17:55:47Z"
        },
        {
          "author": "JonathanLennox",
          "authorAssociation": "NONE",
          "body": "The model I'm thinking of is the URIs identifying RTP Header Extensions, RFC 8285 - that's probably a good starting point to base yourself on.  (Section 5 and Section 10.1.)",
          "createdAt": "2023-04-06T18:16:24Z",
          "updatedAt": "2023-04-06T18:16:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "thanks!",
          "createdAt": "2023-04-06T18:22:50Z",
          "updatedAt": "2023-04-06T18:22:50Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Fixed via #424, closing ",
          "createdAt": "2024-07-08T20:27:12Z",
          "updatedAt": "2024-07-08T20:27:12Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "It took us a while to get to the final design but thanks @JonathanLennox for the inspiration ",
          "createdAt": "2024-07-08T20:28:09Z",
          "updatedAt": "2024-07-08T20:28:09Z"
        }
      ]
    },
    {
      "number": 286,
      "id": "I_kwDOCrLn6M5bmfOw",
      "title": "Stop HTTP/3 events from squatting on the HTTP namespace",
      "url": "https://github.com/quicwg/qlog/issues/286",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Not all HTTPs are the same. I've just learned by meddling with netlogs that HTTP/2 and HTTP/3 might be quite similar but have subtle and annoying differences when it comes to logging. \r\n\r\nWe have \r\n\r\n```\r\nhttp:parameters_set \tBase \tSection 4.1\r\nhttp:parameters_restored \tBase \tSection 4.2\r\nhttp:stream_type_set \tBase \tSection 4.3\r\nhttp:frame_created \tCore \tSection 4.4\r\nhttp:frame_parsed \tCore \tSection 4.5\r\nhttp:push_resolved \tExtra \tSection 4.6\r\n```\r\nand the event definitions themselves use `HTTP` as a prefix.\r\n\r\nI'd suggest we just rename these to use `h3` and `http` respectively.",
      "createdAt": "2023-01-17T18:07:33Z",
      "updatedAt": "2023-05-31T19:51:39Z",
      "closedAt": "2023-05-31T19:51:38Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is a bigger issue than just HTTP/3... for QUIC we're currently using `transport`, but as I've also noticed e.g., TCP does not map nicely to the QUIC events. So potentially worth to discuss changing `transport` to `quic` as well (and what to do with the `datagram*` and TLS-related events then ;) \r\n\r\nAs mentioned in https://github.com/quicwg/qlog/issues/153, this might also mean we can remove `protocol_type`",
          "createdAt": "2023-01-18T09:58:55Z",
          "updatedAt": "2023-01-18T11:02:18Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Sure, but those are separate issues with their own considerations to make. \r\n\r\nThe HTTP case is a lot more cut and dry to me. So I'd go ahead and fix it now via my PR.",
          "createdAt": "2023-01-18T13:35:30Z",
          "updatedAt": "2023-01-18T13:35:30Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on call: general principle is ok. Create new issue to track `transport` changes. ",
          "createdAt": "2023-01-18T20:20:44Z",
          "updatedAt": "2023-01-18T20:20:44Z"
        }
      ]
    },
    {
      "number": 295,
      "id": "I_kwDOCrLn6M5hxp69",
      "title": "HTTP header values (and possibly names also) should be optional",
      "url": "https://github.com/quicwg/qlog/issues/295",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "At the moment, the definition says that the value is mandatory.\r\n```\r\nHTTPField = {\r\n    name: text\r\n    value: text\r\n}\r\n```\r\n\r\nHowever there are cases where the we do not want to log header values (consider a Cookie header).",
      "createdAt": "2023-03-25T06:55:08Z",
      "updatedAt": "2023-07-05T00:02:26Z",
      "closedAt": "2023-07-05T00:02:26Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Yes, I think we should make the value optional and add some guidance in the security and privacy section specifically for header values",
          "createdAt": "2023-03-25T07:00:42Z",
          "updatedAt": "2023-03-25T07:00:42Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Oh the main schema already has HTTP field value consideration described in https://quicwg.org/qlog/draft-ietf-quic-qlog-main-schema.html#section-9-4.7, so all we need to do is change the schema",
          "createdAt": "2023-03-25T07:18:13Z",
          "updatedAt": "2023-03-25T07:18:13Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "in #296 we merged a change to make the value optional.\r\n\r\nI just realized that this issue said `(and possibly names also) should be optional`. @kazuho the HTTP field is only ever used in a list, so its' possible to omit entirely if you want to skip it. I'm not seeing a strong use case for endpoints to want to log:\r\n\r\n1. a `value` but *not* the `name` of the HTTP field.  \r\n2. A HTTPField list entry that omits both `name` and `value`\r\n\r\n@kazuho my inclination is to close this issue now that `value` is optional, please let us know if you object.",
          "createdAt": "2023-05-31T20:05:22Z",
          "updatedAt": "2023-07-05T00:02:12Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Hearing no objection, closing.",
          "createdAt": "2023-07-05T00:02:26Z",
          "updatedAt": "2023-07-05T00:02:26Z"
        }
      ]
    },
    {
      "number": 297,
      "id": "I_kwDOCrLn6M5hxzGi",
      "title": "Logging for paced packet sending",
      "url": "https://github.com/quicwg/qlog/issues/297",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Today qlog has packet_sent events and datagrams_sent events, which can be used to log the event and the time it occurred.\r\n\r\nIn some scenarios, the application generating packets or even datagrams is not in direct control of the emission of those packets to the wire. For example, a QUIC library may be called to generate a batch of packets that are intended to be sent out on a future time schedule. If the pacing is offloaded to some other component, such as the kernel, then reporting events in a qlog might be practically hard.\r\n\r\nSomething we've done in quiche is to add an additional `send_at_time` field in the packet_sent event. This contains a timestamp that the QUIC layer decided that the packet should be sent out at. We can keep that as custom extension but I was curious if others had any opinions.",
      "createdAt": "2023-03-25T09:17:35Z",
      "updatedAt": "2024-06-24T13:35:57Z",
      "closedAt": "2024-06-24T13:35:57Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "We can close this when #400 lands",
          "createdAt": "2024-03-04T09:58:42Z",
          "updatedAt": "2024-03-04T09:58:42Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Small correction: not #400 but its more general spinoff, which will be tracked in #379 :) ",
          "createdAt": "2024-03-04T11:44:08Z",
          "updatedAt": "2024-03-04T11:44:08Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Solved by #417 ",
          "createdAt": "2024-06-24T13:35:25Z",
          "updatedAt": "2024-06-24T13:35:25Z"
        }
      ]
    },
    {
      "number": 301,
      "id": "I_kwDOCrLn6M5mT2Fn",
      "title": "quic: move from \"transport\" label to \"quic\" label",
      "url": "https://github.com/quicwg/qlog/issues/301",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is the followup from #286 ",
      "createdAt": "2023-05-19T01:29:04Z",
      "updatedAt": "2023-05-31T19:56:53Z",
      "closedAt": "2023-05-31T19:56:52Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #302 ",
          "createdAt": "2023-05-31T19:56:52Z",
          "updatedAt": "2023-05-31T19:56:52Z"
        }
      ]
    },
    {
      "number": 309,
      "id": "I_kwDOCrLn6M5qqg4_",
      "title": "Referring to documents",
      "url": "https://github.com/quicwg/qlog/issues/309",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Now that we will be adding events not just from the main QUIC and HTTP/3 series (e.g., RFC 9000 - 9003, 9114, 9204) but also extension documents, I wonder how to indicate which events/fields are defined where.\r\n\r\nUp until now it's been very ad-hoc, most events not indicating anything, and just a few fields explicitly referencing a document and section (e.g., see this recent PR https://github.com/quicwg/qlog/pull/310, or this one https://github.com/quicwg/qlog/pull/306 or fields in https://quicwg.org/qlog/draft-ietf-quic-qlog-quic-events.html#name-connection_state_updated). \r\n\r\nI can see some options:\r\n1. Simply list all documents \"on top\" and let the reader figure it out themselves (more or less what we have now)\r\n2. Only refer explicitly to a document if it's not one of the \"core set\" (i.e., RFC 9000-9003, HTTP/3 and QPACK)\r\n3. Consistently refer to documents for each event, even those in the \"core set\"\r\n\r\nI would mainly do this for documents and only refer to specific sections or statements therein if it really makes sense/is ambiguous (e.g.., not referring to specific sections for each and every event by default). \r\n\r\nI currently have a slight preference for 2. myself\r\n\r\n",
      "createdAt": "2023-07-05T13:12:34Z",
      "updatedAt": "2023-11-29T23:26:00Z",
      "closedAt": "2023-11-29T23:26:00Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during call: use option 2 for now, but keep option open: probably best to change to not referencing hard RFCs directly down the road; needs further discussion",
          "createdAt": "2023-07-05T18:51:43Z",
          "updatedAt": "2023-07-05T18:51:43Z"
        }
      ]
    },
    {
      "number": 313,
      "id": "I_kwDOCrLn6M5qsEz1",
      "title": "Is the .well-known address really necessary?",
      "url": "https://github.com/quicwg/qlog/issues/313",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The main schema defines a means for clients to download generated qlogs by accessing them at a well-known address.  It hints that this is via HTTP but doesn't mandate that or provide more details about the expected HTTP interaction.\r\n\r\nI'm curious how many people actually support this. The spec itself says that `qlog implementers SHOULD NOT enable this .well-known endpoint in typical production settings`, anyone that follows that advice will not. If we axpect this to be more of a debugging methodology, that might suggest that sharing the location (e.g. URI or something else) using out-of-band mechanisms would be just as managable. \r\n\r\nThe proposal is also one sided. There is no capability defined for a client to submit its own logs for a server to later analyse. Not sure if that's a real problem but it is a constraint someone might question later in the process.\r\n\r\nSince the .well-known access does not run in the \"hot path\" of event logging, it would seem fine to extract this and punt it to some follow on work.",
      "createdAt": "2023-07-05T16:53:42Z",
      "updatedAt": "2023-07-24T22:54:08Z",
      "closedAt": "2023-07-24T22:54:08Z",
      "comments": [
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 \r\nit seems to be more useful for interop-like tests than for production use cases, therefore I am not sure it necessarily belongs in the RFC",
          "createdAt": "2023-07-05T17:03:59Z",
          "updatedAt": "2023-07-05T17:03:59Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed during call: remove this from text. If needed later, will be separate document.",
          "createdAt": "2023-07-05T18:53:24Z",
          "updatedAt": "2023-07-05T18:53:24Z"
        }
      ]
    },
    {
      "number": 314,
      "id": "I_kwDOCrLn6M5qswIt",
      "title": "Bump the version before next draft",
      "url": "https://github.com/quicwg/qlog/issues/314",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "There's been a tonne of breaking changes commited to the editor's copy. Before we cut the next draft version, we need to bump the qlog version too.",
      "createdAt": "2023-07-05T19:03:49Z",
      "updatedAt": "2023-07-11T09:34:35Z",
      "closedAt": "2023-07-11T09:34:35Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also need to remember to update the top sections of the h3 and quic docs to include refs to all the extension RFCs in proper prose.\r\n\r\nI also need to add changelogs.",
          "createdAt": "2023-07-06T10:31:24Z",
          "updatedAt": "2023-07-06T10:31:41Z"
        }
      ]
    },
    {
      "number": 318,
      "id": "I_kwDOCrLn6M5quLtz",
      "title": "Migration-related events",
      "url": "https://github.com/quicwg/qlog/issues/318",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The qlog schema has had a placeholder section for migration-related events for a long time.  #317 removes the offending text and we  and instead we can continue discussion on this issue.",
      "createdAt": "2023-07-05T23:11:40Z",
      "updatedAt": "2024-03-14T12:40:39Z",
      "closedAt": "2024-03-14T12:40:39Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Will be fixed by #336 when that gets merged. ",
          "createdAt": "2024-03-04T14:12:39Z",
          "updatedAt": "2024-03-04T14:12:39Z"
        }
      ]
    },
    {
      "number": 319,
      "id": "I_kwDOCrLn6M5quML8",
      "title": "Is the loss_timer_updated event sufficient?",
      "url": "https://github.com/quicwg/qlog/issues/319",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We've had the following todo's for `loss_timer_updated` in the quic schema for a while, pulling them out into this issue\r\n\r\n1. TODO: how about CC algo's that use multiple timers? How generic do these events\r\nneed to be? Just support QUIC-style recovery from the spec or broader?\r\n\r\n2. TODO: read up on the loss detection logic in draft-27 onward and see if this suffices\r\n\r\n",
      "createdAt": "2023-07-05T23:14:01Z",
      "updatedAt": "2024-11-04T16:55:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I'm guessing we are looking for volunteers to help us here. We can ask. In the absence of someone offering it, we can use the WGLC as an indicator that there is consensus on what is already in the draft as sufficient.",
          "createdAt": "2024-11-04T16:55:03Z",
          "updatedAt": "2024-11-04T16:55:03Z"
        }
      ]
    },
    {
      "number": 323,
      "id": "I_kwDOCrLn6M5qw-Hg",
      "title": "QUICDatagramsSent or UDPDatagramsSent",
      "url": "https://github.com/quicwg/qlog/issues/323",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We currently have several events that can be used to indicate how QUIC packets are sent in UDP datagrams (`quic:datagrams_sent`, `quic:datagrams_received` etc.).\r\n\r\nHowever, adding support for RFC9221 (Unreliable Datagram extension for QUIC), which adds the new DatagramFrame, causes some issues with the naming here.\r\n\r\nFor example, we also want a `datagram_data_moved` event in addition to the existing `(stream_)data_moved` event, but that would be ambiguous which \"datagram\" we're actually talking about (UDP datagrams or QUIC Datagram Frames). \r\n\r\nSince we've renamed the `transport` category to `quic` (before it was `transport:datagrams_*`), it makes sense to rename these events to `udp:datagrams_*` as well for consistency and clarity.\r\n",
      "createdAt": "2023-07-06T09:59:38Z",
      "updatedAt": "2024-03-06T10:34:04Z",
      "closedAt": "2024-03-06T10:34:04Z",
      "comments": []
    },
    {
      "number": 324,
      "id": "I_kwDOCrLn6M5qxSZA",
      "title": "Trigger for H3PriorityUpdated",
      "url": "https://github.com/quicwg/qlog/issues/324",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "I am wondering if the new H3PriorityUpdated event (see #312) needs some specified `trigger` field values.\r\n\r\nConceptually, you can get the necessary context from other events surrounding this event (e.g., if you get a H3FrameParsed with a HEADERS containing a `priority` field preceding this, that's a clear indicator that's the trigger). However, there are cases where this is less clear (e.g., default initialization to a value different from the spec, local override due to configuration or other logic, merging of client and server-sent priorities for the same stream, ...)\r\n\r\nWe don't NEED to define any triggers here (`trigger` is always defined on event data, just not necessarily specced in qlog), but I'm wondering if some default values would be useful here @LPardue?\r\n\r\ne.g., \r\n```\r\n? trigger: \"client_directive\" / \"server_directive\" / \"local_override\" / \"local_default\" / \"merge\" / \"merge_override\"\r\n```",
      "createdAt": "2023-07-06T10:51:06Z",
      "updatedAt": "2025-03-12T11:44:46Z",
      "closedAt": "2025-03-12T11:44:46Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Personally, I don't think I'd have the ability to pass through enough context to my logging library to capture the trigger. But I think I need a bit more time to work on the implementation.",
          "createdAt": "2023-10-21T17:59:21Z",
          "updatedAt": "2023-10-21T17:59:21Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue any update on your opinion on this? I still think this would be useful in general, even if quiche can't pass it :) and i still like the values I proposed above. Are you opposed to a PR for this? ",
          "createdAt": "2024-03-01T16:09:56Z",
          "updatedAt": "2024-03-01T16:09:56Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I can live with it if you want to add it. But I'd like a better description of how the \"trigger\" field is a part of event data; see #429",
          "createdAt": "2024-07-09T22:36:21Z",
          "updatedAt": "2024-07-09T22:36:21Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Thinking on this some more, I don't think the values in the OP are actually a trigger. They are a result of applying the guidance in https://www.rfc-editor.org/rfc/rfc9218.html#name-merging-client-and-server-d. In other words, how the value of `new` was arrived upon. The client always sends a signal, the server always has to make a decision, including ignoring the client.\r\n\r\nSo I think what maybe what you want is an optional `reason` field that can be used to explain _how_. That might just contain values `client_signal_only, client_server_merged, local_policy\".\r\n\r\nThen if you want a `trigger`, it should track _why_ the update happened e.g. a client PRIORITY_UPDATE, some spontaneous server-local decision, so perhaps just `client_signal, local_decision, other`. For example, I have a Priority extension for changing on a byte schedule. I might extends the trigger field to have a \"schedule\" value, and still use a reason \"local_policy\".",
          "createdAt": "2024-10-21T14:41:13Z",
          "updatedAt": "2024-10-21T14:41:13Z"
        }
      ]
    },
    {
      "number": 338,
      "id": "I_kwDOCrLn6M52s1RU",
      "title": "Remove QPACK events from H3 & QPACK schema",
      "url": "https://github.com/quicwg/qlog/issues/338",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "quic-http3-fields"
      ],
      "body": "We've heard some feedback that the QPACK events are too low-level to be useful\r\nand that higher-level QPACK events would be preferred. However, in the absence of\r\na proposal for higher-level QPACK events we are stuck with what is currently\r\ndefined ... and nobody seems to be using these.\r\n\r\nThe proposal is to remove QPACK events, see PR #335. This was discussed at IETF 118 and the sense of the room seemed to support it. Lets take it to the list to confirm.",
      "createdAt": "2023-11-13T20:52:13Z",
      "updatedAt": "2023-12-09T23:07:44Z",
      "closedAt": "2023-12-09T23:07:44Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Closed as done.",
          "createdAt": "2023-12-09T23:07:44Z",
          "updatedAt": "2023-12-09T23:07:44Z"
        }
      ]
    },
    {
      "number": 339,
      "id": "I_kwDOCrLn6M52tZyf",
      "title": "I-JSON things",
      "url": "https://github.com/quicwg/qlog/issues/339",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "#289 does an editorial refactor, which hightlights that I-JSON doesn't really belong as a subsection of JSON serialization. In his review, Robin states:\r\n\r\n> Since we removed truncation from this, it's a bit weird to have just a single subsection under JSON. It's also weird we don't explicitly say anything about \"qlog_format\"/file extension/MIME type when employing I-JSON (it's still just \"JSON\", but that should be explicitly spelled out imo).\r\n\r\n> It makes more sense to promote I-JSON to a `##` here, so we have 3 sections for the 3 formats (this is also how they're introduced atm).\r\n\r\n_Originally posted by @rmarx in https://github.com/quicwg/qlog/pull/289#discussion_r1120305282_\r\n            ",
      "createdAt": "2023-11-13T22:48:47Z",
      "updatedAt": "2024-02-05T11:47:23Z",
      "closedAt": "2024-02-05T11:47:22Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I tried to propose some text here but failed at the first attempt.\r\n\r\nAs far as I can tell, there are no standard means to communicate that I-JSON is being used explicitly (i.e. no media type or extension). So a parse can't use any signal to know when to override the definition of uint64. In #359, I propose we just make uint64 itself a number or a string. \r\n\r\nSo I wonder if we should rename this section to \"JSON interoperability\" and mention that serializers make want to apply the I-JSON subset in either of qlog's JSON or JSON-SEQ formats. And also keep the explanation why we need a bigger number range.",
          "createdAt": "2023-12-09T22:33:58Z",
          "updatedAt": "2023-12-09T22:33:58Z"
        }
      ]
    },
    {
      "number": 340,
      "id": "I_kwDOCrLn6M52tbBc",
      "title": "\"field names\" vs \"member names\" vs. \"object member names\"",
      "url": "https://github.com/quicwg/qlog/issues/340",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From PR #289:\r\n\r\n> I've called this \"field names\" consistently throughout the qlog documents. However, double-checking this with the JSON RFC at https://www.rfc-editor.org/rfc/rfc8259#section-4, they use \"member names\" or \"object member names\" instead. \r\n\r\n>I'm not sure that makes things any clearer for readers unfamiliar with JSON terminology, and changing things would be a big overall update across the docs, but potentially worth it for consistency? Either way, would require a new issue/PR.\r\n\r\n_Originally posted by @rmarx in https://github.com/quicwg/qlog/pull/289#discussion_r1120277151_\r\n            ",
      "createdAt": "2023-11-13T22:53:42Z",
      "updatedAt": "2023-12-19T01:56:22Z",
      "closedAt": "2023-12-19T01:56:22Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I like the term qlog field names, especially as we want the qlog schema to be serialization format independent. Therefore I don't think we need to use JSON terminology. I made #362 as a way to make the sentences a bit cripser - but I could equally live without it.",
          "createdAt": "2023-12-09T23:06:59Z",
          "updatedAt": "2023-12-09T23:06:59Z"
        }
      ]
    },
    {
      "number": 341,
      "id": "I_kwDOCrLn6M52tdi-",
      "title": "Remove text about filename optimization chaining",
      "url": "https://github.com/quicwg/qlog/issues/341",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> I really wonder if we should keep this kind of thing in here, especially if we don't include any concrete examples anymore. Then we should also remove a similar paragraph up-top when discussing `qlog_format` for the first time.\r\n\r\n_Originally posted by @rmarx in https://github.com/quicwg/qlog/pull/289#discussion_r1120332518_\r\n            ",
      "createdAt": "2023-11-13T23:03:30Z",
      "updatedAt": "2023-12-19T01:55:52Z",
      "closedAt": "2023-12-19T01:55:52Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This is dependent on landing #289 first",
          "createdAt": "2023-11-29T23:23:47Z",
          "updatedAt": "2023-11-29T23:23:47Z"
        }
      ]
    },
    {
      "number": 342,
      "id": "I_kwDOCrLn6M52wiFR",
      "title": "change STREAM and DATAGRAM frame definition to allow logging of frame payload",
      "url": "https://github.com/quicwg/qlog/issues/342",
      "state": "OPEN",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "Currently the `raw` field includes the wire representation of the frame. This doesn't seem useful, and would mean that a qlog consumer would need to implement a frame parser. Instead, we should only log the payload.\r\n\r\nThis could be done by changing the `raw` field to `payload`.",
      "createdAt": "2023-11-14T10:20:59Z",
      "updatedAt": "2025-03-12T03:47:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, I don't agree with this. The reason it includes the frame/packet headers currently is because we (intentionally) lose some information present in the binary form by representing the data in qlog/JSON. Users should have a way to get to the original data for low-level debugging if needed. An argument -might- be made for splitting it into a separate `headers` and `payload` (and then also `trailers`?) field, but not omitting headers.\r\n\r\nYour proposal imo also only circumvents 1 layer of parsing at a time (e.g., not logging QUIC STREAM frames still requires implementing an H3/QPACK parser, not logging QUIC Packer Headers still required QUIC frame parser, etc.). \r\n\r\nI would suggest closing this without action. ",
          "createdAt": "2024-03-04T14:11:42Z",
          "updatedAt": "2024-03-04T14:11:42Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Are you still willing to fight for this @marten-seemann ? \r\n\r\nI just also thought of another counter-argument: since the current RawInfo struct also contains the full length and the payload-only length, an implementation that just wants the payload can calculate the length of the headers and then skip that many bytes ahead in the `payload` hexstring to get to the payload start (it requires a little bit more logic in the case of trailers, but we really only have those for QUIC packets, and those trailers are 100% predictable in size). \r\n\r\nIf you do not provide push-back within 1 week, I'll close this without action. ",
          "createdAt": "2024-06-24T14:14:26Z",
          "updatedAt": "2024-06-24T14:14:26Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during editors' meeting. Indeed makes sense to only log payload. If you need higher up headers, you log previous layer (e.g., if you need QUIC packet headers, you'd get them from the raw UDP packets).",
          "createdAt": "2024-06-25T09:27:13Z",
          "updatedAt": "2024-06-25T09:27:13Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "@rmarx given you're workin on https://github.com/quicwg/qlog/pull/450/files, do you want to visit this issue about StreamFrame and DatagramFrame soon too?",
          "createdAt": "2025-03-12T03:47:53Z",
          "updatedAt": "2025-03-12T03:47:53Z"
        }
      ]
    },
    {
      "number": 346,
      "id": "I_kwDOCrLn6M53Ntt0",
      "title": "connection_id_updated",
      "url": "https://github.com/quicwg/qlog/issues/346",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "> when the endpoint receives a new connection id\r\nfrom the peer, it will see the dst_ fields are set. When the endpoint updates\r\nits own connection ID (e.g., NEW_CONNECTION_ID frame), it logs the src_ fields.\r\n\r\nI don't understand what the `dst_ fields` or `src_ fields` are. Is this stale text?",
      "createdAt": "2023-11-17T23:36:18Z",
      "updatedAt": "2024-03-04T11:24:48Z",
      "closedAt": "2024-03-04T11:24:48Z",
      "comments": []
    },
    {
      "number": 348,
      "id": "I_kwDOCrLn6M54QkO9",
      "title": "Event importance is not prose important",
      "url": "https://github.com/quicwg/qlog/issues/348",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Each event definition lives in a section and states it's importance as the first line of the section. IIRC we agreed on this as an editorial style but I'm growing to dislike it.",
      "createdAt": "2023-11-29T23:31:04Z",
      "updatedAt": "2023-12-08T15:21:17Z",
      "closedAt": "2023-12-08T15:21:17Z",
      "comments": []
    },
    {
      "number": 349,
      "id": "I_kwDOCrLn6M54Qmht",
      "title": "\"Definition:\"  in prose is redundant",
      "url": "https://github.com/quicwg/qlog/issues/349",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Each event definition figure is prefixed with text that says `Definition:`. This is redunant and we can improve readability by removing them.",
      "createdAt": "2023-11-29T23:42:37Z",
      "updatedAt": "2023-12-08T15:13:49Z",
      "closedAt": "2023-12-08T15:13:49Z",
      "comments": []
    },
    {
      "number": 355,
      "id": "I_kwDOCrLn6M55KxlL",
      "title": "Security use cases",
      "url": "https://github.com/quicwg/qlog/issues/355",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "              This first sentence is not precise about whether it refers to the logging use case or the use case of the logged exchange.\r\n\r\n_Originally posted by @martinthomson in https://github.com/quicwg/qlog/pull/353#discussion_r1410158849_\r\n            ",
      "createdAt": "2023-12-08T15:31:00Z",
      "updatedAt": "2024-07-08T19:23:57Z",
      "closedAt": "2024-07-08T19:23:57Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "also see https://github.com/quicwg/qlog/pull/353/files#r1410163988 where the text says\r\n\r\n> Operator and implementers need to balance the value of logged data against the potential\r\nrisks inherent in their (involuntary) disclosure. This balance depends on the\r\nuse case at hand (e.g., research datasets might have different requirements to\r\nlive operational troubleshooting).\r\n\r\nand Martin comments \r\n\r\n> It seems like the difference in these examples is WHO has access to the data and the level to which the different entities might be trusted, so maybe this isn't so much about use cases.",
          "createdAt": "2023-12-08T15:32:59Z",
          "updatedAt": "2023-12-08T15:34:48Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It could be I'm conflating the things sure, but from my perspective, research datasets from e.g., active measurements, are obtained for a very different \"use case\" than generic operational logs. \r\n\r\nSimilarly, for the research \"use case\" you need more in-depth data (e.g., to do in-depth debugging) than for the operational \"use case\". \r\n\r\nSo I can see where the comment is coming from, but I'm not sure I agree it's mainly about WHO has access to the data, decoupled from the use case...\r\n\r\n",
          "createdAt": "2023-12-08T15:37:07Z",
          "updatedAt": "2023-12-08T15:37:07Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As part of https://github.com/quicwg/qlog/pull/364, the original sentence:\r\n\r\n```\r\nAny data that is determined to be necessary for a use case at hand could be logged or captured.\r\n```\r\n\r\nwas edited into\r\n\r\n```\r\nDepending on the observability use case any data could be logged or captured.\r\n```\r\n\r\nI personally think this adequately clarifies which \"use case\" we're talking about in the original text of this issue.\r\n\r\nHOWEVER it does not really address the other point in the [2nd comment](https://github.com/quicwg/qlog/issues/355#issuecomment-1847390791):\r\n\r\n> It seems like the difference in these examples is WHO has access to the data and the level to which the different entities might be trusted, so maybe this isn't so much about use cases.\r\n\r\nAs that part of the text is still:\r\n\r\n```\r\nOperators and implementers should balance the value of logged data with the\r\npotential risks of (involuntary) disclosure, which can depend on use cases\r\n(e.g., research datasets might have different requirements to live operational\r\ntroubleshooting).\r\n```\r\n\r\nThat imo might be fixed by doing something like (last sentence part added): \r\n\r\n```\r\nOperators and implementers should balance the value of logged data with the\r\npotential risks of (involuntary) disclosure, which can depend on use cases\r\n(e.g., research datasets might have different requirements to live operational\r\ntroubleshooting) **and/or which entities have access to the data.** \r\n```\r\n\r\n\r\nif you agree @LPardue, I'll make a PR for that change and we can close this issue with it. \r\n\r\n",
          "createdAt": "2024-06-24T14:09:25Z",
          "updatedAt": "2024-06-24T14:10:03Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I'm not sure that addional fragment helps much. I took a stab at something a little different, in case it works or inspires you.",
          "createdAt": "2024-06-27T23:00:57Z",
          "updatedAt": "2024-06-27T23:00:57Z"
        }
      ]
    },
    {
      "number": 357,
      "id": "I_kwDOCrLn6M55PO8Q",
      "title": "Standardization formats intentions vs recommendations",
      "url": "https://github.com/quicwg/qlog/issues/357",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "              Not sure I'm the biggest fan of referring explicitly to the other 2 docs here, since this MAIN doc is supposed to be generic (except maybe for some examples).\r\n\r\n_Originally posted by @rmarx in https://github.com/quicwg/qlog/pull/289#discussion_r1420675552_\r\n\r\nSee my followup comments on that PR. It is useful to provide explicit statements but perhaps we want to extract the mention of QUIC and H3 event schema serialization intentions into their own documents. We can recommend in the base schema that each extension state if it is generic or make some format-specific optimization.\r\n            ",
      "createdAt": "2023-12-09T20:12:07Z",
      "updatedAt": "2024-03-04T11:26:54Z",
      "closedAt": "2024-03-04T11:26:54Z",
      "comments": []
    },
    {
      "number": 358,
      "id": "I_kwDOCrLn6M55PSHD",
      "title": "Edit down the security section",
      "url": "https://github.com/quicwg/qlog/issues/358",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "We've had comments it's long. Let's look for opportunities to shave text.",
      "createdAt": "2023-12-09T20:57:05Z",
      "updatedAt": "2024-02-28T13:54:14Z",
      "closedAt": "2024-02-28T13:54:14Z",
      "comments": []
    },
    {
      "number": 366,
      "id": "I_kwDOCrLn6M58lt7T",
      "title": "Improve connectivity:connection_closed",
      "url": "https://github.com/quicwg/qlog/issues/366",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As reported by @hlandau on the mailing list:\r\n\r\nconnectivity:connection_closed:\r\n\r\n  This is missing the frame type field in the QUIC CONNECTION_CLOSE\r\n  frame which is rather useful information.\r\n\r\n  connection_code can be a string or a uint32, but QUIC uses a variable\r\n  length integer here and thus this can be up to 62 bits. Same for the\r\n  application_code.\r\n\r\n  It is up to the decoder to infer by presence of connection_code or\r\n  application_code to infer whether this was an application or transport\r\n  CONNECTION_CLOSE. But this requires it to log such a value. It would\r\n  be nice if this can be communicated without necessarily knowing the\r\n  actual value. Consider either adding a field to distinguish between\r\n  transport and app errors or replacing the \"error\" field of \"trigger\"\r\n  with \"app_error\" and \"transport_error\".",
      "createdAt": "2024-01-19T10:55:33Z",
      "updatedAt": "2024-02-28T13:56:47Z",
      "closedAt": "2024-02-28T13:56:47Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "As suggested, it think it makes sense to udate this even to more closely resemble the CONNECTION_CLOSE frame structure e.g. have error_code and error_space fields\r\n",
          "createdAt": "2024-01-24T00:30:24Z",
          "updatedAt": "2024-01-24T00:30:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I created #384 to address the frame type trigger field.\r\n\r\nOn re-reading the issue I realised I misinterpreted the request about not knowing an error code. If an endpoint doesn't know the specific error code, the trigger field allows to articulate transport or app errors via the existing values. So I don't think a change here is an improvement.",
          "createdAt": "2024-01-28T19:29:48Z",
          "updatedAt": "2024-01-28T19:30:38Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Closing as we think this can already be handled by other means",
          "createdAt": "2024-02-28T13:56:47Z",
          "updatedAt": "2024-02-28T13:56:47Z"
        }
      ]
    },
    {
      "number": 367,
      "id": "I_kwDOCrLn6M58luqK",
      "title": "Improve connectivity:connection_id_updated",
      "url": "https://github.com/quicwg/qlog/issues/367",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "As reported by @hlandau on the mailing list:\r\n\r\nconnectivity:connection_id_updated:\r\n\r\n  It would be nice to be able to optionally log CID-associated sequence\r\n  numbers and the type of CID source (ODCID, Initial CID,\r\n  preferred_address transport parameter, NCID frame, etc.)",
      "createdAt": "2024-01-19T10:57:01Z",
      "updatedAt": "2024-01-24T01:26:03Z",
      "closedAt": "2024-01-24T01:26:02Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Dupe of #373 that has discussion, so closing.",
          "createdAt": "2024-01-24T01:26:02Z",
          "updatedAt": "2024-01-24T01:26:02Z"
        }
      ]
    },
    {
      "number": 368,
      "id": "I_kwDOCrLn6M58lxw5",
      "title": "Improve quic:alpn_information",
      "url": "https://github.com/quicwg/qlog/issues/368",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "As reported by @hlandau on the mailing list:\r\n\r\nquic:alpn_information:\r\n\r\n  RFC 7301 states that ALPN protocol strings are byte strings, not text.\r\n  How should ALPN protocol strings which are not valid UTF-8 or not\r\n  valid text be logged?",
      "createdAt": "2024-01-19T11:02:20Z",
      "updatedAt": "2024-02-05T09:53:33Z",
      "closedAt": "2024-02-05T09:53:33Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This issue is correct. Implementations that treat ALPN IDs as if they were strings can hit issues. Although qlog is not in the hot path, assuming  sequence is safe to encode is not robust (especially as it is uncontrolled data).\r\n\r\nMy inclination would be to define a ALPN ID type for qlog. That could carry the raw bytes encoded as `hexstring` and/or the \"friendly\" representation if its safe. e.g.\r\n\r\n```\r\nALPNIdentifier = {\r\n  ? bytes: hexstring\r\n  ? string: string\r\n}\r\n```\r\nThe reason being that most people would recognise `h3` on sight, but scratch their heads about what `0x68 0x33` is.\r\n\r\nFurthermore, while looking at [the section](https://quicwg.org/qlog/draft-ietf-quic-qlog-quic-events.html#name-alpn_information), I think we should actually cite the ALPN RFC and tighten up the text at the same time.",
          "createdAt": "2024-01-24T00:19:30Z",
          "updatedAt": "2024-01-24T00:21:00Z"
        },
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": "Personally I would just go with the hex encoding. Providing the ability to use either seems overkill. Not being able to eyeball a qlog file to read the ALPN might be annoying, but that will be the case anyway if an implementation does the robust thing and only serialises the hex encoding.",
          "createdAt": "2024-01-24T07:23:18Z",
          "updatedAt": "2024-01-24T07:23:18Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Not being able to quickly read the \"h3\" ALPN from a qlog seems like a non-starter to me. I don't want to remember (or rather, look up 1000 times) what that is in hex.",
          "createdAt": "2024-01-24T07:57:44Z",
          "updatedAt": "2024-01-24T07:57:44Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Agree with Marten here.\r\n\r\nHTTP headers might actually suffer the same issues now I think about it. ",
          "createdAt": "2024-01-24T09:50:39Z",
          "updatedAt": "2024-01-24T09:51:05Z"
        }
      ]
    },
    {
      "number": 369,
      "id": "I_kwDOCrLn6M58ly6Z",
      "title": "Improve quic:parameters_set",
      "url": "https://github.com/quicwg/qlog/issues/369",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As reported by @hlandau on the mailing list:\r\n\r\nquic:parameters_set:\r\n\r\n  As things stand, there is no facility for logging the reception of unknown\r\n  transport parameters by an endpoint. Since transport parameters are used to\r\n  negotiate extensions to QUIC, having logged data about the presence of\r\n  transport parameters sent by a peer but not understood, and the consequential\r\n  ability to get information about the prevalence of any given unsupported\r\n  transport parameter in incoming traffic, seems like it would be quite useful.\r\n\r\n  I think this event needs more clarify in terms of the distinction between\r\n  attempting to negotiate a feature and it being enabled. It should be possible\r\n  to log the feature set a local or remote endpoint is requesting and it\r\n  should be possible to log the actually negotiated feature set. Possibly\r\n  this can be resolved via simple clarification. If a client connects to\r\n  a server, does it start by emitting parameters_set (owner=local) with (e.g.)\r\n  max_datagram_frame_size set, and then when the server responds without\r\n  it, emit parameters_set (owner=remote) without it? I guess this allows\r\n  the necessary information to be inferred.\r\n\r\n  If the absence of a field indicates it was not negotiated after receiving\r\n  transport parameters from a server, this creates a problem if this event has\r\n  to be used to log other parameters determined at different times (which seems\r\n  plausible for `tls_cipher`, `early_data_enabled`, etc.), as then logging\r\n  those parameters could be misinterpreted as a sign that the transport\r\n  parameters have been received and a feature has not been negotiated.\r\n  Either the cause of a parameters_set event should be clarified (maybe a trigger\r\n  field) or possibly this should be split into different event types.\r\n\r\n  I think it would be valuable to have the ability to log information\r\n  such as spin bit policy (e.g. enabled, disabled due to random chance,\r\n  disabled administratively), independent of the actual spin_bit_updated\r\n  event).",
      "createdAt": "2024-01-19T11:04:16Z",
      "updatedAt": "2024-02-28T11:53:58Z",
      "closedAt": "2024-02-28T11:53:58Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This is a bunch of different issues that need to be split out. \r\n\r\nSupporting unknown TPs is already tracked via https://github.com/quicwg/qlog/issues/176 - we should fix that.\r\n\r\nRegarding \"negotiation\"  each TP will do things differently. For example, some TPs like initial flow control are a statement of what an endpoint is willing to receive. Other fields, like idle timeout, are a declaration that then goes on to decide the connection's idle timeout via combination of both TPs.\r\n\r\nThe datagram example is a good one. If a server doesn't send a max_datagram_frame_size TP or it sends a value of 0, the client can't send them. If its a problem, the client would close the connection. If its not a problem, the client won't close the connection. But that's a facet of the application that uses QUIC. I'm not really sure there is anything we can standardise easily here. Even more so once we allow for logging of arbitrary unknown TPs.\r\n\r\nKeeping things as a matter of what locally set, vs remotely received helps alleviate the trigger question IMO.\r\n\r\nRegarding spin bit policy, that's a separate issue. Personally I'm not interested in spending effort on that but if others want to propose text that fine.",
          "createdAt": "2024-01-24T01:09:35Z",
          "updatedAt": "2024-01-24T01:09:35Z"
        },
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": "I think our understanding of the issues is in agreement. I do think some work is needed here and that the \"owner\" field isn't enough.",
          "createdAt": "2024-01-24T07:26:21Z",
          "updatedAt": "2024-01-24T07:26:21Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I decided to split this off for easier tracking.\r\n\r\nThe first point is indeed tracked in #176 and will be continued there.\r\nThe second point is now at #398, the third at #399.\r\n\r\nClosing this one because of that :) ",
          "createdAt": "2024-02-28T11:53:58Z",
          "updatedAt": "2024-02-28T11:53:58Z"
        }
      ]
    },
    {
      "number": 370,
      "id": "I_kwDOCrLn6M58lzqM",
      "title": "Add clarification for is_coalesced to packet_sent and packet_received",
      "url": "https://github.com/quicwg/qlog/issues/370",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "As reported by @hlandau on the mailing list:\r\n\r\nquic:packet_sent:\r\n\r\n  The meaning of `is_coalesced` should be clarified. I assume this is\r\n  set to true unless a packet is both the first and last packet in a\r\n  datagram. However that is not necessarily obvious when a packet is\r\n  being generated; another option is to define this as being true for\r\n  every packet but the first packet in a datagram.\r\n\r\nquic:packet_received:\r\n\r\n  See comment on is_coalesced above",
      "createdAt": "2024-01-19T11:05:38Z",
      "updatedAt": "2024-07-08T19:12:48Z",
      "closedAt": "2024-07-08T19:12:47Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, I clarified this in #403, but I'm not longer fully sure the `is_coalesced` approach is the best.\r\n\r\nMaybe @hlandau could take another look now that the intent is clearer and indicate which approach you prefer? :) ",
          "createdAt": "2024-03-01T16:03:19Z",
          "updatedAt": "2024-03-01T16:03:19Z"
        },
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": "@rmarx My reading here:\r\n\r\n>However, in cases where implementations cannot track datagrams in this way, the\r\n>`is_coalesced` field can be used to indicate that a packet was (intended to be)\r\n>coalesced. Implementations MAY use both methods concurrently.\r\n\r\nis that `is_coalesced` is basically non-preferred and only for use if an implementation cannot use `datagram_id`. That seems like a good approach.\r\n\r\n\"intended to be\" needs clarifying... this implies a packet could be intended to be coalesced but isn't actually. So to have that you actually have to introduce a concept of \"coalescable\" rather than \"was coalesced\", which feels like it opens a bit of a can of worms where either we have to define that, or an implementation basically gets to define some arbitrary set of conditions which is \"coalescing desired\". But that then kind of feels uselessly vague.\r\n\r\nI almost feel like we should just drop `is_coalesced` unless we can identify a concrete use case for it. It seems hard to lock down a proper meaning for it and the utility (unless I am missing something) seems minimal given the minimal implementation costs of the preferred `datagram_id` approach.",
          "createdAt": "2024-03-06T00:28:32Z",
          "updatedAt": "2024-03-06T00:28:32Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Yeah I'm in Hugo, per my comment on PR #403 , datagram_id seems yseful enough without the is_coaleaced field and avoids the can o' worms",
          "createdAt": "2024-03-06T01:12:25Z",
          "updatedAt": "2024-03-06T01:12:25Z"
        }
      ]
    },
    {
      "number": 371,
      "id": "I_kwDOCrLn6M58l0cM",
      "title": "Add trigger for specific packet_dropped situation",
      "url": "https://github.com/quicwg/qlog/issues/371",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As reported by @hlandau on the mailing list:\r\n\r\nquic:packet_dropped:\r\n\r\n  What is the intended trigger category here when an EL is discarded and\r\n  buffered packets are discarded as a consequence? `decryption_failure`\r\n  could match but feels subtly different, as I guess that covers the\r\n  case where a packet is received after an EL is discarded. IMO it would\r\n  be better to have a different trigger category for this, and add\r\n  language clarifying this case.",
      "createdAt": "2024-01-19T11:07:10Z",
      "updatedAt": "2024-01-27T02:41:10Z",
      "closedAt": "2024-01-27T02:41:10Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here, I might be suffering from \"my brain is slow because it's friday\"-syndrome, but I'm not sure what you mean by \"EL\" here. Care to explain?\r\n\r\nIn general, there are many more `packet_dropped` reasons than we chose to list here, since an exhaustive list would be too much. We have the `general` category for this, AND because triggers are generally loosely defined, implementations can choose their own custom values as well. Though, we can of course have the discussion if this specific situation is common enough to warrant its own trigger value in the spec. ",
          "createdAt": "2024-01-19T11:08:49Z",
          "updatedAt": "2024-01-19T11:08:49Z"
        },
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": ">Here, I might be suffering from \"my brain is slow because it's friday\"-syndrome, but I'm not sure what you mean by \"EL\" here. Care to explain?\r\n\r\nEncryption level\r\n\r\nIf custom values are OK I've no objection, though it does seem to me to undermine the point of a standard enum a little.\r\n\r\nActually, there is a broader point of discussion here &mdash; the interoperability objectives of QLOG seem slightly fuzzy to me, since there is seemingly a lot of expectation of implementations doing custom things like this, and it seems like it will cause problems for tools. Maybe in practice it will not be a problem and tools will just battle-harden themselves by testing with lots of QLOG output from lots of different implementations. It does undermine the point of a standard a little bit &mdash; but maybe QLOG is something that needs to inherently occupy a midpoint between a completely strict standard and a state of total flexibility out of practical realities. (See also the comments on the congestion control algorithm name field, feels like we are touching on the same thing there.) That's something I could definitely see.",
          "createdAt": "2024-01-19T19:16:40Z",
          "updatedAt": "2024-01-19T19:16:40Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, now it all makes more sense :) And it's a fair point that the current categories don't quite cover this properly... \r\n\r\nI don't have a strong preference for any of these options (though nr. 3 seems a bit better maybe?):\r\n1. Do nothing\r\n2. Add new category for this\r\n3. Add this as an \"example\" for the `decryption_failure` trigger in the text\r\n\r\nFor the broader point, I think you hit the nail right on the head. It's been a tough line to walk between a fully \"interoperable\" and consistent specification, and the implementation realities and requirements of individual stacks. I think the general approach has been to provide a stable \"framework\" as much as possible, that allows for the creation of tools that don't have to be too flexible and that mainly need to deal with some variability in terms of field/trigger values, which is usually not too difficult to manage (e.g., qvis will just display the string it reads, without much interpretation if it doesn't expect the value). If we would try to nail down everything, we'd have a mix of pcaps and a whole second layer of semantics on top (and documents at least 4 times as long probably). \r\n\r\nThat said, of course, if situations are common enough and information is often critical in common debugging scenarios, we do try to put them into the spec explicitly :)",
          "createdAt": "2024-01-19T19:42:00Z",
          "updatedAt": "2024-01-19T19:42:00Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I think option 3 is the correct one, it would be just a few words",
          "createdAt": "2024-01-24T01:16:42Z",
          "updatedAt": "2024-01-24T01:16:42Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's useful to be able to tell these two cases apart. Keys being unavailable happens regularly during the handshake, whereas decryption failures shouldn't happen unless there are transmission errors or an active attack.\r\n\r\nfwiw, quic-go already uses `key_unavailable` here.",
          "createdAt": "2024-01-24T04:09:56Z",
          "updatedAt": "2024-01-24T04:09:56Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I can live with a other type",
          "createdAt": "2024-01-24T04:38:24Z",
          "updatedAt": "2024-01-24T04:38:24Z"
        }
      ]
    },
    {
      "number": 372,
      "id": "I_kwDOCrLn6M58l2dv",
      "title": "Clarify value of packets_acked:packet_number_space",
      "url": "https://github.com/quicwg/qlog/issues/372",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "As reported by @hlandau on the mailing list:\r\n\r\nquic:packet_acked:\r\n\r\n  `PacketNumberSpace.application_data`, as this is by far the most prevalent packet\r\n  number space a typical QUIC connection will use.\r\n\r\n  Editorial note: The usage of the . notation\r\n  `PacketNumberSpace.application_data` seems slightly novel here. Just\r\n  write \"application_data\"?",
      "createdAt": "2024-01-19T11:10:43Z",
      "updatedAt": "2024-02-19T09:18:10Z",
      "closedAt": "2024-02-19T09:18:10Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The goal here is not to have the string \"PacketNumberSpace.application_data\" literally as the value, but rather the value of that CDDL definition in the `PacketNumberSpace` struct definition lower in the document:\r\n\r\n```\r\n~~~ cddl\r\nPacketNumberSpace = \"initial\" /\r\n                    \"handshake\" /\r\n                    \"application_data\"\r\n~~~\r\n{: #packetnumberspace-def title=\"PacketNumberSpace definition\"}\r\n```\r\n\r\nSo the intended value is just \"application_data\", but I didn't want to have a \"hardcoded duplicate\" of that string in 2 separate locations in the doc (though maybe that's not a real concern and we can just change this to the correct string? or just word it better to make clearer that the value of the struct should be used?)\r\n\r\n",
          "createdAt": "2024-01-19T11:12:53Z",
          "updatedAt": "2024-01-19T11:12:53Z"
        },
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": "Yep, I understood that. I just found the use of the CDDL notation a bit surprising here.",
          "createdAt": "2024-01-19T16:20:19Z",
          "updatedAt": "2024-01-19T16:20:19Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I agree with @hlandau here. This seems unique and surprising.\r\n\r\nThere's several cases in the drafts of fields that have similar crafted types and we just name those types directly when we need to. Lets just use `application_data` here, it's less confusing. ",
          "createdAt": "2024-01-24T01:24:35Z",
          "updatedAt": "2024-01-24T01:24:35Z"
        }
      ]
    },
    {
      "number": 373,
      "id": "I_kwDOCrLn6M58l4BB",
      "title": "Improve connectivity:connection_id_updated",
      "url": "https://github.com/quicwg/qlog/issues/373",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "As reported by @hlandau on the mailing list:\r\n\r\nconnectivity:connection_id_updated\r\n\r\n  It would be nice to be able to optionally log CID-associated sequence\r\n  numbers and the type of CID source (ODCID, Initial CID,\r\n  preferred_address transport parameter, NCID frame, etc.)",
      "createdAt": "2024-01-19T11:13:39Z",
      "updatedAt": "2024-02-27T14:41:07Z",
      "closedAt": "2024-02-27T14:41:07Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, the intent is that this type of information can/should be inferred from other events surrounding the `connection_id_updated` event (e.g., receipt of NCID frames, receipt of an initial from the client, etc.)\r\n\r\nWhile conceptually we can add the fields you want to this event as well, we'd be getting deeper into \"everything can be logged in multiple ways\" territory (of which we already have too many imo), so I'm personally not the biggest fan.\r\n\r\nThat said, there's of course an argument that this would be useful for implementations not logging the full set of other events (though I'm not sure how much we want to pander specifically to this use case, as it would need adding other fields to other events as well). ",
          "createdAt": "2024-01-19T11:17:26Z",
          "updatedAt": "2024-01-19T11:17:26Z"
        },
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": "Hmm... so basically you're saying the preferred approach is to note connection IDs from logged NCID frames, etc., then correlate that to connection_id_updated.\r\n\r\nI think that's entirely valid, so I'm somewhat retracting this suggestion &mdash; no need to add redundancy here &mdash; unless other people think it's valuable.",
          "createdAt": "2024-01-19T19:12:20Z",
          "updatedAt": "2024-01-19T19:12:20Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Seems like we can close with no action.",
          "createdAt": "2024-02-19T03:37:38Z",
          "updatedAt": "2024-02-19T03:37:38Z"
        }
      ]
    },
    {
      "number": 374,
      "id": "I_kwDOCrLn6M58l7P9",
      "title": "Improve quic:stream_state_updated",
      "url": "https://github.com/quicwg/qlog/issues/374",
      "state": "OPEN",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "As reported by @hlandau on the mailing list:\r\n\r\nquic:stream_state_updated:\r\n\r\n  I think this needs to be clarified a little that an event logged here with both\r\n  a `stream_id` field and a `stream_side` field is expressing a state for that\r\n  component of the stream and from the perspective of the specified vantage point\r\n  (also, what about the network vantage point?); whereas an event logged here\r\n  with a `stream_id` field but no `stream_side` field is expressing a state for\r\n  both stream components as a whole.\r\n\r\n  If my interpretation here is correct, I think it would also help to note that\r\n  the valid values of StreamState depend on the value *and* presence of\r\n  stream_side.",
      "createdAt": "2024-01-19T11:19:58Z",
      "updatedAt": "2025-03-12T03:32:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Specifically for the \"network vantage point\" aspect of the question: the intent was that a network observer would use \"sending\" vs \"receiving\" depending on which party opened the stream, but that indeed falls down when using bidi streams... \r\n\r\nI think there is some overlap here with the stream_state values and their implied-ness for either one or both sides, but I think @LPardue has a better grasp on this than me. \r\n",
          "createdAt": "2024-01-19T11:23:23Z",
          "updatedAt": "2024-01-19T11:23:23Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue could use some input on this here :) ",
          "createdAt": "2024-06-24T14:01:25Z",
          "updatedAt": "2024-06-24T14:01:25Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": " I have never used this event myself and have little experience to impart. There's no text to describe how `stream_side` is supposed to be used, which isn't great. \r\n\r\nNot sure what to do here tbh\r\n",
          "createdAt": "2024-11-04T17:11:22Z",
          "updatedAt": "2024-11-04T17:11:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": " Given that\n\na ) this event describes itself as \n\n> The `stream_state_updated` event is emitted whenever the internal state of a\nQUIC stream is updated; see {{Section 3 of QUIC-TRANSPORT}}.\n\nb) QUIC is not intended to support on-path observation of its details\n\nc) To my knowledge, we have no network observer implementers that are stating this is a problem or providing input to the discussion\n\nI'm not particularly motivated to try and solve any theoretical complications for network observers. \n\nAssuming we agree on that, lets focus on the case of client or server endpoints. This event has a lot of fields and permutations, several of which don't make semantic sense - for example, there's no sense in emitting an event that claims a peer-initiated unidirectional stream was put into a \"data sent\" state. \n\nSimilarly, I don't think there's much logical sense to an stream updated event like \"stream_id=0, stream_side field omitted, new=data_sent\" because a bidirectional field has two stream states in opposite directions. \n\nHugo might disagree, since they say\n\n> whereas an event logged here\nwith a stream_id field but no stream_side field is expressing a state for\nboth stream components as a whole.\n\nbut I tend to disagree that its going to be that common to have a full duplex stream to have consistent stream states.\n\nSo how about this as an idea:\n\n*  make the stream_side field mandatory. They are already mandatory in QUICs stream model. That removes ambiguity in an already complicated puzzle.\n* add an optional initiator field (client, server) to augment the stream_type field. Both initiator and type are already encoded in the stream ID, so these are just crutches to avoid maths\n\nThese steps won't prevent garbage values but will make it cleaer what to do. If we really want to support the idea of \"both sides closed all duplexes and the stream is completely closed\" then add a \"both\" value to stream_side and write some text to explain that.",
          "createdAt": "2025-03-12T03:32:54Z",
          "updatedAt": "2025-03-12T03:32:54Z"
        }
      ]
    },
    {
      "number": 375,
      "id": "I_kwDOCrLn6M58l-nN",
      "title": "Improve quic:stream_data_moved",
      "url": "https://github.com/quicwg/qlog/issues/375",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx",
        "LPardue"
      ],
      "labels": [],
      "body": "As reported by @hlandau on the mailing list:\r\n\r\nquic:stream_data_moved:\r\n\r\n  A brief explanation of each from/to value here and the intended meaning would\r\n  be a big improvement. Also clarify that raw here refers to the referenced\r\n  stream application data (and does not include frame headers etc.).\r\n\r\n  Consider having a way to report when the end-of-stream (FIN) condition is\r\n  reported to an application. One option here is to have an optional \"fin\" field\r\n  here.\r\n\r\n  There does not appear to be any way to communicate when a stream reset event is\r\n  delivered to an application in an equivalent way, which would be useful.\r\n\r\nquic:datagram_data_moved:\r\n\r\n  As with stream_data_moved, clarify meaning of the from/to fields here.",
      "createdAt": "2024-01-19T11:26:23Z",
      "updatedAt": "2024-07-03T13:20:51Z",
      "closedAt": "2024-07-03T13:20:51Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While I can do the first part here (explain the from/to intents), I think @LPardue is more qualified to help with how we best indicate other signals have been delivered from transport to application.\r\n\r\nI know that has a long history of discussion in general, and I personally don't think this should be part of the `data_moved` event (i.e., would need a new event in my opinion)",
          "createdAt": "2024-01-19T11:27:46Z",
          "updatedAt": "2024-01-19T11:27:46Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "There's already a lot of text in these sections, personally I don't think explaining each field is going to be much more help. \r\n\r\nRe: `raw` raking it clear it is stream data not frames is a couple of words and worth it. \r\n\r\nI can see some value in the ability to indicate when an app requests a stop_sending or a reset_stream or when either is passed up to an app. I think that's a new event though.\r\n\r\nFor stream fin, I could argue a few ways. I think a `? fin: bool` field on stream_data_moved is probably the best tradeoff.",
          "createdAt": "2024-01-28T20:08:18Z",
          "updatedAt": "2024-01-28T20:08:52Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in editors meeting.\r\nRobin: not the biggest fan of adding `fin` + some additional fields for stop_sending and reset_stream, but option.\r\nMarten and Lucas: similar APIs in implementation: fin is possibly separate from the others (which are passed as errors). Errors often don't get communicated directly when happen, but only when application tries to read. So it does make sense to have it in `stream_data_moved` maybe. \r\nLucas: will propose a PR to add these signals to `stream_data_moved`\r\n\r\n\r\n",
          "createdAt": "2024-02-05T09:48:20Z",
          "updatedAt": "2024-02-05T09:48:20Z"
        }
      ]
    },
    {
      "number": 376,
      "id": "I_kwDOCrLn6M58l__5",
      "title": "Clarify security: key events",
      "url": "https://github.com/quicwg/qlog/issues/376",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [],
      "body": "As reported by @hlandau on the mailing list:\r\n\r\nsecurity:key_updated:\r\n\r\n  Clarify use of the generation field here, which is introducing a new concept\r\n  not directly touched on by the QUIC RFCs, which just deal in the Key Phase bit.\r\n  Provide examples for the first few generation numbers (for example, presumably\r\n  the first 1-RTT EL key has a generation of 0). Also clarify how this interacts\r\n  with the temporal behaviour of the key update process (since old keys are\r\n  retained to handle reordered packets). Presumably once a new key exists, it is\r\n  logged with a new generation number and the old key is eventually given a\r\n  key_discarded event with the old generation number. But this should be\r\n  clarified.\r\n\r\nsecurity:key_discarded:\r\n\r\n  As above.",
      "createdAt": "2024-01-19T11:29:29Z",
      "updatedAt": "2024-02-08T02:03:58Z",
      "closedAt": "2024-02-08T02:03:58Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during editors meeting. \r\nMarten agrees this is an issue and will propose a PR (maybe just renaming `generation` to `key_phase`?)",
          "createdAt": "2024-02-05T09:38:34Z",
          "updatedAt": "2024-02-05T09:38:34Z"
        }
      ]
    },
    {
      "number": 377,
      "id": "I_kwDOCrLn6M58mA3t",
      "title": "Add congestion control name to recovery:parameters_set",
      "url": "https://github.com/quicwg/qlog/issues/377",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "As reported by @hlandau on the mailing list:\r\n\r\nrecovery:parameters_set:\r\n\r\n  A minor point, but I suppose it may be useful to have a field for a name of a\r\n  congestion control algorithm here, defined as \"newreno\" / text (with \"newreno\"\r\n  being the algorithm specified in RFC 9002).\r\n",
      "createdAt": "2024-01-19T11:31:21Z",
      "updatedAt": "2024-02-05T09:36:59Z",
      "closedAt": "2024-02-05T09:36:59Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a hard one. Of the QUIC implementations that implement NewReno, most of them tweak the algorithm described in RFC 9002 at least a little bit. So if you actually want to know what the congestion control algorithm is, you'll have to look at the NewReno as implemented in version x.y of that QUIC stack.",
          "createdAt": "2024-01-19T14:09:59Z",
          "updatedAt": "2024-01-19T14:09:59Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Yeah in principle this sounds nice. But I don't think there is much robust interop opportunity around such a string. Marten highlighted one reason with version, other factors include other parameters of the software or environment. \r\n\r\nI could theorise how I could use this myself to assess e.g. experiments. But then I can just do that in custom fields that I would consume myself.",
          "createdAt": "2024-01-19T14:34:44Z",
          "updatedAt": "2024-01-19T14:34:44Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do feel there is value in this even if you just get a general \"algorithm family\" out of it. \r\n\r\nSay you're a new user of the library or a researcher and you -think- you've configured stuff to use Algorithm B instead of A, this is an easy way to check if that actually works correctly (or conversely to get an idea of what type of thing it's doing by default in the first place without digging through the code). \r\n\r\nI do agree it shouldn't go beyond \"newreno\" or \"bbrv1\" or something like that, and I'm not even sure we need to specify any values in the qlog docs, just the field name.",
          "createdAt": "2024-01-19T15:35:38Z",
          "updatedAt": "2024-01-19T15:35:38Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I dont buy that use case much. If you can actually configure an instance, then you should have confidence you know what you're doing, otherwise a lot of bets are off and I don't think logging helps. But if they want that capability, sticking the config in the trace description seems fine to me.\r\n\r\nAlgorithm names on their aren't useful IMO - especially if theres no standard for them.\r\n\r\nquiche supports different algorithms and hyststart++ as different composable config. \r\n\r\nThis event already supports articulating various stuff that could be relevant but not standard if someone really wants it inside the event\r\n\r\n> this event can contain any number of unspecified fields to support different recovery approaches.",
          "createdAt": "2024-01-19T16:13:20Z",
          "updatedAt": "2024-01-19T16:13:20Z"
        },
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": "Yeah, my intention here is definitely not any kind of \"interop\". But it is useful information to know the broad class of family being used IMO.\r\n\r\nI don't think the \"people should know what they're doing\" argument holds water &mdash; people may be switching between different algorithms frequently for experimental purposes and thus have a large collection of QLOG traces using different algorithms.\r\n\r\nIt's not essential since people can add custom fields. But if many different implementations are going to log this, it's certainly more convenient if they use the same field name.",
          "createdAt": "2024-01-19T16:18:38Z",
          "updatedAt": "2024-01-19T16:18:38Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "We need a higher bar than it might be common and helpful. Standardising a field requires explaining what's its purpose is and how it should be used.\r\n\r\n If I want to experiment with congestion control I will likely be playing with several parameters. A high level family name cant articulate that. Instead, I might want to write my own structured format for all the knobs that I can control. In which case the standard field would be redundant.",
          "createdAt": "2024-01-19T16:24:43Z",
          "updatedAt": "2024-01-19T16:24:43Z"
        },
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": "After reflecting on the \"philosophy of qlog\" in these two comments: https://github.com/quicwg/qlog/issues/371#issuecomment-1900972178\r\n\r\nI think I now agree and that we don't need to do this.\r\n",
          "createdAt": "2024-01-24T07:28:40Z",
          "updatedAt": "2024-01-24T07:28:40Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during editors meeting.\r\nClosing without action; proposed solution is to use custom per-implementation fields if needed (since no 2 Reno implementations are even alike and we don't want full parameters for every possible config)",
          "createdAt": "2024-02-05T09:36:59Z",
          "updatedAt": "2024-02-05T09:36:59Z"
        }
      ]
    },
    {
      "number": 378,
      "id": "I_kwDOCrLn6M58mGt0",
      "title": "Clarify use of StreamFrame",
      "url": "https://github.com/quicwg/qlog/issues/378",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "As reported by @hlandau on the mailing list:\r\n\r\nStreamFrame:\r\n\r\n  This format has ambiguity as to whether explicit length and/or offset\r\n  fields were used. It is potentially useful to know this, or the\r\n  numeric value of the stream type field.\r\n\r\n  Being able to know the header length for overhead calculation would\r\n  also be valuable IMO.\r\n\r\n  It may be worth explicitly clarifying that it is not possible to use\r\n  this object to log information about a stream frame without logging\r\n  the value of the FIN bit, as the presence or absence of this bit is\r\n  inferred from presence or absence of the FIN field.",
      "createdAt": "2024-01-19T11:43:01Z",
      "updatedAt": "2024-02-05T09:35:30Z",
      "closedAt": "2024-02-05T09:35:29Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, for the two top things, there the intent is to use the `raw` field if that type of depth is needed (up until now, nobody has asked for this, so we assumed this was sufficient, and I'm still of that opinion ;))\r\n\r\nFor the bottom one, I agree, but I don't quite see how this is an issue in practice? ",
          "createdAt": "2024-01-19T11:44:25Z",
          "updatedAt": "2024-01-19T11:44:25Z"
        },
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": ">For the bottom one, I agree, but I don't quite see how this is an issue in practice?\r\n\r\nNot really an issue &mdash; just thought it worth pointing out. If there is an explicit decision that this isn't an issue, that's fine, but it could also easily have been accident, so just thought I'd point it out.",
          "createdAt": "2024-01-19T16:22:08Z",
          "updatedAt": "2024-01-19T16:22:19Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during editors meeting. Seems to not be (much of) an issue in practice, so decided to close without action.",
          "createdAt": "2024-02-05T09:35:29Z",
          "updatedAt": "2024-02-05T09:35:29Z"
        }
      ]
    },
    {
      "number": 379,
      "id": "I_kwDOCrLn6M583n4L",
      "title": "Should we use \"* text => uint64\" anywhere that a type can contain extension fields?",
      "url": "https://github.com/quicwg/qlog/issues/379",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "In H3 [parameters_set](https://quicwg.org/qlog/draft-ietf-quic-qlog-h3-events.html#name-parameters_set) , we have a\r\n\r\n```\r\n; additional settings for grease and extensions\r\n    * text => uint64\r\n```\r\n\r\nif I grok CDDL correctly, this allows us to have any number of pairs that would serialize like \r\n\r\n```\r\n\"my_sekret_extension\": 123,\r\n\"9999\": 0\r\n```\r\n\r\nIt got me thinking a bit. This isn't explained super clearly and people might overlook it. Maybe there's more use for this in some other types. Leading to, maybe we should define this as a generic tuple type in the base spec along with some text, then we can reuse it across various events?",
      "createdAt": "2024-01-22T23:23:47Z",
      "updatedAt": "2024-06-24T13:22:36Z",
      "closedAt": "2024-06-24T13:22:36Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So this is the intent of the `* text => any` mention in the main schema here: https://www.ietf.org/archive/id/draft-ietf-quic-qlog-main-schema-07.html#name-events\r\n\r\nSo, arguably, the extra mention in `parameters_set` should be removed/replaced with a reference to that instead. \r\n\r\nI'm not a big fan of explicitly adding that to all events (too much clutter). ",
          "createdAt": "2024-01-30T10:41:59Z",
          "updatedAt": "2024-01-30T10:41:59Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I don't think that works for my needs from a composition perspective. I want to extend `$ProtocolEventBody` so that the extension is specific to a single type, not extend the entire event.",
          "createdAt": "2024-01-30T11:46:51Z",
          "updatedAt": "2024-01-30T11:46:51Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in meeting.\r\nLucas: main intent is to formally allow any event to be extensible (instead of having to copy-paste all event parameters to a new event name). Currently possible in code of course, but not in proper CDDL schema. \r\nRobin: probably not possible without making everything a socket, but need to double check with CDDL defs. ",
          "createdAt": "2024-02-05T09:34:35Z",
          "updatedAt": "2024-02-05T09:34:35Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, turns out this is possible in a relatively simple way.\r\n\r\nI thought we would have to make every event their own \"type socket\" (like `$protocolEventBody` or `$quicFrame`), but it turns out we can make do with \"group sockets\" (they use $$ instead of $ and don't require all the boilerplate the other sockets need). Both are described here: https://datatracker.ietf.org/doc/html/rfc8610#section-3.9\r\n\r\nI have a more extensive example at #400, but that's only for 2 events (`parameters_set` and `parameters_restored`). \r\n\r\nIf we want to allow this for all events, this is possible, but would require adding something like this on the bottom of each event definition:\r\n\r\n```\r\n* $$quic-eventname-extension\r\n```\r\n\r\nThat's basically all that's needed... (which is much less than what's needed for the \"type sockets\").\r\n\r\nWith that, you can specify new fields on a per-event basis by extending one specific extension point, which is IIUC what @LPardue asked here. \r\n\r\nSo say there's a new extension that adds 2 loss bits and you want to add those to the packet_sent event:\r\n\r\n```\r\n$$quic-packetsent-extension //= (\r\n    q_bit: bool\r\n    ? l_bit: bool\r\n)\r\n```\r\n\r\nNote that this can also be used for other things than events (e.g., `H3Parameters`). It won't work for extending things like ENUMs (or e.g., `H3Setting`), but for that we can still use the more verbose \"type sockets\" that we've been doing before if needed. \r\n\r\n----\r\n\r\nThe main downside is that all the new fields are by definition optional when regarded in the complete schema, because for now, we of course don't have any extensions yet, so we have to do `* $$quic-eventname-extension` (there will be zero or more) or `? $$quic-eventname-extension` (they are optional) in our current definition. So even if later extensions mandate a new field (as the example above, q_bit is mandatory), this wouldn't be enforced in the combined schema.\r\n\r\nThere are of course workarounds for this (e.g., script that gathers CDDL from all docs can remove the * or ? before the used $$ fields so they do properly track this), but it's good to be aware of this. \r\n\r\nAFAICT, there is no way to prevent this without additional boilerplate (e.g., we could not use * or ?, but then we'd have to define an (empty) extension for each of these in the current documents... annoying). \r\n\r\n---\r\n\r\nI propose we track this general issue here going forward (instead of related #261, #176, #170, #124, #192, #297).\r\n\r\nI could use some opinions on this here @LPardue @marten-seemann @lnicco :) \r\n\r\n",
          "createdAt": "2024-02-29T15:53:48Z",
          "updatedAt": "2024-03-04T11:44:36Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Nice. The caveats sound fine to me (but my understanding isn't as comprehensive as yours). It does sound to me that we'll probably want to have some support in place for future extensions to help get validated but that is outside the scope of the qlog documents themselves.",
          "createdAt": "2024-03-02T02:54:18Z",
          "updatedAt": "2024-03-02T02:54:18Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue yes, it's definitely possible to get future extensions to be properly validated by the CDDL tooling. The moment they have a concrete extension in place, it suffices to change `* $$quic-eventname-extension` to `$$quic-eventname-extension` (remove the `*`) so the field will no longer be seen as \"zero or more\" but instead \"one\" and the tooling will properly track optional/required fields in the extension as expected (tested this with the ruby gem last week). ",
          "createdAt": "2024-03-04T09:27:49Z",
          "updatedAt": "2024-03-04T09:27:49Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The proposal on #400 would allow me to support the `send_at_time` custom field we have in quiche \ud83d\udc4d \r\n\r\nhttps://github.com/cloudflare/quiche/blob/master/qlog/src/events/quic.rs#L649\r\n\r\nI think it would like like this\r\n\r\n```\r\n~~~~~~~~\r\n$$quic-packetsent-extension //= (\r\n  ? sent_at_time: float\r\n)\r\n~~~~~~~~",
          "createdAt": "2024-03-04T09:44:43Z",
          "updatedAt": "2024-03-04T09:44:43Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during editors meeting:\r\nMerge #400 now\r\nRobin: Create new PR that adds extension sockets to all events (and other types where needed, like `H3Setting`), discuss during Brisbane meeting ",
          "createdAt": "2024-03-04T09:47:01Z",
          "updatedAt": "2024-03-04T09:47:01Z"
        }
      ]
    },
    {
      "number": 382,
      "id": "I_kwDOCrLn6M59IsSM",
      "title": "H3Settings is a bit underspecified",
      "url": "https://github.com/quicwg/qlog/issues/382",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://quicwg.org/qlog/draft-ietf-quic-qlog-h3-events.html#section-5.3.4\r\n\r\n```\r\nH3Setting = {\r\n    name: text\r\n    value: uint64\r\n}\r\n```\r\n\r\nLooking at IANA https://www.iana.org/assignments/http3-parameters/http3-parameters.xhtml, I think qlog nudges implementations to log the setting name. When an implementation receives an unknown setting (not a greased one) it won't know the name. It could log the setting type value code in the name field, but that is not specified. This makes things annoying for parsers since they need to do some thinking. \r\n\r\nOne suggestion is to add another field like `type` that could contain the numerical type value. It would be duplicative to have both, so that might require making `type` and `name` optional.",
      "createdAt": "2024-01-25T02:10:19Z",
      "updatedAt": "2024-06-27T20:14:43Z",
      "closedAt": "2024-06-27T20:14:43Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Also we might want to state that the name should be the name IANA use, possiblyeven define a explicit names in addition to free form string.",
          "createdAt": "2024-01-25T02:15:12Z",
          "updatedAt": "2024-01-25T02:15:12Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during meeting. \r\nAgree to add this option, similar to how we changed ALPN in #385 ",
          "createdAt": "2024-02-05T09:17:58Z",
          "updatedAt": "2024-02-05T09:17:58Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another thing I'm wondering is if we should clarify what the `name` field is exactly.\r\n\r\ni.e., I've previously logged this myself as `QPACK_MAX_TABLE_CAPACITY` but the IANA name is prefixed with `SETTINGS_`, so `SETTINGS_QPACK_MAX_TABLE_CAPACITY` instead. \r\n\r\nYou could argue this should be obvious, but e.g., in RFC9204, they use the unprefixed version (see https://www.rfc-editor.org/rfc/rfc9204.html#section-8.1) with a note `For formatting reasons, the setting names here are abbreviated by removing the 'SETTINGS_' prefix.`... could be quite confusing for novice implementers, so maybe 1 example or clear statement that the name is the IANA registered name would be good. ",
          "createdAt": "2024-02-05T14:55:23Z",
          "updatedAt": "2024-02-05T15:00:03Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Agree 100%, I'll add some text",
          "createdAt": "2024-02-05T18:48:11Z",
          "updatedAt": "2024-02-05T18:48:11Z"
        }
      ]
    },
    {
      "number": 387,
      "id": "I_kwDOCrLn6M5-ChUf",
      "title": "packet_sent doesn't allow logging of IP address (for packets sent outside of a connection)",
      "url": "https://github.com/quicwg/qlog/issues/387",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "This would be interesting for Version Negotiation, Retry, CONNECTION_CLOSE etc. sent by a server.",
      "createdAt": "2024-02-02T10:23:57Z",
      "updatedAt": "2024-06-10T09:47:42Z",
      "closedAt": "2024-06-10T09:47:41Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during meeting.\r\nRobin: not a big fan of this; use `datagrams_*` instead or `group_id`/`path_id` or custom field or separate trace\r\nLucas: not super-strong opinion there \r\nMarten: imo server log sending out retries should log everything in a single event, not spilt out\r\nRobin: will think about it some more; get back to you\r\n\r\nsee also #211 ",
          "createdAt": "2024-02-05T09:14:25Z",
          "updatedAt": "2024-02-05T09:25:04Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, still not a big fan of having this separately from `path_id` (see #336) or conceptually `group_id`.\r\n\r\nI get that logging a separate `path_assigned` event is annoying for this type of thing, but there you could also choose to just log the IP addresses as the `pathID` as that's a string (see for example slide 5 here: https://datatracker.ietf.org/meeting/118/materials/slides-118-quic-qlog-00). \r\n\r\nI'm mostly afraid that if you add ip fields to all these events, people will use them for \"normal\" logs as well, not just for the use cases you describe, which is something I -really- want to discourage. ",
          "createdAt": "2024-03-01T15:05:57Z",
          "updatedAt": "2024-03-01T15:05:57Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@marten-seemann now that https://github.com/quicwg/qlog/pull/336 has been merged, and with my comments above, do you think we can close this issue? ",
          "createdAt": "2024-06-10T09:07:43Z",
          "updatedAt": "2024-06-10T09:07:43Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during editor's meeting.\r\n\r\nMarten: really useful to log events outside connections for debugging\r\nLucas: true, but in practice we don't do this at scale because we get so much bad stuff. Have whole DDoS protection layers to protect against this. Also annoying to link outside connection events to actual connections (e.g., VNEG/RETRY).\r\n\r\nMarten: proposed adding separate events to explicitly log this stuff\r\nRobin: seems too much work/overhead just to add ip address info. Feel like the pathID \"hack\" proposed above allows for this use case.\r\nMarten: I can work, but it's dirty. Paths aren't necessarily 4-tuples; abusing fact that pathID is a string\r\nRobin: true... but if you look at how `PathEndpointInfo` is defined, that's basically also just a 4-tuple? You would just skip the `path_assigned` step by serializing it yourself.\r\nMarten: don't want to make it more complicated than necessary. I don't like the pathID solution, really don't, but creating new events/category seems like a lot of overhead.\r\n\r\nRobin: ok. For now then just closing this issue without action; use pathID for this use case. Open to revisiting later if more feedback from the field comes in. \r\n",
          "createdAt": "2024-06-10T09:47:42Z",
          "updatedAt": "2024-06-10T09:47:42Z"
        }
      ]
    },
    {
      "number": 391,
      "id": "I_kwDOCrLn6M5_Y-Le",
      "title": "`ConnectionClose` storing a uint64 error_code and a uint64 error_code_value seems redundant",
      "url": "https://github.com/quicwg/qlog/issues/391",
      "state": "CLOSED",
      "author": "evanrittenhouse",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As the title states, I don't quite see a reason for [`ConnectionClose`](https://quicwg.org/qlog/draft-ietf-quic-qlog-quic-events.html#name-connectioncloseframe) to have both `error_code` and `error_code_value` store uint64s. It seems like it may be clearer if either:\r\n1. `error_code` is some non-uint64 value\r\n2. `error_code` is a uint64, but `error_code_value` drops out of the event.",
      "createdAt": "2024-02-15T19:16:42Z",
      "updatedAt": "2024-02-19T09:21:44Z",
      "closedAt": "2024-02-19T09:21:44Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "So the current definition is \r\n\r\n```\r\nErrorSpace = \"transport\" /\r\n             \"application\"\r\n\r\nConnectionCloseFrame = {\r\n    frame_type: \"connection_close\"\r\n    ? error_space: ErrorSpace\r\n    ? error_code: TransportError /\r\n                  $ApplicationError /\r\n                  uint64\r\n    ? error_code_value: uint64\r\n    ? reason: text\r\n\r\n    ; when error_space === \"transport\"\r\n    ? trigger_frame_type: uint64 /\r\n                          text\r\n}\r\n```\r\n\r\nTransportError and ApplicationError are \"strongly typed\" strings. An endpoint that receives an unknown code should be able to log the raw number as a uint64. The big question is why do `error_code` and `error_code_value` both allow that? I think we should just pick one way.",
          "createdAt": "2024-02-15T19:21:08Z",
          "updatedAt": "2024-02-15T19:21:08Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, IIRC, the original intent here was to log all necessary details for the `CRYPTO_ERROR` error space (as also indicated in the prose preceeding the CDDL in the doc: \"The error_code_value field is the numerical value without variable-length integer encoding. This is useful because some error types are spread out over a range of codes (e.g., QUIC's crypto_error).\")\r\n\r\nWhy? Because in [RFC9000, CRYPTO_ERROR is a range of errors](https://www.rfc-editor.org/rfc/rfc9000.html#section-20.1):\r\n\r\n```\r\nCRYPTO_ERROR (0x0100-0x01ff):\r\nThe cryptographic handshake failed. A range of 256 values is reserved for carrying error codes specific to the cryptographic handshake that is used. Codes for errors occurring when TLS is used for the cryptographic handshake are described in [Section 4.8](https://www.rfc-editor.org/rfc/rfc9001#section-4.8) of [[QUIC-TLS](https://www.rfc-editor.org/rfc/rfc9000.html#QUIC-TLS)].\r\n```\r\n\r\nAs such, originally in qlog, you'd for example have `error_code: \"crypto_error\"` and `error_code_value: 0x0111` so you can have both the high-level error_code string AND the specific value of the 256 range.\r\n\r\nHOWEVER I changed this down the line to have[ the separate `CryptoError` struct](https://quicwg.org/qlog/draft-ietf-quic-qlog-quic-events.html#section-8.12.25) as part of TransportError that says this:\r\n\r\n```\r\n; all strings from \"crypto_error_0x100\" to \"crypto_error_0x1ff\"\r\nCryptoError = text .regexp \"crypto_error_0x1[0-9a-f][0-9a-f]\"\r\n```\r\n\r\nAnd I probably just forgot to remove `error_code_value`. \r\nSo, if we agree that the latter approach is a good one, we can indeed leave out `error_code_value` :) \r\n\r\nHowever, I do remember this having some weirdness with proper CDDL (i.e., can't merge both an enum (TransportError) and a separate type like CryptoError, which is why it's indicated purely as prose in the current docs). \r\n\r\nSo I think the final solution depends on how strictly we want to adhere to CDDL :) \r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2024-02-15T19:42:05Z",
          "updatedAt": "2024-02-15T19:43:13Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "can we do this (and update the prose accordingly)?\r\n\r\n```\r\nConnectionCloseFrame = {\r\n    frame_type: \"connection_close\"\r\n    ? error_space: ErrorSpace\r\n    ? error_code: TransportError /\r\n                  CryptoError /\r\n                  $ApplicationError /\r\n                  uint64\r\n    ? reason: text\r\n\r\n    ; when error_space === \"transport\"\r\n    ? trigger_frame_type: uint64 /\r\n                          text\r\n}\r\n```",
          "createdAt": "2024-02-15T19:59:15Z",
          "updatedAt": "2024-02-15T19:59:15Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Without running the CDDL validator, I'm guessing yes :) That would be the most practical solution I think! ",
          "createdAt": "2024-02-15T20:03:37Z",
          "updatedAt": "2024-02-15T20:03:37Z"
        }
      ]
    },
    {
      "number": 397,
      "id": "I_kwDOCrLn6M6Aj2XC",
      "title": "Split out ECN \"capable\" state",
      "url": "https://github.com/quicwg/qlog/issues/397",
      "state": "OPEN",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [],
      "body": "`ECNState` currently has 4 different options.\r\n\r\nDuring IETF 118, it was mentioned by @mirjak that the `capable` option is potentially not fine-grained enough.\r\nI don't know enough about ECN/L4S to know what the change should be here, but the discussion is on YouTube here: https://youtu.be/qbAm_HfLv_c?feature=shared&t=4419\r\n\r\nSomething for @marten-seemann to follow-up on",
      "createdAt": "2024-02-27T15:23:30Z",
      "updatedAt": "2024-02-27T16:36:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I don't think you need more fine-grained options for the capable ECNState but maybe another state to indicate if the sender, that is in the capable state, also marks packets as ECN capable. In the capable state it can mark packets with either Not-ECT, ECT(0), ECT(1). Where ECT(1) is used to indicate L4S support. ",
          "createdAt": "2024-02-27T16:36:38Z",
          "updatedAt": "2024-02-27T16:36:38Z"
        }
      ]
    },
    {
      "number": 398,
      "id": "I_kwDOCrLn6M6Aq7o2",
      "title": "Difference between negotiated vs actually accepted/enabled TPs",
      "url": "https://github.com/quicwg/qlog/issues/398",
      "state": "OPEN",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "Spinoff/splitoff from #369.\r\n\r\n@hlandau  originally reported for `quic:parameters_set`:\r\n\r\nI think this event needs more clarify in terms of the distinction between\r\nattempting to negotiate a feature and it being enabled. It should be possible\r\nto log the feature set a local or remote endpoint is requesting and it\r\nshould be possible to log the actually negotiated feature set. Possibly\r\nthis can be resolved via simple clarification. If a client connects to\r\na server, does it start by emitting parameters_set (owner=local) with (e.g.)\r\nmax_datagram_frame_size set, and then when the server responds without\r\nit, emit parameters_set (owner=remote) without it? I guess this allows\r\nthe necessary information to be inferred.\r\n\r\nIf the absence of a field indicates it was not negotiated after receiving\r\ntransport parameters from a server, this creates a problem if this event has\r\nto be used to log other parameters determined at different times (which seems\r\nplausible for tls_cipher, early_data_enabled, etc.), as then logging\r\nthose parameters could be misinterpreted as a sign that the transport\r\nparameters have been received and a feature has not been negotiated.\r\nEither the cause of a parameters_set event should be clarified (maybe a trigger\r\nfield) or possibly this should be split into different event types.",
      "createdAt": "2024-02-28T11:26:54Z",
      "updatedAt": "2024-06-24T15:26:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are imo 2 things here, 1 per paragraph:\r\n\r\n1. The intent is indeed to log (at least) 2 `parameters_set` events. One with `owner=local` for the ones you send to the peer, and one with `owner=remote` with ones you receive from the peer. Comparing the values in the two SHOULD be enough to deduce the actually negotiated features/values. If not, the solution would be to emit a third `parameters_set` event reflecting the final value (e.g., at the client, you'd have `owner=local`, then `owner=remote` for what you got from the server and then again `owner=local` to reflect the final values you \"set\" at the client side that will be used). I don't immediately see an existing TP for which this approach would not work. Do you think this is sufficient to resolve your first paragraph @hlandau? If it's indeed a question of a \"simple clarification\" being needed, would you be able to suggest text for such a clarification that would make it easier for you?\r\n\r\n2. I must admit I don't fully understand this part. Specifically \"as then logging those parameters could be misinterpreted as a sign that the transport parameters have been received and a feature has not been negotiated\". Could you give a concrete example of such a case happening? An important aspect here is that the naming is a bit annoying, as it's `parameters_set` but it's not just the literal \"transport parameters\" but much more general \"parameters\" as a whole. So using the event to log non-TP parameters (e.g., early_data_enabled) MUST NOT be inferred to say that this also means that TPs have been received/negotiated (maybe that's also just a clarification then?). If you still feel a trigger would be a good solution, could you give a few examples of such triggers to help my understanding? Thanks :) ",
          "createdAt": "2024-02-28T11:33:35Z",
          "updatedAt": "2024-02-28T11:33:35Z"
        },
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": "1 sounds good to me and makes sense.\r\n\r\nFor 2, an example scenario:\r\n\r\n- Client sends handshake, TPs include idle timeout TP, parameters_set(owner=local, idle_timeout=...) logged\r\n- Server sends handshake, TP include idle timeout TP, parameters_set(owner=remote, idle_timeout=...) logged\r\n- Some other event on the client happens which causes parameters_set(owner=local, foo=...) to be logged\r\n- This obviously should not imply `idle_timeout` is no longer configured.\r\n- But for a parameters_set event which is TP-triggered, absence of `idle_timeout` seems to imply it was not sent.\r\n\r\nOK, thinking about it, is the intention here to have \"stateful\" handling of this where a qlog consumer models the current state as the product of all events? i.e.,\r\n\r\n```\r\ncurParams.idleTimeout = UNSET\r\nfor each params event:\r\n  if event.idleTimeout is present:\r\n    curParams.idleTimeout = event.idleTimeout\r\n```\r\n\r\nThat works but should be made clear. Can a param transition back to its \"unset\" value using `null` explicitly? Or is `null` the same as a field being missing?\r\n\r\nHere's some wording I've come up with quickly, feel free to mess with it:\r\n\r\n```\r\nSome parameters are the result of negotiation between peers. In this case, one\r\nendpoint generally suggests a possible value for a parameter and its peer then\r\nsuggests another possible value. The value used is the result of some\r\nparameter-specific function applied over those two suggested values.\r\nSuch negotiation SHOULD be expressed as a series of `parameters_set` events.\r\nFor example:\r\n\r\n- The local endpoint logs a `parameters_set` event with an `owner` of `local`\r\n  reflecting the negotiated parameter values it would like to use.\r\n- The local endpoint receives parameter values from the peer and logs a\r\n  `parameters_set` event with an `owner` of `remote` reflecting the desired\r\n  values expressed by the peer.\r\n- The local endpoint logs a `parameters_set` event with an `owner` of `local`\r\n  reflecting the negotiated parameter values determined from the two sets\r\n  of paramater values communicated by the local and remote endpoints.\r\n\r\nEach parameter in a `parameters_set` event supersedes the previous value of that\r\nparameter if present. If a parameter does not appear in a given `parameters_set`\r\nevent, its value is unchanged from the previous event which set that parameter.\r\nIf a parameter never appears in a `parameters_set` event, it retains its default\r\nvalue. A default value may be restored by specifying a JSON value of `null` for\r\na parameter, which is semantically distinct from the absence of a parameter in a\r\n`parameters_set` event.\r\n```",
          "createdAt": "2024-03-06T00:46:59Z",
          "updatedAt": "2024-03-06T00:46:59Z"
        }
      ]
    },
    {
      "number": 399,
      "id": "I_kwDOCrLn6M6ArF_H",
      "title": "Logging spin bit policy",
      "url": "https://github.com/quicwg/qlog/issues/399",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Splitoff of #369.\r\n\r\n@hlandau said:\r\n\r\nI think it would be valuable to have the ability to log information\r\nsuch as spin bit policy (e.g. enabled, disabled due to random chance,\r\ndisabled administratively), independent of the actual spin_bit_updated\r\nevent).\r\n\r\n@LPardue replied:\r\n\r\nPersonally I'm not interested in spending effort on that but if others want to propose text that fine.",
      "createdAt": "2024-02-28T11:49:51Z",
      "updatedAt": "2024-03-06T09:51:20Z",
      "closedAt": "2024-03-06T09:51:20Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @LPardue here that this is not something we should standardize here, though I'm also not 100% opposed to it if people contribute text.\r\n\r\nPersonally, I feel this should better be punted to if/when something like the Loss Bits proposal (https://datatracker.ietf.org/doc/draft-mdt-quic-explicit-measurements/00/) is adopted/RFC'd, so it can be tackled in 1 go. \r\n\r\nWould you be willing to contribute text @hlandau? Otherwise, we will close this with no action. \r\n",
          "createdAt": "2024-02-28T11:52:46Z",
          "updatedAt": "2024-02-28T11:52:46Z"
        },
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": "I think this can be closed for now. The amount of text that would be needed for it isn't congruent with the limited value I suspect. Can be revisited for draft-mdt-quic-explicit-measurements.",
          "createdAt": "2024-03-06T01:11:35Z",
          "updatedAt": "2024-03-06T01:11:35Z"
        }
      ]
    },
    {
      "number": 405,
      "id": "I_kwDOCrLn6M6BJIC9",
      "title": "Give concrete guidance on how to extend qlog",
      "url": "https://github.com/quicwg/qlog/issues/405",
      "state": "OPEN",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "editorial"
      ],
      "body": "With #417 and the `additional-schema` proposal, we're moving to a good state for qlog's extensibility. \r\n\r\nHowever, we feel additional prose is needed to make people make good use of this extensibility. Without it, we will mainly have the proper CDDL structures and some scattered prose, but no clear flowcharts/lists or similar. \r\n\r\nFor example, we can add TODOs for different use cases:\r\n- If you want to add a fully new protocol, do xyz\r\n- If you want to add new fields to an existing event, do abc\r\n- If you want to add new options to an ENUM, do def\r\n\r\nThis can only be done after the extensibility stuff is properly done though, so this issue is to remind us later ;) ",
      "createdAt": "2024-03-04T11:48:47Z",
      "updatedAt": "2025-03-12T03:41:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Marking this as editorial. \n\nI would suggest a fairly light touch here. I.e. add some short text in the main schema that describes the key points you outline. There's an increasing number of examples of actually using qlog extensibility that I think there's ample examples of these things without needing too many words or fake examples.",
          "createdAt": "2025-03-12T03:41:30Z",
          "updatedAt": "2025-03-12T03:41:58Z"
        }
      ]
    },
    {
      "number": 410,
      "id": "I_kwDOCrLn6M6BpHJ9",
      "title": "Connectivity::Connection_closed application trigger type is confusing",
      "url": "https://github.com/quicwg/qlog/issues/410",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "```\r\nConnectivityConnectionClosed = {\r\n\r\n    ; which side closed the connection\r\n    ? owner: Owner\r\n    ? connection_code: TransportError /\r\n                       CryptoError /\r\n                       uint32\r\n    ? application_code: $ApplicationError /\r\n                        uint32\r\n    ? internal_code: uint32\r\n    ? reason: text\r\n    ? trigger:\r\n        \"clean\" /\r\n        \"handshake_timeout\" /\r\n        \"idle_timeout\" /\r\n        ; this is called the \"immediate close\" in the QUIC RFC\r\n        \"error\" /\r\n        \"stateless_reset\" /\r\n        \"version_mismatch\" /\r\n        ; for example HTTP/3's GOAWAY frame\r\n        \"application\"\r\n}\r\n```\r\n\r\nGOAWAY doesn't close the connection, so I find this example a bit confusing.\r\n\r\nIn quiche, I would be able to close a connection using transport or an application CONNECTION_CLOSE and log that information in the other fields like `connection_code` etc. \r\n\r\nMaybe we should remove that trigger variant?",
      "createdAt": "2024-03-08T00:04:14Z",
      "updatedAt": "2024-07-08T19:07:31Z",
      "closedAt": "2024-07-08T19:07:30Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see the confusion. I think the intent was to make a difference between e.g., a programmer-triggered close on the QUIC level (\"clean\") vs a GOAWAY triggered one at the application level. Even though the GOAWAY doesn't immediately trigger the close directly, it was the conceptual \"trigger\" that led to the connection being closed down. Of course, you can make an argument that stacks won't track this and will not log this, and I can follow that :) \r\n\r\nI was also thinking of non-HTTP3 stuff running over QUIC however that might have application-level direct-close things (especially at the side initiating the close of course), so I wouldn't just do away with `application` here. Maybe just remove the comment? ",
          "createdAt": "2024-03-08T09:50:11Z",
          "updatedAt": "2024-03-08T09:50:11Z"
        }
      ]
    },
    {
      "number": 411,
      "id": "I_kwDOCrLn6M6Bz-7V",
      "title": "Logging non-UTF-8 reasons",
      "url": "https://github.com/quicwg/qlog/issues/411",
      "state": "CLOSED",
      "author": "hlandau",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Similarly to the ALPN string issue, we define the `CONNECTION_CLOSE` reason string here as text: https://github.com/quicwg/qlog/blob/57b679678b44d80234a0e10a08e53fe5ef9e7532/draft-ietf-quic-qlog-quic-events.md?plain=1#L313\r\n\r\nThe problem here is that RFC 9000 only says the reason string SHOULD be UTF-8. It could be arbitrary, or binary data, even if that is a bad idea.\r\n\r\nIt should be possible to log a reason string which an implementation sees which does not appear to be valid UTF-8.",
      "createdAt": "2024-03-10T20:18:29Z",
      "updatedAt": "2024-06-10T09:51:47Z",
      "closedAt": "2024-06-10T09:51:47Z",
      "comments": [
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": "This is related to this implementation issue: https://github.com/openssl/openssl/pull/23807",
          "createdAt": "2024-03-10T20:20:22Z",
          "updatedAt": "2024-03-10T20:20:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Agree, I just had to implement this and cast to the bytes to a lossy utf8. Let's make it possible in the spec to capture raw bytes .",
          "createdAt": "2024-03-10T20:43:05Z",
          "updatedAt": "2024-03-10T20:43:05Z"
        }
      ]
    },
    {
      "number": 413,
      "id": "I_kwDOCrLn6M6Cj2lP",
      "title": "Logging of HTTP field names or values that contain illegal bytes",
      "url": "https://github.com/quicwg/qlog/issues/413",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "While normally HTTP header names and values are expected to be safe strings (possibly with even further restrictions on the chartacter set that is allowed), it's possible that an endpoint could receive garbage bytes that it would validate and reject. In such scenarios, it can be useful to log what was received for the purposes of debugging root causes.\r\n\r\nThe [H3HeadersFrame](https://quicwg.org/qlog/draft-ietf-quic-qlog-h3-events.html#name-h3headersframe) uses the `H3HTTPField` type, where names and values use the `text` type. This is unfortunate as it forces implementers into certain approaches to logging. For instance, Rust has a `f[rom_utf8_lossy()](https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8_lossy)` method that would insert a \ufffd for an invalid sequence. While safe, this discards information that could be useful to understand excatly what was received.",
      "createdAt": "2024-03-17T01:51:48Z",
      "updatedAt": "2024-07-03T13:21:43Z",
      "closedAt": "2024-07-03T13:21:43Z",
      "comments": []
    },
    {
      "number": 416,
      "id": "I_kwDOCrLn6M6CsDrv",
      "title": "Discuss extensibility of extension points through type or group sockets",
      "url": "https://github.com/quicwg/qlog/issues/416",
      "state": "OPEN",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "With https://github.com/quicwg/qlog/pull/415 and the upcoming PR describing general extensibility, we won't yet have discussed guidelines for extending other stuff (e.g., $QuicFrame or $H3Parameters or $H3FrameType), so don't forget to add those once those two PRs are merged.\r\n\r\nAt that point, probably also best to move the socket extensibility discussion to the general extensibility section and add this new thing there as well.\r\n\r\n(this is mostly a DO NOT FORGET ABOUT THIS ROBIN issue)",
      "createdAt": "2024-03-18T15:48:21Z",
      "updatedAt": "2024-03-18T15:48:22Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 421,
      "id": "I_kwDOCrLn6M6NynFt",
      "title": "Make logging raw byte values consistent",
      "url": "https://github.com/quicwg/qlog/issues/421",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design"
      ],
      "body": "As detailed here https://github.com/quicwg/qlog/pull/383#issuecomment-2194521047, we're not really consistent in how we allow logging of raw byte values of individual fields, especially if they're \"unknown\"/don't map to a known string or name or type or...\r\n\r\nThis is a reminder to @rmarx to make a PR that makes this consistent across all events that currently don't use the `field_bytes: uint64` (or similar) pattern. ",
      "createdAt": "2024-06-27T18:36:20Z",
      "updatedAt": "2025-03-13T14:01:43Z",
      "closedAt": "2025-03-13T14:01:43Z",
      "comments": []
    },
    {
      "number": 423,
      "id": "I_kwDOCrLn6M6N8Y2j",
      "title": "Move Trigger section underneath Data section",
      "url": "https://github.com/quicwg/qlog/issues/423",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The general structure of section 6 is to walk through the common fields of `Event`. We say:\r\n\r\n> While this \"trigger\" field could be a property of the qlog Event itself, it is instead a property of the \"data\" field instead.\r\n\r\nTherefore, it seems more logical to move it underneath the Data section",
      "createdAt": "2024-06-29T02:38:11Z",
      "updatedAt": "2024-10-18T00:03:05Z",
      "closedAt": "2024-10-18T00:03:05Z",
      "comments": []
    },
    {
      "number": 425,
      "id": "I_kwDOCrLn6M6Oq-B0",
      "title": "Register application/qlog+json and application/qlog+json-seq media types",
      "url": "https://github.com/quicwg/qlog/issues/425",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "We already declare that these types exist and should be used but they aren't registered in https://www.iana.org/assignments/media-types/media-types.xhtml#application. We should follow the process described in the notes section at the top of that page. Note, we probably don't want to define `application/qlog` since we are serialization format agnostic and need the suffix to identify the actual format.",
      "createdAt": "2024-07-06T16:55:35Z",
      "updatedAt": "2025-03-12T03:50:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This is tightly linked to https://github.com/quicwg/qlog/issues/434. There's no point registering anything until that discussion is resolved.",
          "createdAt": "2025-03-12T01:14:50Z",
          "updatedAt": "2025-03-12T01:14:50Z"
        }
      ]
    },
    {
      "number": 426,
      "id": "I_kwDOCrLn6M6OtW3v",
      "title": "protocol_type or protocol_types",
      "url": "https://github.com/quicwg/qlog/issues/426",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We seem to like to pluralize field names where the value is an array, so this seem inconsistent\r\n\r\n> ? protocol_type: ProtocolTypeList",
      "createdAt": "2024-07-07T22:48:41Z",
      "updatedAt": "2024-09-30T09:54:51Z",
      "closedAt": "2024-09-30T09:54:51Z",
      "comments": []
    },
    {
      "number": 429,
      "id": "I_kwDOCrLn6M6PAt_n",
      "title": "How is \"trigger\" a common subfield of \"data\"?",
      "url": "https://github.com/quicwg/qlog/issues/429",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "In https://quicwg.org/qlog/draft-ietf-quic-qlog-main-schema.html#section-8.2-5 we say:\r\n\r\nAny generic key-value map type can be assigned to $ProtocolEventData (the only common \"data\" subfield defined in this document is the optional trigger field, see [Section 7.4](https://quicwg.org/qlog/draft-ietf-quic-qlog-main-schema.html#trigger-field)).\r\n\r\nI don't quite understand how this is a common field, since there is no CDDL for it. Should we be defining `$ProtocolEventData` with the actual optional `?trigger` field? Or is is more like \"common by convention\" or some other magic. \r\n\r\nOr is it actually the case that \"trigger\" is a design pattern that concrete event definitions can adopt but that they must explicitly declare the trigger field in their event definition?",
      "createdAt": "2024-07-09T22:25:37Z",
      "updatedAt": "2025-03-12T11:47:26Z",
      "closedAt": "2025-03-12T11:47:26Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "FWIW: Of this 40 events we define for QUIC and H3, only 10 of them currently define a trigger field.",
          "createdAt": "2024-07-09T22:41:42Z",
          "updatedAt": "2024-07-09T22:41:42Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's impossible to add the trigger field to `$ProtocolEventData` since new events aren't really inheriting from `$ProtocolEventData` but rather just adding themselves to it as a list of all possible events that can be used (put differently: `$ProtocolEventData` is an extensible ENUM, not a base class).\r\n\r\nWe don't really have a base class for events at this point, and so trigger is left as a bit of a loosely defined thing (more like as you say \"a design pattern that concrete event definitions can adopt but that they must explicitly declare the trigger field in their event definition\").\r\n\r\nGiven that we only have the one `trigger` field that would be common and that it's optional and not super-widespread, I personally think this is fine? \r\n",
          "createdAt": "2024-10-21T08:27:20Z",
          "updatedAt": "2024-10-21T08:27:20Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the explanation, that makes more sense. I think we can probably wordsmith the text on triggers a bit. I just reread section 8.2 and 8.2.1 and its seems a bit verbose. I think we can probably simplify this to something along the lines of \"if its useful for an event to include a trigger, then it is RECOMMENDED that the event data contains an optional field named `trigger` that has a string value.\"",
          "createdAt": "2024-10-21T14:21:55Z",
          "updatedAt": "2024-10-21T14:21:55Z"
        }
      ]
    },
    {
      "number": 431,
      "id": "I_kwDOCrLn6M6PBMtO",
      "title": "is parameters_restored missing fields defined in parameters_set?",
      "url": "https://github.com/quicwg/qlog/issues/431",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "e.g. max_datagram_frame_size and grease_quic_bit",
      "createdAt": "2024-07-10T00:17:36Z",
      "updatedAt": "2024-10-21T19:42:23Z",
      "closedAt": "2024-10-21T19:42:23Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, seems like I forgot to add those... opened #441, PTAL!",
          "createdAt": "2024-10-21T08:43:00Z",
          "updatedAt": "2024-10-21T08:43:00Z"
        }
      ]
    },
    {
      "number": 432,
      "id": "I_kwDOCrLn6M6PjsfV",
      "title": "Extensions to events can not be indicated by schema",
      "url": "https://github.com/quicwg/qlog/issues/432",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Here's a summary of what qlog already permits\r\n\r\n* Define new event schema\r\n  * Define new namespaces, if desired \r\n* Define new categories\r\n  * In existing namespaces, if desired \r\n* Define new event types in new categories\r\n  * Existing categories cannot be extended\r\n* Extend any event that allows it with new fields\r\n\r\nFor example, the QUIC packet_sent event is extensible. Cloudflare has a custom field called send_at_time that we use (see https://github.com/quicwg/qlog/issues/297 for background). If I want to formally define that extension point with a schema, the current event_schemas mechanism doesn't quite work well. While I could define a new namespace, category ID and event type - that's a lot of overhead for adding just a single field to an existing event. This also makes it hard to compose extensions together.\r\n\r\nProposal: define a new type of schema that is scoped to cover only extensions to existing event types, which is indicated by a value in the URI e.g., where we have `urn:ietf:params:qlog:events:gen#loglevel` a standardized extension `foo` could be identified by `urn:ietf:params:qlog:event_ext:extension_foo`, a private extension could be identified by `https://example.com/032024/event_ext/extension_foo.html`\r\n",
      "createdAt": "2024-07-15T11:27:42Z",
      "updatedAt": "2024-10-21T19:45:51Z",
      "closedAt": "2024-10-21T19:45:51Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mulling this over for a long time, I don't see an immediate better/alternative solution than indeed going with an additional type of URN for the `event_ext` here... (see alternatives I've tried on the bottom of this comment).\r\n\r\nHowever, this does have some annoyingness:\r\n\r\nFor the \"I just want to extend an existing event's Data field with new fields\" use case, this works just fine. You'd put the following in :\r\n\r\n```\r\nIn `urn:ietf:params:qlog:event_ext:more_packet_sent_fields`:\r\n$$packet-sent-extension //= (\r\n  ? additional_field_b: bool\r\n)\r\n\r\nWhere the original document `urn:ietf:params:qlog:events:quic#quic` would have:\r\nQUICPacketSent = {\r\n    field_a: uint8\r\n\r\n    * $$quic-packetsent-extension\r\n}\r\n```\r\n\r\nHOWEVER, in the case where you actually define new events/data types and then **add them to an existing enum/CDDL \"type socket\",** you get an annoying choice: \r\n\r\n1. either split up the definition of the new event into its own URN and the existing type socket extension in another `event_ext` URN\r\n2. just keep the type socket extension in the new event URN as well\r\n\r\n2 feels more logical, but is asymmetric with the above (i.e., extending event Data fields directly requires a new `events_ext` URN while adding new events/types to a type socket does NOT). 1 is more symmetric, but seems like annoying busy work. Examples below:\r\n\r\nOption 1:\r\n\r\n```\r\nIn urn:ietf:params:qlog:events:new_frame#rogerrabbit:\r\n\r\nRogerRabbitFrame = {\r\n     type: \"Roger\"\r\n     ? who: text\r\n}\r\n\r\nIn urn:ietf:params:qlog:events_ext:rogerrabbit:\r\n\r\n$H3Frame /= RogerRabbitFrames\r\n\r\n(where $H3Frame is defined in urn:ietf:params:qlog:events:h3#h3 of course)\r\n```\r\n\r\nOption 2 would just have both under the same URN\r\n\r\n```\r\nIn urn:ietf:params:qlog:events:new_frame#rogerrabbit:\r\n\r\nRogerRabbitFrame = {\r\n     type: \"Roger\"\r\n     ? who: text\r\n}\r\n\r\n$H3Frame /= RogerRabbitFrames\r\n```\r\n\r\nNote that in Option 1, both URNs can of course still be defined in the same document, it's just annoying to have to split them up separately (although, you could make the argument **it's a bit cleaner/more explicit** that way as well). \r\n\r\nAnother remark is that above, I've extended just `$H3Frame` which is NOT an event, but the proposed URNs for extensions is currently `event_ext`. So **I'd bikeshed that to just `extensions` instead**!\r\n\r\n---\r\n\r\nAppendix: alternatives considered\r\n\r\nA. decoupling event categories from the events URN. This would allow us to just do something like `urn:ietf:params:qlog:definitions:MyNamespace` and the namespace could contain anything! No need for new URN types or anything! However, since we need categories to be globally unique, having them in the URN somehow seems like a good way to automatically enforce that...\r\n\r\nB. Allowing extension of existing categories and URNs. For example, when extending QUICPacketSent above, you'd have something like `urn:ietf:params:qlog:events:quic#quic?packet-sent-ext-1`. However, this feels wrong for multiple reasons: you'd basically re-use a URN defined in document A as prefix in document B, C, D,.. which makes it hard to track, you'd only be able to do this to add EXTENSIONS to the existing events in a category but NOT add new events to that category (since we disallow that currently). It's all a bit of a mess...   \r\n\r\n",
          "createdAt": "2024-10-18T08:45:12Z",
          "updatedAt": "2024-10-18T08:45:12Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After my long comment above and thinking about it some more + a long discussion with Lucas, we decided it would make most sense to just remove categories from qlog altogether.\r\n\r\nI originally used categories because I thought events would be re-usable across protocols, but in practice, this was a pipe dream anyway. They just made extensibility and naming (and even implementations) more difficult while adding little to no value. \r\n\r\n#439 removes categories and consequently makes it possible to be more flexible in how we extend qlog, including with new documents that just extend existing events in existing namespaces, and it thus also closes this issue as solved. ",
          "createdAt": "2024-10-21T19:45:51Z",
          "updatedAt": "2024-10-21T19:45:51Z"
        }
      ]
    },
    {
      "number": 434,
      "id": "I_kwDOCrLn6M6RoHrG",
      "title": "JSON-SEQ is painful",
      "url": "https://github.com/quicwg/qlog/issues/434",
      "state": "OPEN",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When we switched to JSON-SEQ a while back (https://github.com/quicwg/qlog/issues/172), we assumed that using record separators instead of newline-delimited JSON wouldn't cause too much pain. I think it's time to reevaluate this assumption.\r\n\r\n## vim\r\n\r\nIt also turns out that existing software is not that great at handling record record separators. Here's a screenshot of `vim` messing up the line character count (note that last line, where it usually tells you the cursor position, and it now displays 12-13).\r\n![image](https://github.com/user-attachments/assets/1bfa7d6f-c354-43dc-950e-73df0aad951d)\r\n\r\n## jq\r\n\r\n`jq` is actually the tool that's the most compatible with JSONSEQ. However, one MUST use the `--seq` flag, using standard `jq` results in the following error, which is not very helpful for the user:\r\n```\r\njq: parse error: Invalid numeric literal at line 1, column 2\r\n```\r\nI had to use a search engine to figure out how to convince `jq` to use record separators. Definitely not the end of the world, but a subpar developer experience nonetheless.\r\n\r\n## grep\r\n\r\nAnother example is `grep`. Try to extract the `transport:connection_started` event from this qlog file using `grep`:\r\n\r\n```\r\n\u001e{\r\n    \"qlog_format\":\"JSON-SEQ\",\r\n    \"qlog_version\":\"draft-03\",\r\n    \"title\":\"quic-go qlog\",\r\n    \"configuration\":{\"code_version\":\"(devel)\"},\r\n    \"trace\":{\r\n        \"vantage_point\":{\"type\":\"client\"},\r\n        \"common_fields\":{\"ODCID\":\"65b480747721258697d6\",\"group_id\":\"65b480747721258697d6\",\"reference_time\":1722494434168.3032,\"time_format\":\"relative\"},\r\n    },\r\n}\r\n\u001e{\r\n    \"time\":0.038458,\r\n    \"name\":\"transport:connection_started\",\r\n    \"data\":{\"ip_version\":\"ipv6\",\"src_ip\":\"::\",\"src_port\":55464,\"dst_ip\":\"127.0.0.1\",\"dst_port\":6121,\"src_cid\":\"36ff0294\",\"dst_cid\":\"65b480747721258697d6\"},\r\n}\r\n```\r\n\r\nFirst of all, note how GitHub renders the record separator here: \ufffd (I love seeing this character on my screen!).\r\n\r\nBut back to `grep`: I haven't figured out a way to grep for the `transport:connection_started` event, and [apparently](https://superuser.com/questions/140965/grep-changing-the-delimiter) it's not easy to change the record separator.\r\n\r\n`grep`ing is **very important** when debugging, I often find myself filtering a qlog file for the event type(s) that I'm interested in.",
      "createdAt": "2024-08-01T19:11:44Z",
      "updatedAt": "2024-10-17T13:49:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "francoismichel",
          "authorAssociation": "NONE",
          "body": "I've been using and parsing QLOG quite extensively for my research and I can see how it can become painful especially for debugging purposes (sometimes you just have to browse through a file to find the exact problem that triggers some weird behaviour that appears during one run out of 1000). Not sure how my use-case is representative of real-world scenarios though, but I had to do that a lot. It is probably close to what implementers like @marten-seemann sometimes have to do.\r\n\r\nIf it actually really messes up with existing tools that worked fined with the previous format (I think it was close to, if not exactly [jsonlines](https://jsonlines.org/), which seems [quite popular](https://jsonlines.org/on_the_web) ?), I guess it makes sense to at least discuss that ?\r\n\r\nThat being said, developing a simple converter from json-seq to jsonlines for debugging use-cases that require grep, vim & co may be a good middleground solution, without necessarily having to change the spec.",
          "createdAt": "2024-08-01T20:03:21Z",
          "updatedAt": "2024-08-02T08:28:46Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Personally I've had no issues with the JSON-SEQ format. The [RFC 7464](https://datatracker.ietf.org/doc/html/rfc7464) is clear on various edge cases that might arise when parsing truncated logs. There is no equivalent IETF standard that exists for just a single line. The default serialization format for the QLogFile is JSON, which also allows \"pretty-printing\" styles to include newlines too, so I don't see the grep argument as too strong (although I do understand it). The majority of time I just print each event on a single line. But I do have use cases where qlogs are meant to be eyeballed by a human, and having pretty printing does actually help those. \r\n\r\nVS code deals with the record separator character just fine:\r\n\r\n![image](https://github.com/user-attachments/assets/8b4271ac-d5ce-43d0-9af9-69ed2d858de0)\r\n\r\n\r\nThere are users of quiche's standalone qlog crate, and users of quiche for client and server. I have heard them having no issue with JSON-SEQ over a single line. We also provide a very simple [reader class](https://github.com/cloudflare/quiche/blob/master/qlog/src/reader.rs) that seems to work ok, albeit it could probably be hardened by following more advice from RFC 7464.",
          "createdAt": "2024-08-01T20:08:17Z",
          "updatedAt": "2024-08-01T20:08:17Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "A middleground might be to subset JSON-SEQ and state something along the lines of \"In addition to the formatting rules defined in JSON-SEQ, it is RECOMMENDED that loggers do not embed new lines inside of serialized events, this makes it easier for general-purpose, line-oriented tools, to consume them.\"\r\n\r\n@marten-seemann might argue for a `MUST` level requirement here - but the failure scenario is trivally recoverable by some preprocessing, In the case where I find embedded newlines useful (and to be consumed by my own tooling), I'd ignore the MUST anyway. But it would mean other tools can't necessarily interop with me then, which is a little sad.",
          "createdAt": "2024-08-01T20:31:25Z",
          "updatedAt": "2024-08-01T20:31:25Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Maybe an interesting point is that xquic logs to slog/clog and then converts to json via python: https://github.com/alibaba/xquic/blob/main/scripts/qlog_parser.py\r\n\r\nAnd tangentially there's an issue on msquic for translation from their preferred format to qlog - https://github.com/microsoft/msquic/issues/1158",
          "createdAt": "2024-08-01T21:47:46Z",
          "updatedAt": "2024-08-01T21:47:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@LPardue makes a good point. What QLog defines is an interchange format between tools, not the format that your tools are supposed to log natively. People have the freedom to log in the format they like, then convert that to QLog. FWIW, quicly has taken the same approach.\r\n\r\nThat said, I think I agree with @marten-seemann and @francoismichel regarding if there is a reason to endorse a serialization format that has edges compared to JSONL.\r\n\r\nKnowing that JSONL is not standardized, one option we have is stop short of declaring how we concatenate the events. The idea is that while it is paramount to have the definition of how each event is being serialized, it is not that important to agree on one way of concatenating the events. IMO, it can either be JSONL, JSON-SEQ, or one JSON array.\r\n\r\nIf most people prefer JSONL, we will end up consolidating on JSONL.\r\n\r\nDoes that sound like a better strategy compared to naming JSON-SEQ in a normative manner?",
          "createdAt": "2024-08-01T23:40:11Z",
          "updatedAt": "2024-08-01T23:40:11Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Speaking personally with no hats, I don't think we should spend QUIC WG time relitigating all of the finer details of JSON encoding and parsing, for some newline delineated format. Leaving it wooly defined, doesn't seem acceptable to me. The spec is targetted towards tool makers too, selling them short risks interop failures of the *structured* logging nature of qlog. That doesn't seem like a fair tradeoff when tools working on unstructured lines data can work fine if each event is contained on a line.",
          "createdAt": "2024-08-02T00:32:06Z",
          "updatedAt": "2024-08-02T00:32:06Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "As a very boring example - what media type would a handrolled ndjson use? Right now we have proposed to piggy back off of the existing `json-seq` suffix to use `qlog+json-seq`. Defining a new suffix would be a lot of work and maybe not event viable.",
          "createdAt": "2024-08-02T00:53:22Z",
          "updatedAt": "2024-08-02T00:53:22Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I might be blissfully ignorant regarding the edge cases of JSON serialization, but in my mind, NLJSON is trivially simple to define: \r\n```\r\nEvery line in and of itself is a valid JSON object.\r\n```\r\nThat's it.\r\n\r\n> As a very boring example - what media type would a handrolled ndjson use? \r\n\r\nI'm not convinced that adding a MIME type to the file itself was the right thing to do, see #435. If we remove this field, we might not need to specify anything. \r\n\r\n--- \r\n\r\nAs a general point, what we should optimize for is (new) developers / researchers handling qlogs. It should be dead simple to take a bunch of qlogs from different implementations, and use them to debug a QUIC transfer. \r\n\r\nOf course the file format doesn't matter if you're only using tools that understand the intricacies of qlog, like qvis. But analysis often involves using standard unix tools. Simple example: count how many times a particular event happened: `grep <event name> <file.qlog> | wc`. We're just creating unnecessary frustration if simple stuff like this doesn't work.\r\n\r\nI do realize that this might make it harder to push the spec through the IETF process. This is unfortunate, and certainly annoying for us as editors, and the QUIC WG chairs. But in the end, we're not writing a spec so that it fits neatly into the set of existing RFCs. We're writing a spec, so we have a neat serialization format that's maximally useful for devs and researchers.",
          "createdAt": "2024-08-02T04:28:01Z",
          "updatedAt": "2024-08-02T04:28:01Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "[client-1928a4431b958983545fe79a00fcf7a670f39d8e.zip](https://github.com/user-attachments/files/16465771/client-1928a4431b958983545fe79a00fcf7a670f39d8e.zip) unzips to client-1928a4431b958983545fe79a00fcf7a670f39d8e.sqlog, which is a JSON-SEQ file that includes some pretty printing e.g.\r\n\r\n```\r\n\u001e{\"qlog_version\":\"0.3\",\"qlog_format\":\"JSON-SEQ\",\"title\":\"quiche-client qlog\",\"description\":\"quiche-client qlog id=1928a4431b958983545fe79a00fcf7a670f39d8e\",\"trace\":{\"vantage_point\":{\"type\":\"client\"},\"title\":\"quiche-client qlog\",\"description\":\"quiche-client qlog id=1928a4431b958983545fe79a00fcf7a670f39d8e\",\"configuration\":{\"time_offset\":0.0}}}\r\n\u001e{\r\n  \"time\": 0.0,\r\n  \"name\": \"transport:parameters_set\",\r\n  \"data\": {\r\n    \"owner\": \"local\",\r\n    \"tls_cipher\": \"None\",\r\n    \"disable_active_migration\": true,\r\n    \"max_idle_timeout\": 30000,\r\n    \"max_udp_payload_size\": 1350,\r\n    \"ack_delay_exponent\": 3,\r\n    \"max_ack_delay\": 25,\r\n    \"active_connection_id_limit\": 2,\r\n    \"initial_max_data\": 10000000,\r\n    \"initial_max_stream_data_bidi_local\": 1000000,\r\n    \"initial_max_stream_data_bidi_remote\": 1000000,\r\n    \"initial_max_stream_data_uni\": 1000000,\r\n    \"initial_max_streams_bidi\": 100,\r\n    \"initial_max_streams_uni\": 100\r\n  }\r\n}\r\n```\r\n\r\n\r\n> Simple example: count how many times a particular event happened: grep <event name> <file.qlog> | wc. We're just creating unnecessary frustration if simple stuff like this doesn't work.\r\n\r\nIt works:\r\n\r\n```\r\n$ grep \"transport:packet_sent\" client-1928a4431b958983545fe79a00fcf7a670f39d8e.sq\r\nlog | wc -l\r\n     17\r\n```\r\n\r\nor \r\n\r\n```\r\n$ jq -c --seq 'select(.name==\"transport:packet_sent\")' client-1928a4431b958983545fe79a00fcf7a670f39d8e.sqlog | wc -l\r\n     17\r\n```\r\n\r\nor even\r\n\r\n```\r\n$ jq -c --seq  . client-1928a4431b958983545fe79a00fcf7a670f39d8e.sqlog | grep \"transport:packet_sent\" qlogs/client-1928a4431b958983545fe79a00fcf7a670f39d8e.sqlog | wc -l\r\n     17\r\n```\r\n\r\nthat last one is even has a fragment you can use to seemlessly convert to line-delimited for you own needs, e.g. here's the output of \r\n\r\n```\r\n$ jq -c --seq  . client-1928a4431b958983545fe79a00fcf7a670f39d8e.sqlog | head\r\n{\"qlog_version\":\"0.3\",\"qlog_format\":\"JSON-SEQ\",\"title\":\"quiche-client qlog\",\"description\":\"quiche-client qlog id=1928a4431b958983545fe79a00fcf7a670f39d8e\",\"trace\":{\"vantage_point\":{\"type\":\"client\"},\"title\":\"quiche-client qlog\",\"description\":\"quiche-client qlog id=1928a4431b958983545fe79a00fcf7a670f39d8e\",\"configuration\":{\"time_offset\":0}}}\r\n{\"time\":0,\"name\":\"transport:parameters_set\",\"data\":{\"owner\":\"local\",\"tls_cipher\":\"None\",\"disable_active_migration\":true,\"max_idle_timeout\":30000,\"max_udp_payload_size\":1350,\"ack_delay_exponent\":3,\"max_ack_delay\":25,\"active_connection_id_limit\":2,\"initial_max_data\":10000000,\"initial_max_stream_data_bidi_local\":1000000,\"initial_max_stream_data_bidi_remote\":1000000,\"initial_max_stream_data_uni\":1000000,\"initial_max_streams_bidi\":100,\"initial_max_streams_uni\":100}}\r\n{\"time\":0.078191,\"name\":\"transport:packet_sent\",\"data\":{\"header\":{\"packet_type\":\"initial\",\"packet_number\":0,\"version\":\"babababa\",\"scil\":20,\"dcil\":16,\"scid\":\"1928a4431b958983545fe79a00fcf7a670f39d8e\",\"dcid\":\"6c5443b5ef7ebae8d7830638c8f9dbf5\"},\"raw\":{\"length\":338,\"payload_length\":275},\"send_at_time\":0.078191,\"frames\":[{\"frame_type\":\"crypto\",\"offset\":0,\"length\":271}]}}\r\n{\"time\":0.078191,\"name\":\"recovery:metrics_updated\",\"data\":{\"smoothed_rtt\":333,\"rtt_variance\":166.5,\"congestion_window\":13500,\"bytes_in_flight\":338,\"ssthresh\":18446744073709552000}}\r\n{\"time\":10.191873,\"name\":\"transport:packet_sent\",\"data\":{\"header\":{\"packet_type\":\"initial\",\"packet_number\":1,\"version\":\"1\",\"scil\":20,\"dcil\":16,\"scid\":\"1928a4431b958983545fe79a00fcf7a670f39d8e\",\"dcid\":\"6c5443b5ef7ebae8d7830638c8f9dbf5\"},\"raw\":{\"length\":338,\"payload_length\":275},\"send_at_time\":10.191873,\"frames\":[{\"frame_type\":\"crypto\",\"offset\":0,\"length\":271}]}}\r\n{\"time\":28.821796,\"name\":\"transport:packet_received\",\"data\":{\"header\":{\"packet_type\":\"initial\",\"packet_number\":0,\"version\":\"1\",\"scil\":20,\"dcil\":20,\"scid\":\"01f9ec51e1be075788faf55113ec16fe80aeda58\",\"dcid\":\"1928a4431b958983545fe79a00fcf7a670f39d8e\"},\"raw\":{\"length\":1200,\"payload_length\":117},\"frames\":[{\"frame_type\":\"ack\",\"ack_delay\":0.109,\"acked_ranges\":[[1,1]]},{\"frame_type\":\"crypto\",\"offset\":0,\"length\":90}]}}\r\n{\"time\":28.821796,\"name\":\"recovery:metrics_updated\",\"data\":{\"min_rtt\":18.629923,\"smoothed_rtt\":18.629923,\"latest_rtt\":18.629923,\"rtt_variance\":9.3149605,\"bytes_in_flight\":0}}\r\n{\"time\":29.419956,\"name\":\"transport:packet_received\",\"data\":{\"header\":{\"packet_type\":\"handshake\",\"packet_number\":0,\"version\":\"1\",\"scil\":20,\"dcil\":20,\"scid\":\"01f9ec51e1be075788faf55113ec16fe80aeda58\",\"dcid\":\"1928a4431b958983545fe79a00fcf7a670f39d8e\"},\"raw\":{\"length\":1033,\"payload_length\":984},\"frames\":[{\"frame_type\":\"crypto\",\"offset\":0,\"length\":963}]}}\r\n{\"time\":29.551624,\"name\":\"transport:packet_received\",\"data\":{\"header\":{\"packet_type\":\"handshake\",\"packet_number\":1,\"version\":\"1\",\"scil\":20,\"dcil\":20,\"scid\":\"01f9ec51e1be075788faf55113ec16fe80aeda58\",\"dcid\":\"1928a4431b958983545fe79a00fcf7a670f39d8e\"},\"raw\":{\"length\":689,\"payload_length\":640},\"frames\":[{\"frame_type\":\"crypto\",\"offset\":963,\"length\":618}]}}\r\n{\"time\":29.551624,\"name\":\"transport:parameters_set\",\"data\":{\"owner\":\"remote\",\"tls_cipher\":\"Some(AES128_GCM)\",\"original_destination_connection_id\":\"6c5443b5ef7ebae8d7830638c8f9dbf5\",\"disable_active_migration\":false,\"max_idle_timeout\":0,\"max_udp_payload_size\":65527,\"ack_delay_exponent\":3,\"max_ack_delay\":25,\"active_connection_id_limit\":2,\"initial_max_data\":10000000,\"initial_max_stream_data_bidi_local\":10000000,\"initial_max_stream_data_bidi_remote\":10000000,\"initial_max_stream_data_uni\":10000000,\"initial_max_streams_bidi\":100,\"initial_max_streams_uni\":100}}\r\n```\r\n\r\nHonestly, for anyone wrangling JSON, `jq` is ubiquitous and provides a out-of-box capability to filter and convert a standardized canonical format into a multitude of formats, or pipes to other tools.\r\n\r\n",
          "createdAt": "2024-08-02T05:35:02Z",
          "updatedAt": "2024-08-02T05:35:02Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Media types were defined in response to https://github.com/quicwg/qlog/issues/158, where @kazuho said\r\n\r\n> At the moment, we use a custom ndjson format, but if we are to use qlog, there has to be a media-type.",
          "createdAt": "2024-08-02T05:38:09Z",
          "updatedAt": "2024-08-02T05:38:09Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Simple example: count how many times a particular event happened: grep  <file.qlog> | wc. We're just creating unnecessary frustration if simple stuff like this doesn't work.\r\n> \r\n> It works:\r\n\r\nIt works because you picked an example that's so simple that JSON-SEQ doesn't break it. Unfortunately, that doesn't apply to the vast majority of things you might want to do. For example, try counting the number of packets sent that counted a MAX_STREAM_DATA frame. You'd need something like `grep packet_sent <file.qlog> | grep max_stream_data | wc`. This breaks as soon as the event is not in one line.\r\n\r\nSure, you can use `jq` for that (once you've figured out that you need to use `--seq`, yet another annoyance for new developers). It's definitely more powerful than standard bash tools, but then I also have to ask ChatGPT to figure out selectors and filters every time...\r\n",
          "createdAt": "2024-08-02T05:46:47Z",
          "updatedAt": "2024-08-02T05:46:47Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "wrt to vim, this is expected behaviour as described in https://vimdoc.sourceforge.net/htmldoc/options.html#%27ruler%27\r\nbecause it chooses to render record separator as `^^`\r\n\r\n> If the number of characters displayed is different from the number of bytes in the text (e.g., for a TAB or a [multi-byte](https://vimdoc.sourceforge.net/htmldoc/mbyte.html#multi-byte) character), both the text column (byte number) and the screen column are shown, separated with a dash. For an empty line \"0-1\" is shown. For an empty buffer the line number will also be zero: \"0,0-1\".\r\n\r\nAnyone that likes to program with TAB would already be used to this\r\n\r\n![image](https://github.com/user-attachments/assets/3808f053-6c2f-47da-bba9-a2faaedff552)\r\n",
          "createdAt": "2024-08-02T05:48:53Z",
          "updatedAt": "2024-08-02T05:48:53Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "> You'd need something like grep packet_sent <file.qlog> | grep max_stream_data | wc. This breaks as soon as the event is not in one line.\r\n\r\nAdding `jq -c --seq  . |` prefix is not hard to do and satisfies this requirement if people don't want to learn jq syntax.",
          "createdAt": "2024-08-02T05:52:16Z",
          "updatedAt": "2024-08-02T05:52:16Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "### As an individual without hats:\r\n\r\nI fully agree with @marten-seemann here... I think standards should reflect how people actually use stuff and the JSON-SEQ thing is plain annoying, even if things like jq have support for it (and we can \"work around\" it by having transformers and whatnot. My time at a larger company has taught me the absolute value of \"sensible defaults\" and \"predictability through familiarity\").\r\n\r\nIt really annoyed me having to switch from NDJSON to JSON-SEQ when we did just because NDJSON doesn't have an (IETF) RFC (even if I understand the arguments).\r\n\r\n---\r\n\r\n### As an editor with too many years on this already:\r\n\r\nI have **zero (0)** appetite to try and switch this again at this stage and especially trying to push it through the (eventual) IESG/whatever process needed to finally get these out the door. \r\n\r\nWith the recent extensibility changes, we can easily write an extension draft that defines how to still use NDJSON, it just won't be part of the default/first set of documents (Oh RFC 9218, have we learned nothing). \r\n\r\nI'm also perfectly fine with keeping support for NDJSON in qvis for example. \r\n\r\n",
          "createdAt": "2024-08-02T13:17:31Z",
          "updatedAt": "2024-08-02T13:17:31Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during editors meeting. Will need face 2 face discussion with @marten-seemann during upcoming meeting to resolve this. ",
          "createdAt": "2024-09-30T09:50:58Z",
          "updatedAt": "2024-09-30T09:50:58Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during editors meeting with me, Marten and Lucas.\r\n\r\nWe can't agree among ourselves whether to switch to NDJSON, add NDJSON or just stick with JSON-SEQ. However, we also feel this is not the most important issue to solve right now, so we will mention it during the upcoming IETF meeting in Dublin to see if people want to come to this issue to advocate for one option or another, but we won't call for a vote/hum on this from the WG at this point. ",
          "createdAt": "2024-10-17T13:23:28Z",
          "updatedAt": "2024-10-17T13:23:28Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This needs to be raised on the QUIC mailing list before then, to reach that the broadest set of people",
          "createdAt": "2024-10-17T13:49:55Z",
          "updatedAt": "2024-10-17T13:49:55Z"
        }
      ]
    },
    {
      "number": 435,
      "id": "I_kwDOCrLn6M6RqQVc",
      "title": "parsing the `serialization_format` field requires prior knowledge of the serialization format",
      "url": "https://github.com/quicwg/qlog/issues/435",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From section 5:\r\n```json\r\n<RS>{\r\n     \"file_schema\": \"urn:ietf:params:qlog:file:sequential\",\r\n     \"serialization_format\": \"application/qlog+json-seq\",\r\n     \"title\": \"Name of JSON Text Sequence qlog file (short)\",\r\n     \"description\": \"Description for this trace file (long)\",\r\n     \"trace\": {\r\n       \"common_fields\": {\r\n         \"protocol_type\": [\"QUIC\",\"HTTP3\"],\r\n         \"group_id\":\"127ecc830d98f9d54a42c4f0842aa87e181a\",\r\n         \"time_format\":\"relative\",\r\n         \"reference_time\": 1553986553572\r\n       },\r\n       \"vantage_point\": {\r\n         \"name\":\"backend-67\",\r\n         \"type\":\"server\"\r\n       }\r\n    }\r\n}\r\n```\r\n\r\nIf I don't know that the file is serialized as JSON-SEQ, I won't be able to parse the header that tells me that it's serialized as JSON-SEQ.\r\n\r\nWhat would we lose by not including the `serialization_format`?",
      "createdAt": "2024-08-02T01:12:50Z",
      "updatedAt": "2024-10-16T08:26:15Z",
      "closedAt": "2024-10-16T08:26:15Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The text states \r\n\r\n> In order to make it easier to parse and identify qlog files and their serialization format, the \"file_schema\" and \"serialization_format\" fields and their values SHOULD be in the first 256 characters/bytes of the resulting log file.\r\n\r\nSo in theory, a tool could try to regex match or magic number match for a binary format, based on these things.\r\n\r\nIt is a bit of a chicken and egg thing though. Currently, my parser just looks at the file extension and then does some trial decode and a fallback.",
          "createdAt": "2024-08-02T01:29:45Z",
          "updatedAt": "2024-08-02T01:29:45Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, to an extent you're right @marten-seemann, you need some idea of what you're dealing with (i.e., binary vs plaintext vs something like JSON). However, only basing this on for example file extension is too naive (especially since people use .json EVERYWHERE).\r\n\r\nThe [current code in qvis](https://github.com/quiclog/qvis/blob/master/visualizations/src/components/filemanager/data/FileLoader.ts#L211) imo shows this well, since I want to support both netlog files (also annoyingly .json) and various JSON-based qlog variants (normal JSON, JSON-SEQ, NDJSON). \r\n\r\nI don't want to have to \"trial parse\" each of those options, since the parsers might be somewhat expensive to initialize / don't necessarily work in a streaming fashion/might even have to be offloaded to the backend. Having the `serialization_format` in the first x chars helps me make a very educated decision using a simple string lookup on how to handle the file without having to involve a complete parser yet. \r\n\r\nWhile I agree it's not ideal, it's a good practical solution that I'd like to keep. The recent switch to making it equivalent with the media types I feel is elegant and clear and consistent in ways that the previous `qlog_format` wasn't. \r\n\r\n",
          "createdAt": "2024-08-02T13:25:22Z",
          "updatedAt": "2024-08-02T13:25:22Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> The [current code in qvis](https://github.com/quiclog/qvis/blob/master/visualizations/src/components/filemanager/data/FileLoader.ts#L211) imo shows this well, since I want to support both netlog files (also annoyingly .json) and various JSON-based qlog variants (normal JSON, JSON-SEQ, NDJSON).\r\n> \r\n> I don't want to have to \"trial parse\" each of those options, since the parsers might be somewhat expensive to initialize / don't necessarily work in a streaming fashion/might even have to be offloaded to the backend. Having the `serialization_format` in the first x chars helps me make a very educated decision using a simple string lookup on how to handle the file without having to involve a complete parser yet.\r\n\r\nI totally get that, though I'd argue that this is not the situation we should optimize for:\r\n* supporting netlog in addition to qlog seems pretty qvis-specific\r\n* telling different draft versions apart won't be necessary once we ship an RFC\r\n",
          "createdAt": "2024-08-02T16:48:46Z",
          "updatedAt": "2024-08-02T16:48:46Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "My tool also supports netlog json.\r\n\r\nNew documents could define new log formats or serialization formats. \r\n\r\nThe peeking code that Robin suggests is a simple way to accomodate for a range of future possibilities.",
          "createdAt": "2024-08-02T19:42:21Z",
          "updatedAt": "2024-08-02T19:42:21Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there precedent for this kind of peeking logic in other IETF serialization formats, or other data formats outside of the IETF? This seems extremely hacky to me. ",
          "createdAt": "2024-08-02T21:16:09Z",
          "updatedAt": "2024-08-02T21:16:09Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Yes, this is typically referred to as \"content sniffing\" or \"MIME sniffing\" - it has drawbacks (that we should document further if we are keeping the text) but to my knowledge is commonly used to work around imperfect or incorrect metadata. \r\n\r\nWikipedia highlights that the unix `file` command is such a sniffer. See https://www.darwinsys.com/file/ and https://github.com/file/file. This relies on libmagic, which is commonly distrubted with a database of entries (e.g. at /usr/share/misc/magic.mgc). For example I can do this:\r\n\r\n```\r\n$ file pcap.pcap\r\npcap.pcap: pcap capture file, microsecond ts (little-endian) - version 2.4 (Ethernet, capture length 1500)\r\n```\r\n\r\nand \r\n\r\n```\r\n$ file pcap_no_extension \r\npcap_no_extension: pcap capture file, microsecond ts (little-endian) - version 2.4 (Ethernet, capture length 1500)\r\n```\r\n\r\nAs far as I understand, they accept new contributions, so it's entirely feasible we could add this for qlog serialization formats. In future, a binary encoding format could define some additional [magic numbers](https://en.wikipedia.org/wiki/List_of_file_signatures) to aid such sniffing. Registration requests for media types, [use this template](https://www.rfc-editor.org/rfc/rfc6838.html#section-4.12), which includes an optional Magic Numbers part.\r\n\r\nBeyond `file`, other mentions of sniffing include example https://www.rfc-editor.org/rfc/rfc9110.html#section-8.3, which has some text about how to deal with content and `Content-Type` headers,  stating:\r\n\r\n> In practice, resource owners do not always properly configure their origin server to provide the correct Content-Type for a given representation. Some user agents examine the content and, in certain cases, override the received type (for example, see [[Sniffing](https://www.rfc-editor.org/rfc/rfc9110.html#Sniffing)]). This \"MIME sniffing\" risks drawing incorrect conclusions about the data, which might expose the user to additional security risks (e.g., \"privilege escalation\"). Furthermore, distinct media types often share a common data format, differing only in how the data is intended to be processed, which is impossible to distinguish by inspecting the data alone. When sniffing is implemented, implementers are encouraged to provide a means for the user to disable it.\r\n\r\nThe [MIME sniffing doc ](https://mimesniff.spec.whatwg.org/) itself is very detailed. To pick some relevant parts, there's\r\nhttps://mimesniff.spec.whatwg.org/#identifying-a-resource-with-an-unknown-mime-type that describes a matching algorithm, which is run over the resource header, defined in https://mimesniff.spec.whatwg.org/#reading-the-resource-header. As a snippet:\r\n\r\n> To read the resource header, perform the following steps:\r\n> \r\n> Let buffer be a [byte sequence](https://infra.spec.whatwg.org/#byte-sequence).\r\n> Read [bytes](https://infra.spec.whatwg.org/#byte) of the [resource](https://mimesniff.spec.whatwg.org/#resource) into buffer until one of the following conditions is met:\r\n> the end of the [resource](https://mimesniff.spec.whatwg.org/#resource) is reached.\r\n> the number of [bytes](https://infra.spec.whatwg.org/#byte) in buffer is greater than or equal to 1445.\r\n> a reasonable amount of time has elapsed, as determined by the user agent.\r\n\r\nThere looks to have been an attempt to write something up in an I-D but it seems it wasn't adopted https://datatracker.ietf.org/doc/html/draft-abarth-mime-sniff-06. Not sure why, maybe someone more familiar with the history knows. But AFAIK web content sniffing is commonplace.",
          "createdAt": "2024-08-02T22:24:45Z",
          "updatedAt": "2024-08-02T22:24:45Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Very interesting, thank you for researching this @LPardue! It's kind of sad that we don't have a better of way of determining the file type, but it seems like we're not doing something that's outrageously out of line here.",
          "createdAt": "2024-08-04T23:16:57Z",
          "updatedAt": "2024-08-04T23:16:57Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during editors meeting. Seems like @marten-seemann agrees this is acceptable? If so: please close the issue :) ",
          "createdAt": "2024-09-30T09:51:51Z",
          "updatedAt": "2024-09-30T09:51:51Z"
        }
      ]
    },
    {
      "number": 436,
      "id": "I_kwDOCrLn6M6aO4zn",
      "title": "Logging unknown TransportParameters",
      "url": "https://github.com/quicwg/qlog/issues/436",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Back in https://github.com/quicwg/qlog/issues/176 I said \r\n\r\n> The spec would be improved by having a well-defined \"extension bucket\" field that TPs can go in, an array of integers tuples would be fine, for example.\r\n\r\nand we addressed that with a structured solution using group sockets in https://github.com/quicwg/qlog/pull/417.\r\n\r\nHowever, I think one original problem still stands. As a receiver, if I receive an unknown TP, there's not a standard way to log the codepoint and value. H3 already has a solution to this via the SETTINGS frame but QUIC TPs are different and it isn't so straightforward. \r\n\r\n@hawkinsw has this problem right now. He is doing research on the Accurate ECN extension and very kindly proposed some [en/decode to quiche](https://github.com/cloudflare/quiche/pull/1860). And while a small patch, adding code for an I-D we don't implement (and might want to track all I-D revisions that change the code point) adds overhead. So it got me wondering could we use qlog instead and require zero changes, leading back here.\r\n\r\nFor example, by extending parameters_set as below, we could easily externalise the code that checks supported TPs to log tooling\r\n\r\n```\r\nQUICParametersSet = {\r\n  // all the existing stuff\r\n  \r\n  unknown_parameters: [* UnknownTransportParameter]\r\n  \r\n}\r\n\r\nUnknownTransportParameter= {\r\n    id: uint64,\r\n    value: uint64\r\n}\r\n```",
      "createdAt": "2024-10-15T04:24:38Z",
      "updatedAt": "2024-10-21T07:50:15Z",
      "closedAt": "2024-10-21T07:50:15Z",
      "comments": [
        {
          "author": "hawkinsw",
          "authorAssociation": "NONE",
          "body": "@LPardue This sounds like an excellent idea! In fact, it sounds like something that I would have fun implementing! Would you allow me a crack at it?",
          "createdAt": "2024-10-15T05:31:26Z",
          "updatedAt": "2024-10-15T05:31:26Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue Looking it over, it's a bit of a mess :) \r\n\r\nFor H3 we indeed have the option to log as `unknown` in the H3SettingsFrame, but not in the `h3:parameters_set` event.\r\nIn QUIC, we don't have the equivalent to H3SettingsFrame _(not seriously considering adding TLS events though ;))_ and so indeed this kind of falls through the cracks a bit. \r\n\r\nSo in general the proposed solution of adding `unknown_parameters` to `quic:parameters_set` looks good to me, and let's do that, but I'm wondering if the `h3:parameters_set` discrepancy is a problem in practice or not (probably not, but still... it's an annoying asymmetry). \r\n\r\nAlso: hey @hawkinsw, great to see you're still doing QUIC stuff and wandering over into qlog country :) ",
          "createdAt": "2024-10-15T10:05:37Z",
          "updatedAt": "2024-10-15T10:05:37Z"
        },
        {
          "author": "hawkinsw",
          "authorAssociation": "NONE",
          "body": "@rmarx I am just trying to keep up with you and @LPardue !! I will take a crack at doing some \"good\" here and let you know how I progress. I won't get a chance to start on it until tomorrow AM. Thank you for both being so welcoming!\r\n",
          "createdAt": "2024-10-15T22:31:05Z",
          "updatedAt": "2024-10-15T22:31:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "@rmarx yeah I don't like the asymmetry much either. Although I think some of that can be put down to H3 extensions being a little more loosy goosy than QUIC. Adding a bucket to h3 params set sound fine to me.\r\n\r\n@hawkinsw I'm not sure if your volunteering to update the qlog spec, or to experiment with quiche, or both. But whatever you'd like to volunteer is appreciated!",
          "createdAt": "2024-10-15T22:41:24Z",
          "updatedAt": "2024-10-15T22:41:24Z"
        },
        {
          "author": "hawkinsw",
          "authorAssociation": "NONE",
          "body": "@LPardue and @rmarx Thank you _both_ for your support. If the PR (referenced above) looks like it is on the right track, I will take a whack and opening something for the qlog spec! \r\n\r\nThanks again!\r\n",
          "createdAt": "2024-10-16T14:15:16Z",
          "updatedAt": "2024-10-16T14:15:16Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in editors meeting. No clear preference to add symmetric option for this in `h3:parameters-set` event as well, so the one who creates the PR gets to choose what it'll be :) ",
          "createdAt": "2024-10-17T13:55:03Z",
          "updatedAt": "2024-10-17T13:55:03Z"
        },
        {
          "author": "hawkinsw",
          "authorAssociation": "NONE",
          "body": "@rmarx It looks like you might have beaten me to the punch. I'm sorry I was slow. I tried my best.",
          "createdAt": "2024-10-18T18:55:21Z",
          "updatedAt": "2024-10-18T18:55:21Z"
        }
      ]
    },
    {
      "number": 442,
      "id": "I_kwDOCrLn6M6bI62J",
      "title": "Time units ",
      "url": "https://github.com/quicwg/qlog/issues/442",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "Its still ambiguous what units the logged time field uses. Issue spun off from the other clock updates in the PR below\r\n\r\n              I don't understand this bit. If I have a float64 field, and I decide to use it to log \"1.5\" to mean one and a half seconds, but the logger tool thinks I meant one and a half milliseconds, then there's an interop issue. So I think we need to pick one form of \"units of x with fractional Y\", or add a field to articulate the concrete units and precision.\r\n\r\n_Originally posted by @LPardue in https://github.com/quicwg/qlog/pull/433#discussion_r1808864215_\r\n            ",
      "createdAt": "2024-10-21T14:52:08Z",
      "updatedAt": "2025-07-07T12:24:54Z",
      "closedAt": "2025-07-07T12:24:54Z",
      "comments": []
    },
    {
      "number": 443,
      "id": "I_kwDOCrLn6M6c5Jq_",
      "title": "Indicate where IANA registries are defined",
      "url": "https://github.com/quicwg/qlog/issues/443",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "editorial"
      ],
      "body": "As per an early IANA review before IETF 121, the quic and h3 docs need to explicitly indicate where the new registry is defined (the main schema doc):\r\n\r\n> The \"qlog event schema URIs\" registry hasn\u2019t been created yet. Please cite the document that\u2019s going to create it.",
      "createdAt": "2024-11-04T09:01:13Z",
      "updatedAt": "2025-07-07T12:19:58Z",
      "closedAt": "2025-07-07T12:19:58Z",
      "comments": []
    },
    {
      "number": 447,
      "id": "I_kwDOCrLn6M6sa19w",
      "title": "PING frame doesn't have a payload",
      "url": "https://github.com/quicwg/qlog/issues/447",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design"
      ],
      "body": "In https://quicwg.org/qlog/draft-ietf-quic-qlog-quic-events.html#section-8.13.2\n\n```\n PingFrame = {\n    frame_type: \"ping\"\n\n    ; total frame length, including frame header\n    ? length: uint32\n    ? payload_length: uint32\n}\n```\n\nIn QUIC, the [PING frame](https://datatracker.ietf.org/doc/html/rfc9000#section-19.2) doesn't have a payload so the payload length can never be populated. In my implementation, I've always set this to `None` and the fields are always omitted.\n\nProposal: drop both the `length` and `payload_length` fields",
      "createdAt": "2025-03-04T02:00:14Z",
      "updatedAt": "2025-03-13T14:01:43Z",
      "closedAt": "2025-03-13T14:01:43Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So this is a bit of a weird one... I would agree with `payload_length` but not necessarily with `length`, since that includes the frame header, which can be VLIE. Since we don't guarantee VLIE to always take up the least amount of bytes, this can be 1,2,4,8 bytes. This is primarily needed to do things like the qvis packetization diagram, where you want to know exactly how many bytes are used.\n\nThat said, arguably this should all be changed to just having `? raw: RawInfo` for all these frames (like we already have for the StreamFrame). I am tracking that general update work in https://github.com/quicwg/qlog/issues/421 (note for Robin: CryptoFrame confusingly has both options at the same time?!?)\n\nSo, TL;DR: proposal is to replace both fields with `? raw: RawInfo`\n\n",
          "createdAt": "2025-03-06T09:32:26Z",
          "updatedAt": "2025-03-06T09:32:26Z"
        }
      ]
    },
    {
      "number": 448,
      "id": "I_kwDOCrLn6M6s2Nox",
      "title": "Do we need `protocol_types` now that we have `event_schemas`",
      "url": "https://github.com/quicwg/qlog/issues/448",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design"
      ],
      "body": "https://github.com/quicwg/qlog/pull/446 made me think about why we still need `protocol_types` now that we have `event_schemas` and we've decided that those schemas are (most likely) somewhat tightly tied to specific protocols (i.e., we no longer have the generic `connectivity:` events; those are all just `quic:` events now, since TCP-related events would likely be different enough anyway).\n\nIf you know the `event_schemas`, you know which protocol types are expected in a log as well by implicit inference, so we could do away with `protocol_types` easily enough.\n\nHOWEVER, the main problem with that, is that currently `event_schemas` are part of the top-level `QlogFile`, and so defined at a complete file level, while `protocol_types` are at individual `trace` level. For single files that combine logs from multiple different protocols, this would make it annoying to figure out which traces contained which protocols specifically, since `event_schemas` would aggregate everything at the top-level. \n\n\nConceptually, I feel it just makes more sense to have `event_schemas` as a per-trace thing as well, since you might indeed have cases where not every trace uses the same schemas (before looking into this, I already thought this was the case today...). This would be a small conceptual change imo.\n\nProposal:\n- Move `event_schemas` from `QlogFile` to `Trace` and `TraceSeq` (don't think it needs to be in `common_fields`)\n- Remove `protocol_types`",
      "createdAt": "2025-03-06T09:44:33Z",
      "updatedAt": "2025-03-13T14:10:30Z",
      "closedAt": "2025-03-13T14:10:30Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I definitely support removing protocol_types, it seems redundant and makes it annoying to have to define a separate identifier for the same thing.\n\nI think per trace event_schemas is the only logical option for the model where a log file contains multiple traces that could belong to different implementations.",
          "createdAt": "2025-03-06T09:55:39Z",
          "updatedAt": "2025-03-06T09:55:39Z"
        }
      ]
    },
    {
      "number": 456,
      "id": "I_kwDOCrLn6M6tmvg1",
      "title": "How to log sending of path probe packets?",
      "url": "https://github.com/quicwg/qlog/issues/456",
      "state": "OPEN",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There doesn't seem to be a good way to log the remote address that a path probe packet is being sent to / received from. This would be very helpful for debugging connection migration.",
      "createdAt": "2025-03-12T04:31:15Z",
      "updatedAt": "2025-07-07T01:50:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not entirely sure, but isn't this covered by using [the `path_assigned` event](https://datatracker.ietf.org/doc/html/draft-ietf-quic-qlog-quic-events-09#section-4.7) and logging the remote address in there? \n\nI know that's somewhat more tedious probably than logging it directly together with the probe, but that's the general approach we've taken to path stuff after tons of discussion in the past. If the migration succeeds, you'd be using that PathID anyway.\n\nProposal: use existing `path_assigned` for this use case and close this issue without action. ",
          "createdAt": "2025-03-12T10:45:03Z",
          "updatedAt": "2025-03-12T10:45:32Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This proposal seems reasonable to me. @marten-seemann any objections?",
          "createdAt": "2025-07-07T01:50:02Z",
          "updatedAt": "2025-07-07T01:50:02Z"
        }
      ]
    },
    {
      "number": 461,
      "id": "I_kwDOCrLn6M6urVb6",
      "title": "Capture guidance on extension schemas venues in the IETF",
      "url": "https://github.com/quicwg/qlog/issues/461",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It was commented during IETF 122 that it would be helpful for the QLOG document itself to have a short statement about what venue(s) is(are) suitable to standardize qlog schemas. Mainly for the purpose to avoid people needing to ask around to figure this out.\n\nFor instance, if a WG such as MOQ would like an extension schema for MOQT events, then it is probably most appropriate for the MOQ WG to work on it - because they are closes to the subject matter.\n\nProviding help, review and guidance for that work is something the QUIC WG should still consider though.",
      "createdAt": "2025-03-19T06:22:57Z",
      "updatedAt": "2025-07-07T02:26:29Z",
      "closedAt": "2025-07-07T02:26:29Z",
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wholeheartedly agree that we should provide this type of guidance. But is that something that belongs in the docs directly? ",
          "createdAt": "2025-03-19T14:40:09Z",
          "updatedAt": "2025-03-19T14:40:09Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I'm not conviced we need more text in documents. I think this is something that will become familiar to people over time as qlog schemas are defined in various places.",
          "createdAt": "2025-07-07T02:26:29Z",
          "updatedAt": "2025-07-07T02:26:29Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwMDI4NTY1",
      "title": "Fixed typo in \"version_negotiation\" enum member",
      "url": "https://github.com/quicwg/qlog/pull/12",
      "state": "MERGED",
      "author": "jlaine",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-22T20:34:38Z",
      "updatedAt": "2019-07-22T21:12:06Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "52267e9675f5fd06f5d507a1792aa601ea0bdb81",
      "headRepository": "jlaine/internet-drafts",
      "headRefName": "negotiation-typo",
      "headRefOid": "22e20c5e072d32d98f4e432effec3e2b49d6c869",
      "closedAt": "2019-07-22T21:12:06Z",
      "mergedAt": "2019-07-22T21:12:06Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "9bc53886d90472c68000652c2a1c83a9a6c338a5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEwMzM1NzE2",
      "title": "Rename \"type\" property to \"packet_type\" in packet events",
      "url": "https://github.com/quicwg/qlog/pull/18",
      "state": "MERGED",
      "author": "jlaine",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-08-23T10:53:01Z",
      "updatedAt": "2019-08-23T12:30:44Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "3b12117f096ab7fa7927516a39a2fd17b392d8d6",
      "headRepository": "jlaine/internet-drafts",
      "headRefName": "packet_type",
      "headRefOid": "f629b74ec44e95158b4594873c338435d07fc108",
      "closedAt": "2019-08-23T12:30:44Z",
      "mergedAt": "2019-08-23T12:30:44Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "886a41e3afc7634500ed382350508a1fe5c224b7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0NDMzMDYy",
      "title": "add the HANDSHAKE_DONE frame",
      "url": "https://github.com/quicwg/qlog/pull/38",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #37.",
      "createdAt": "2020-01-18T14:47:55Z",
      "updatedAt": "2020-01-18T15:31:42Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "e5c946c65db20624d4f06d5c9102d6154fc8c847",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "handshake-done",
      "headRefOid": "189dd7bbf606d0b8400d91260e704c9c328b6aa3",
      "closedAt": "2020-01-18T15:31:42Z",
      "mergedAt": "2020-01-18T15:31:42Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "b50635531bbbbcd059d9670b0b97f55069defb4f"
      },
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Done.",
          "createdAt": "2020-01-18T15:29:31Z",
          "updatedAt": "2020-01-18T15:29:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTQ3OTg4",
          "commit": {
            "abbreviatedOid": "5ec9531"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Could you also add HandshakeDoneFrame to the QuicFrame type in appendix A.4 (https://tools.ietf.org/html/draft-marx-qlog-event-definitions-quic-h3-01#appendix-A.4)? ",
          "createdAt": "2020-01-18T15:18:51Z",
          "updatedAt": "2020-01-18T15:18:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTQ4NTEy",
          "commit": {
            "abbreviatedOid": "189dd7b"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-18T15:31:31Z",
          "updatedAt": "2020-01-18T15:31:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0NDk4MTI4",
      "title": "move packet_size to events, move packet_type to PacketHeader",
      "url": "https://github.com/quicwg/qlog/pull/41",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #40.",
      "createdAt": "2020-01-19T05:31:38Z",
      "updatedAt": "2020-09-07T20:14:49Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "b50635531bbbbcd059d9670b0b97f55069defb4f",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "udp-vs-quic-header",
      "headRefOid": "ce9b1690e05a31048d39ec171721febb1922d618",
      "closedAt": "2020-09-07T20:14:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was a slightly bigger change than initially anticipated and made in https://github.com/quiclog/internet-drafts/commit/0cb1f02e3c8a60962bc39b387c5db9ba12210556. ",
          "createdAt": "2020-09-07T20:14:49Z",
          "updatedAt": "2020-09-07T20:14:49Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1MjMwMjI3",
      "title": "rename header_decrypt_error to header_parse_error",
      "url": "https://github.com/quicwg/qlog/pull/61",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #60.",
      "createdAt": "2020-03-08T05:53:58Z",
      "updatedAt": "2020-09-08T12:30:47Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "b50635531bbbbcd059d9670b0b97f55069defb4f",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "header-decrypt-error",
      "headRefOid": "359513a3bb236747fcbd71ee1f506e12199293ad",
      "closedAt": "2020-09-08T12:30:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Made change manually in draft02 branch in https://github.com/quiclog/internet-drafts/commit/a578e935e4cae5d3415bb46358a7b668bf4a4356",
          "createdAt": "2020-09-08T12:30:47Z",
          "updatedAt": "2020-09-08T12:30:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 63,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg3NjMyNDIw",
      "title": "rename idle_timeout to max_idle_timeout",
      "url": "https://github.com/quicwg/qlog/pull/63",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/quicwg/base-drafts/pull/3099.",
      "createdAt": "2020-03-13T07:30:34Z",
      "updatedAt": "2020-03-13T08:13:43Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "b50635531bbbbcd059d9670b0b97f55069defb4f",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "max-idle-timeout",
      "headRefOid": "a007af093fb3f7f77c82d415a6f366f2dc9b2098",
      "closedAt": "2020-03-13T08:13:43Z",
      "mergedAt": "2020-03-13T08:13:43Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "89d2a71667fbdf7888c9139583c84bc0a9690e0f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 67,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxODExNzMz",
      "title": "rename max_packet_size to max_udp_payload_size",
      "url": "https://github.com/quicwg/qlog/pull/67",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/quicwg/base-drafts/pull/3473.",
      "createdAt": "2020-03-21T04:03:25Z",
      "updatedAt": "2020-03-21T12:32:22Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "89d2a71667fbdf7888c9139583c84bc0a9690e0f",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "max-udp-payload-size",
      "headRefOid": "8c8e39e1dafd3ced236d384d20539a7a2dec25d2",
      "closedAt": "2020-03-21T12:32:21Z",
      "mergedAt": "2020-03-21T12:32:21Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "eeebaa4826d2596f552dedac95b4d01998d6e735"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkzODIxMTU2",
      "title": "Add stateless reset support",
      "url": "https://github.com/quicwg/qlog/pull/68",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Partially fixes #64.\r\n\r\nMain change is adding `stateless_reset` as a PacketType.\r\n\r\nThe `stateless_reset_token` is added as a field to packet_sent and packet_received.\r\nAny of the \"unpredictable bits\" can be logged as `raw_encrypted`\r\n\r\nAdded a trigger to `connection_state_update` to indicate if a connection goes into draining/closing because a valid stateless_reset was received.\r\n\r\nBackwards compatibility break: renamed `reset_token` to `stateless_reset_token` on the NewConnectionID frame definition (for consistency). \r\n\r\nBeen thinking about a way to signal an \"invalid\" stateless reset, but figured there is no way to distinguish it from an otherwise garbage datagram, so decided it was impossible. Not 100% sure about the \"looping case\" where you continually lower the packet size. Maybe that's solved by adding a generic \"packet_size\" trigger value to `packet_dropped` though?",
      "createdAt": "2020-03-25T20:50:37Z",
      "updatedAt": "2020-03-28T10:24:21Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "eeebaa4826d2596f552dedac95b4d01998d6e735",
      "headRepository": "quicwg/qlog",
      "headRefName": "stateless_reset",
      "headRefOid": "6ff25a4b44ee3a5f146381c737a5de3c64e14c78",
      "closedAt": "2020-03-28T10:24:21Z",
      "mergedAt": "2020-03-28T10:24:20Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "edf676c342bf73c168a27a4af6b6f45af58518ba"
      },
      "comments": [
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "LGTM!",
          "createdAt": "2020-03-27T02:54:01Z",
          "updatedAt": "2020-03-27T02:54:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMDE3NjE5",
          "commit": {
            "abbreviatedOid": "6ff25a4"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-26T13:40:51Z",
          "updatedAt": "2020-03-26T13:40:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1MDU5NTUz",
      "title": "update transport errors",
      "url": "https://github.com/quicwg/qlog/pull/70",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-28T07:26:37Z",
      "updatedAt": "2020-03-28T11:00:33Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "eeebaa4826d2596f552dedac95b4d01998d6e735",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "update-transport-errors",
      "headRefOid": "26a19a8f72339cac08eb277f45285fdd244981eb",
      "closedAt": "2020-03-28T11:00:33Z",
      "mergedAt": "2020-03-28T11:00:33Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "2a4dfd91598685b31daade04cf99db4bdffd2109"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 71,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1MDY0ODQy",
      "title": "add a packet number space field to loss_timer_set and loss_timer_expired",
      "url": "https://github.com/quicwg/qlog/pull/71",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #69.",
      "createdAt": "2020-03-28T08:27:33Z",
      "updatedAt": "2020-03-28T10:29:32Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "eeebaa4826d2596f552dedac95b4d01998d6e735",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "loss-timer-events-pn-space",
      "headRefOid": "da1743e05116cf2f0f0390ea24c54bf66b2df0c0",
      "closedAt": "2020-03-28T10:29:31Z",
      "mergedAt": "2020-03-28T10:29:31Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "d4a976e57f271d237d1818e5e56c62b6b60fd38b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1MDc5MjQ3",
      "title": "Merge loss_timer events",
      "url": "https://github.com/quicwg/qlog/pull/73",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #69.\r\n\r\nNot 100% sure this is enough for all the latest draft-27(+) changes though, added a TODO in the draft for that purpose. \r\n\r\nAlso added a packet_number_space field to metrics_updated to be flexible for implementations that don't want to implement all types of events. It's not a great fit at that location, but it seemed the most synergistic without having a completely new event type.\r\n\r\nPTAL @marten-seemann ",
      "createdAt": "2020-03-28T10:55:36Z",
      "updatedAt": "2020-03-29T11:23:59Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "d4a976e57f271d237d1818e5e56c62b6b60fd38b",
      "headRepository": "quicwg/qlog",
      "headRefName": "loss_timer",
      "headRefOid": "11720e0eb6c63f44526e7546c705aa419a7bf6ef",
      "closedAt": "2020-03-29T11:23:59Z",
      "mergedAt": "2020-03-29T11:23:59Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "a68c214abaa655138ad5935bf3a1021091bfc5a5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzg4MzI3",
          "commit": {
            "abbreviatedOid": "1833887"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-03-29T08:59:00Z",
          "updatedAt": "2020-03-29T09:01:06Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "There's no single point in time where the packet number space changes for loss recovery purposes. On the contrary, both client and server will have packets from different packet number spaces in flight during every QUIC handshake.\r\n\r\nTherefore I'd suggest to remove this field.",
              "createdAt": "2020-03-29T08:59:00Z",
              "updatedAt": "2020-03-29T11:10:15Z"
            },
            {
              "originalPosition": 64,
              "body": "Why do we need to export a trigger, if this is the only possible reason for canceling the timer anyway?",
              "createdAt": "2020-03-29T09:00:48Z",
              "updatedAt": "2020-03-29T11:10:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzk5MDAx",
          "commit": {
            "abbreviatedOid": "11720e0"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-29T11:13:37Z",
          "updatedAt": "2020-03-29T11:13:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAxNzczNjIw",
      "title": "add more packet_dropped triggers",
      "url": "https://github.com/quicwg/qlog/pull/77",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-10T06:13:27Z",
      "updatedAt": "2020-04-12T12:10:18Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "a68c214abaa655138ad5935bf3a1021091bfc5a5",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "more-drop-triggers",
      "headRefOid": "af1614c49eace48bf29b911790a9db0095b458ca",
      "closedAt": "2020-04-12T12:10:18Z",
      "mergedAt": "2020-04-12T12:10:18Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "9af27705fd0eed8f38465ebf34afeedc9e93d857"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Per discussion on slack, `unexpected_version_negotiation` and `unexpected_retry` can be merged into `unexpected_packet`, given that we have a `packet_type` field for the disambiguation. ",
          "createdAt": "2020-04-12T11:41:05Z",
          "updatedAt": "2020-04-12T11:41:05Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "@rmarx Done. Updated the PR.",
          "createdAt": "2020-04-12T11:56:16Z",
          "updatedAt": "2020-04-12T11:56:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 81,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzMDgyODg0",
      "title": "add a supported_versions array to packet_sent and packet_received",
      "url": "https://github.com/quicwg/qlog/pull/81",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partial fix for #75.",
      "createdAt": "2020-04-14T09:51:56Z",
      "updatedAt": "2020-04-14T14:40:18Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "9af27705fd0eed8f38465ebf34afeedc9e93d857",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "log-supported-versions",
      "headRefOid": "d02e59eeb7ca2df7787b9818b584629d01608cd9",
      "closedAt": "2020-04-14T14:40:17Z",
      "mergedAt": "2020-04-14T14:40:17Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "b0880b8a5ff7a9e856e321ff12465fd4be15cf5f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 82,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzMTEzNzAw",
      "title": "add a version_negotiation trigger for the closed connection_state_updated event",
      "url": "https://github.com/quicwg/qlog/pull/82",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-14T10:57:24Z",
      "updatedAt": "2020-04-14T14:39:52Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "9af27705fd0eed8f38465ebf34afeedc9e93d857",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "version-mismatch",
      "headRefOid": "573c8386c29bed76851f66c40158eb4165fb35a3",
      "closedAt": "2020-04-14T14:39:52Z",
      "mergedAt": "2020-04-14T14:39:52Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "05c45b5d9e2195535a610c28f9c4a27d88444c5d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 83,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzNTMwMzQ5",
      "title": "add a timeout trigger for the closed connection_state_updated event",
      "url": "https://github.com/quicwg/qlog/pull/83",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-15T04:12:58Z",
      "updatedAt": "2020-11-03T11:42:33Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "b0880b8a5ff7a9e856e321ff12465fd4be15cf5f",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "connection-state-timeout",
      "headRefOid": "08e4ca6944c39f416b951adba3dd03d30af326a7",
      "closedAt": "2020-11-03T11:42:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm unsure about this PR. In my implementation, I have an idle timeout as well as a handshake timeout (the handshake timeout way shorter than the idle timeout).\r\nWould it make sense to add a value for both? Or a separate field for trigger details?",
          "createdAt": "2020-04-15T07:43:32Z",
          "updatedAt": "2020-04-15T07:43:32Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In draft-02, I added a trigger value for both generic timeout and handshake_timeout based on quic-go's implementation. ",
          "createdAt": "2020-11-03T11:42:33Z",
          "updatedAt": "2020-11-03T11:42:33Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 84,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzNjUzMDA0",
      "title": "add a packet_size field to the packet_buffered event",
      "url": "https://github.com/quicwg/qlog/pull/84",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #76.",
      "createdAt": "2020-04-15T09:44:14Z",
      "updatedAt": "2020-07-22T07:48:09Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "b0880b8a5ff7a9e856e321ff12465fd4be15cf5f",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "packet-buffered-packet-size",
      "headRefOid": "e17dbba7a86e0c28814ed03b1d9833b2c0c2750a",
      "closedAt": "2020-07-22T07:48:08Z",
      "mergedAt": "2020-07-22T07:48:08Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "fc2eec4b31c9484f8891323017acdc20bae816b3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 87,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIyMzcxOTQz",
      "title": "Authenticate connection IDs",
      "url": "https://github.com/quicwg/qlog/pull/87",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Adds the transport parameters added in https://github.com/quicwg/base-drafts/pull/3499.",
      "createdAt": "2020-05-24T06:41:19Z",
      "updatedAt": "2020-07-22T07:48:29Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "b0880b8a5ff7a9e856e321ff12465fd4be15cf5f",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "authenticate-connection-ids",
      "headRefOid": "3f2ea8e74fb7a36fb692f4d96951de1656f13102",
      "closedAt": "2020-07-22T07:48:29Z",
      "mergedAt": "2020-07-22T07:48:28Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "09f447a17f183f02f8e0ada7cd0b834c3fd3963a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 92,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzNTYwODU1",
      "title": "add a packet_dropped trigger for duplicate packets",
      "url": "https://github.com/quicwg/qlog/pull/92",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#name-packet-numbers.",
      "createdAt": "2020-05-27T02:03:51Z",
      "updatedAt": "2020-07-22T07:46:53Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "d6433e1e93343aae970163d13549ad8361535330",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "packet-drop-duplicate",
      "headRefOid": "4278731985a41594c118fa093912a44e9d4e4ed4",
      "closedAt": "2020-07-22T07:46:53Z",
      "mergedAt": "2020-07-22T07:46:53Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "c93c66d7dafdba32aa415e720a84643ab4835f86"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 93,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMzMDA5OTUz",
      "title": "rename server_busy to connection_refused",
      "url": "https://github.com/quicwg/qlog/pull/93",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-11T11:19:22Z",
      "updatedAt": "2020-06-11T15:06:15Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "b0880b8a5ff7a9e856e321ff12465fd4be15cf5f",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "connection-refused",
      "headRefOid": "8d9475002611699c8381081fa90b95e51ea22f72",
      "closedAt": "2020-06-11T15:06:15Z",
      "mergedAt": "2020-06-11T15:06:15Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "b8a2fd89f64b95e026a68dfcfb879d6c695e1514"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 98,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ2MDkxNDgx",
      "title": "max_ack_delay is a constant, and logged in the transport parameters_set",
      "url": "https://github.com/quicwg/qlog/pull/98",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-08T08:47:07Z",
      "updatedAt": "2020-07-08T09:30:40Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "b8a2fd89f64b95e026a68dfcfb879d6c695e1514",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "remove-max-ack-delay-from-metrics-update",
      "headRefOid": "408d46cd7076062970ad2898cba4079091629cff",
      "closedAt": "2020-07-08T09:30:40Z",
      "mergedAt": "2020-07-08T09:30:40Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "11edf486b69a96720646b436789d33d4621a02e2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 99,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ2MDkyNjE0",
      "title": "remove in_recovery from metrics_update",
      "url": "https://github.com/quicwg/qlog/pull/99",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #96.",
      "createdAt": "2020-07-08T08:49:13Z",
      "updatedAt": "2020-07-08T09:29:59Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "b8a2fd89f64b95e026a68dfcfb879d6c695e1514",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "remove-in-recovery-from-metrics-update",
      "headRefOid": "a348778bab9d89e583a49e4262d3ab5be20c896d",
      "closedAt": "2020-07-08T09:29:59Z",
      "mergedAt": "2020-07-08T09:29:59Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "2b49fb613be515fdfde9eff5e1f66c455499fd35"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 103,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ2MTAzNDQ2",
      "title": "remove the UnknownFrame QUIC frame type",
      "url": "https://github.com/quicwg/qlog/pull/103",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Other than H3 frames, QUIC frames are not TLV encoded. It's therefore not possible to parse a frame type that your implementation doesn't understand. In fact, it's a protocol violation to even send such a frame.",
      "createdAt": "2020-07-08T09:08:43Z",
      "updatedAt": "2020-07-08T09:38:57Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "b8a2fd89f64b95e026a68dfcfb879d6c695e1514",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "remove-unknown-frame",
      "headRefOid": "76957f1589918be259181e40d9a9b6b810ceb9b2",
      "closedAt": "2020-07-08T09:38:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I follow you on this one.\r\n\r\nHere, the use case is for the receiver. They see an incoming frame with an unknown type, which, according to the spec, leads to a connection close:\r\n\r\n> An endpoint MUST treat the receipt of a frame of unknown type as a\r\n   connection error of type FRAME_ENCODING_ERROR.\r\n\r\nThis definition is to allow the endpoint to log more detailed info (or at least the raw value for manual dissection during debugging) about the unexpected frame before closing the connection. ",
          "createdAt": "2020-07-08T09:34:51Z",
          "updatedAt": "2020-07-08T09:34:51Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "That makes sense. Must have missed that, sorry.",
          "createdAt": "2020-07-08T09:38:56Z",
          "updatedAt": "2020-07-08T09:38:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 108,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ5NDM2MjM3",
      "title": "add an \"invalid_initial\" trigger to the packet_dropped event",
      "url": "https://github.com/quicwg/qlog/pull/108",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There are two conditions an Initial packet has to fulfill:\r\n1. It's DCID must be >= 8 bytes long.\r\n2. The size of the datagram must be >= 1200.\r\n\r\nNone of the other triggers for the `packet_dropped` event seem appropriate for this.",
      "createdAt": "2020-07-15T12:02:04Z",
      "updatedAt": "2020-07-22T07:45:42Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "fae11164cbfc22ff5aa6a763eae746e2e15abd00",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "add-invalid-initial-drop-trigger",
      "headRefOid": "0a8175658bf0aa7ef8d9ebd4754deb1a52c49844",
      "closedAt": "2020-07-22T07:45:42Z",
      "mergedAt": "2020-07-22T07:45:42Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "d6433e1e93343aae970163d13549ad8361535330"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE2NTY1NjM5",
      "title": "token-related fixes",
      "url": "https://github.com/quicwg/qlog/pull/123",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #122.\r\n\r\nThis PR contains 2 fixes:\r\n\r\n- stateless reset tokens are not tokens\r\n- `PacketHeader` already contains a `Token`, so we don't need another field on the `packet_sent` and `packet_received` event",
      "createdAt": "2020-11-06T07:36:26Z",
      "updatedAt": "2024-02-07T10:27:21Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "draft02",
      "baseRefOid": "197532463830d19b3e5b854f692951fc9a30ce9a",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "token-fixes",
      "headRefOid": "24a5388171711b68cae7430aa63e9e98c679e842",
      "closedAt": "2024-02-07T10:27:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Conclusion: remove retry_token from packet_sent and packet_received, allow using the token field on the header for Retry packets.",
          "createdAt": "2024-02-05T09:26:16Z",
          "updatedAt": "2024-02-05T09:26:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2MTU3MzQ2",
          "commit": {
            "abbreviatedOid": "24a5388"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-11-09T11:23:50Z",
          "updatedAt": "2020-11-09T11:23:59Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "So this is a bit of a difficult one imo. \r\nI'd put retry_token outside, since it's encapsulated in its own packet type, and so it can be considered to be part of the \"payload\" rather than the header. \r\nThis is different from the initial token, which is clearly part of the header.\r\n\r\nIf we do put the retry token in the PacketHeader struct, imo it would make sense to do the same for the stateless_reset_token as well, since from the same logic, you could say that that is part of the Stateless Reset Packet header as well, rater than its payload. \r\n\r\nI think it's probably cleaner to have all three in the PacketHeader then, with token?:Token covering both initial and retry as you proposed here. \r\n",
              "createdAt": "2020-11-09T11:23:51Z",
              "updatedAt": "2020-11-09T11:23:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 125,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMxNDA0NzMy",
      "title": "Field name consistency with QUIC draft 32",
      "url": "https://github.com/quicwg/qlog/pull/125",
      "state": "MERGED",
      "author": "toru",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently there's a mix of `limit` and `maximum` in the QLog spec, such that:\r\n\r\n```\r\nclass DataBlockedFrame{\r\n  frame_type:string = \"data_blocked\";\r\n\r\n  limit:uint64;\r\n}\r\n\r\n...\r\n\r\n class MaxDataFrame{\r\n   frame_type:string = \"max_data\";\r\n\r\n   maximum:string;\r\n }\r\n```\r\n\r\nI was kindly informed in the QLog chatroom that this was inherited from `h3-27`. Fast forward to `h3-32` these fields have been unified to `maximum`. Therefore let's update the spec for consistency (with QUIC and within QLog itself).",
      "createdAt": "2020-12-03T02:06:08Z",
      "updatedAt": "2020-12-03T09:05:29Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "draft02",
      "baseRefOid": "197532463830d19b3e5b854f692951fc9a30ce9a",
      "headRepository": "toru/internet-drafts",
      "headRefName": "limit-to-maximum",
      "headRefOid": "9a655f213f4e5cf8dff12d83116cbdaaac028c4b",
      "closedAt": "2020-12-03T09:05:22Z",
      "mergedAt": "2020-12-03T09:05:22Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "153756069ad5d56a720bf730d673f2c74cf1c2cb"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, this is clearly an oversight.\r\nEspecially for this type of event/frame, the goal is to be fully consistent with the terminology in the QUIC texts. I just missed they re-named it there. \r\n\r\nThanks for the PR!",
          "createdAt": "2020-12-03T09:05:29Z",
          "updatedAt": "2020-12-03T09:05:29Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 138,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkyNjg5Mzk3",
      "title": "introduce a VersionNegotiationError",
      "url": "https://github.com/quicwg/qlog/pull/138",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When a client receives a Version Negotiation packet indicating that there's no commonly supported version, it aborts the connection attempt. Currently, qlog doesn't allow to log this.",
      "createdAt": "2021-03-15T02:43:58Z",
      "updatedAt": "2023-03-12T09:06:38Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "d4b62cd84b73338c8be1b749f7686cccd2754967",
      "headRepository": "marten-seemann/internet-drafts",
      "headRefName": "version-negotiation-error",
      "headRefOid": "d532844064683e5a3c229d64ff1df541d99bfd2a",
      "closedAt": "2023-03-12T09:06:37Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Thinking about it, I'm not so sure about it any more. For stateless reset, we already use the `trigger` field. Maybe we should do the same for VN? Then we could close this PR.",
          "createdAt": "2021-03-15T05:28:52Z",
          "updatedAt": "2021-03-15T05:28:52Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think my intention here was that:\r\n- client logs `connection_closed` with trigger of value `version_mismatch` (which is already in -02, though potentially not perfectly named). Did you maybe miss that trigger? \r\n- to know which versions were offered and supported by both sides, you'd use the `version_information` event and `supported_versions` fields of `packet_sent/received` (see discussion in https://github.com/quiclog/internet-drafts/issues/75)\r\n\r\nI agree this is slightly more tedious than having all of that together in a single event, but IIUC your last reply here, that isn't very critical. \r\n",
          "createdAt": "2021-03-18T14:55:25Z",
          "updatedAt": "2021-03-18T14:55:25Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@marten-seemann I'm not sure how to proceed on this one. From my perspective, my approach in the previous comment should be sufficient and this PR can be closed?\r\n\r\nHowever, I did notice a few more aspects around this that I listed in #241. I suggest closing this PR and continuing discussion on that issue. \r\n",
          "createdAt": "2022-09-28T13:26:16Z",
          "updatedAt": "2022-09-28T13:26:16Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "@rmarx Sorry for dropping the ball on this. After re-reading this:\r\n\r\n> to know which versions were offered and supported by both sides, you'd use the version_information event and supported_versions fields of packet_sent/received (see discussion in https://github.com/quicwg/qlog/issues/75)\r\n\r\nOr the `TransportPacketSent` with `header.packet_type == \"version_negotiation\"`.\r\n\r\n> client logs connection_closed with trigger of value version_mismatch (which is already in -02, though potentially not perfectly named). Did you maybe miss that trigger?\r\n\r\nLooks like I did.\r\n\r\nI think this resolves the problem I was trying to solve, so we won't need this PR.",
          "createdAt": "2023-03-12T09:06:37Z",
          "updatedAt": "2023-03-12T09:06:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5DFWXA",
          "commit": {
            "abbreviatedOid": "d532844"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "You asked me to look at this from the point of view of \"compatible version negotiation\". I think the compatible VN logging is already OK. Compatible VN negotiation uses transport parameters. These parameters are already logged, see for example:\r\n```\r\n[68563, \"transport\", \"parameters_set\", {\r\n    \"owner\": \"local\",\r\n    \"initial_max_stream_data_bidi_local\" : 2097152,\r\n    \"initial_max_data\" : 1048576,\r\n    \"initial_max_streams_bidi\" : 513,\r\n    \"idle_timeout\" : 30000,\r\n    \"max_packet_size\" : 1440,\r\n    \"initial_max_streams_uni\" : 513,\r\n    \"initial_max_stream_data_bidi_remote\" : 65635,\r\n    \"initial_max_stream_data_uni\" : 65535,\r\n    \"active_connection_id_limit\" : 8,\r\n    \"max_ack_delay\" : 10,\r\n    \"handshake_connection_id\": \"091caa2b8bf8bc65\",\r\n    \"1cce\": \"8000fcc7\",\r\n    \"min_ack_delay\" : 1000,\r\n    \"enable_time_stamp\" : \"03\",\r\n    \"grease_quic_bit\" : \"\",\r\n    \"version_negotiation\": { \"chosen\": \"00000001\", \"others\": [\"00000002\", \"00000001\"]}}],\r\n```\r\n",
          "createdAt": "2022-09-29T14:59:36Z",
          "updatedAt": "2022-09-29T15:08:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Shouldn't this be optional? Are we missing a question mark?",
              "createdAt": "2022-09-29T14:59:37Z",
              "updatedAt": "2022-09-29T15:08:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 145,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA2MDQ1Nzc0",
      "title": "Add myself as editor",
      "url": "https://github.com/quicwg/qlog/pull/145",
      "state": "CLOSED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-31T17:22:06Z",
      "updatedAt": "2021-05-01T13:26:41Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "d4b62cd84b73338c8be1b749f7686cccd2754967",
      "headRepository": "lnicco/internet-drafts",
      "headRefName": "luca_author",
      "headRefOid": "1cfa1f014ae74189b8a4b7fb7f14b3944e95f021",
      "closedAt": "2021-05-01T13:26:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Forgot to merge this before starting a separate branch for the pre-adoption changes, so made the changes manually in #155 :) ",
          "createdAt": "2021-05-01T13:26:41Z",
          "updatedAt": "2021-05-01T13:26:41Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 151,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE1ODQ3ODA1",
      "title": "Remove event field (only name is preferred in draft-02)",
      "url": "https://github.com/quicwg/qlog/pull/151",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #149 ",
      "createdAt": "2021-04-15T08:37:38Z",
      "updatedAt": "2021-04-15T09:28:33Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "d4b62cd84b73338c8be1b749f7686cccd2754967",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-extra-events",
      "headRefOid": "1862d3f97ca9298a380931ac74d4c895416f8a8f",
      "closedAt": "2021-04-15T09:28:33Z",
      "mergedAt": "2021-04-15T09:28:33Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "d820822898dc3cd9030d32f491d7c3b1cb964cac"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM2NDUxNTg1",
          "commit": {
            "abbreviatedOid": "1862d3f"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-15T09:06:25Z",
          "updatedAt": "2021-04-15T09:06:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 155,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI4NDMxNzY4",
      "title": "Prepare for adoption",
      "url": "https://github.com/quicwg/qlog/pull/155",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR tracks the changes necessary to prepare for adoption by the QUIC wg as defined in #137.\r\n\r\nIt currently contains all the text changes, still requiring a few other things after they are approved (remove old document files, switch master branch to main, submit updated docs as individual drafts for the adoption call.",
      "createdAt": "2021-05-01T13:19:29Z",
      "updatedAt": "2021-05-17T18:56:09Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "master",
      "baseRefOid": "d820822898dc3cd9030d32f491d7c3b1cb964cac",
      "headRepository": "quicwg/qlog",
      "headRefName": "pre-adoption",
      "headRefOid": "8953dda487e4492c2d47e9778f22452283e7ea71",
      "closedAt": "2021-05-15T19:31:24Z",
      "mergedAt": "2021-05-15T19:31:24Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "514b0d461f607dfac00097a461969d3d3fc74ddb"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For those of you who don't use a local checkout of this to view the resulting HTML after the changes, I've attached them separately:\r\n\r\n[pre-adoption-html-v1.zip](https://github.com/quiclog/internet-drafts/files/6409599/pre-adoption-html-v1.zip)\r\n",
          "createdAt": "2021-05-01T13:23:01Z",
          "updatedAt": "2021-05-01T13:23:01Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Two other points raised by Lucas:\r\n- Add more information about \"previous versions\" (e.g., two main versions in production, -01 and -02, those pre-date these adopted documents)\r\n- Define a new version codepoint for the adopted drafts (now it's still draft-03-wip, but we also can't just do draft-00 or we'll overlap soon. Maybe qlog-0x?)",
          "createdAt": "2021-05-03T12:37:59Z",
          "updatedAt": "2021-05-03T12:37:59Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Do we  also need independent versioning of the different schema? How does qlog evolve over the years? For example, say the main schema got published as 1.0, and then work commenced on 2.0. Can there be a QUIC qlog event definitions 1.1 (which is updated say to support QUIC v2) and a 2.1 (which is updated to support QUIC v2 and a new main schema format)? \r\n\r\nThere's a lot of possible bikeshedding here. For now, maybe you just want to keep your linear versioning scheme (qlog 01, 02, and next 03) and make it clear that it is decoupled from any document draft id version.\r\n",
          "createdAt": "2021-05-05T23:45:34Z",
          "updatedAt": "2021-05-05T23:45:34Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks all for the reviews! \r\n\r\n@lnicco I fully agree that the current text isn't really fit for a proper I-D and especially eventual RFC. I'm hoping we can make things much stricter and clearer following wg consensus on some main points. I'm also hoping the new editors will help re-write some things when that happens ;) \r\n\r\n\r\nI have just fixed the remarks (hopefully), merged the PR and tried to submit the new drafts to the datatracker. \r\nI ran into some problems due to not being familiar with the process there though, doing something different for all 3 documents...\r\n\r\n- main-schema-03 should be published as normal (was somehow auto-posted to the QUIC list...)\r\n- quic-events-00 somehow ended up as having to go through a manual review process (editors got an email about that)\r\n- h3-events-00 has to be approved by the QUIC wg chairs first (no clue why/how that triggered, but @LPardue got an email for that, so...)\r\n\r\nSo you'll probably see some weird emails and the 2 event-definition documents are somewhat delayed behind main-schema, but hopefully things will be sorted soon!\r\n\r\n",
          "createdAt": "2021-05-15T20:17:16Z",
          "updatedAt": "2021-05-15T20:17:16Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After guidance from the QUIC wg chairs, I have now cancelled submission of:\r\n- draft-marx-qlog-quic-events-00\r\n- draft-marx-qlog-h3-events-00\r\n\r\nAnd instead re-submitted as:\r\n- draft-marx-quic-qlog-quic-events-00\r\n- draft-marx-quic-qlog-h3-events-00\r\n\r\nto make it clearer these are adoption candidates. These are both still pending approval from the QUIC wg chairs, so not quite published yet. \r\n\r\n",
          "createdAt": "2021-05-17T09:07:41Z",
          "updatedAt": "2021-05-17T09:07:41Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The soap continued... apparently this all triggered a bug in datatracker when trying to replace documents that are in pre-adoption with a wg (it's not quite a compiler bug, but I'll take it for now ;)). \r\n\r\nThe chosen solution is to submit the new drafts again, without indicating they replace the old joint h3+quic events draft. The idea is that the backlinking will be corrected post-adoption.\r\n\r\nFor clarity, these are the most recent drafts that the adoption call will be issued for:\r\n- https://datatracker.ietf.org/doc/draft-marx-quic-qlog-h3-events/\r\n- https://datatracker.ietf.org/doc/draft-marx-quic-qlog-quic-events/\r\n- https://datatracker.ietf.org/doc/draft-marx-qlog-main-schema/\r\n",
          "createdAt": "2021-05-17T18:56:09Z",
          "updatedAt": "2021-05-17T18:56:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUwMjg4NzQ4",
          "commit": {
            "abbreviatedOid": "8fb4412"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-03T12:03:26Z",
          "updatedAt": "2021-05-03T12:03:26Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "You could still point people to this repo in order to collect any adoption call feedback. Then, any and all issues can be brought across to the QUIC WG org when the repo is transferred. And we can update the URL to that new one when the adopted `-00` gets published.",
              "createdAt": "2021-05-03T12:03:26Z",
              "updatedAt": "2021-05-03T12:03:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUwMjkyOTUx",
          "commit": {
            "abbreviatedOid": "8fb4412"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-03T12:10:31Z",
          "updatedAt": "2021-05-03T12:10:31Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Is the intent to delete this file?",
              "createdAt": "2021-05-03T12:10:31Z",
              "updatedAt": "2021-05-03T12:10:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUwMzE5NzM0",
          "commit": {
            "abbreviatedOid": "8fb4412"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-03T12:50:34Z",
          "updatedAt": "2021-05-03T12:50:34Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Indeed, this one is removed and replaced by the two new ones.",
              "createdAt": "2021-05-03T12:50:34Z",
              "updatedAt": "2021-05-03T12:50:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyODUyNjc5",
          "commit": {
            "abbreviatedOid": "8fb4412"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-05T23:36:44Z",
          "updatedAt": "2021-05-05T23:36:45Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "so uhh, why isn't it `git rm`'d ? :D",
              "createdAt": "2021-05-05T23:36:44Z",
              "updatedAt": "2021-05-05T23:36:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU1MDgwNDM3",
          "commit": {
            "abbreviatedOid": "8fb4412"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, but as @LPardue pointed out, don't we need to delete the old documents?",
          "createdAt": "2021-05-09T13:46:54Z",
          "updatedAt": "2021-05-09T13:46:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU1ODU1MjE0",
          "commit": {
            "abbreviatedOid": "8fb4412"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. Thanks Robin for doing this.\r\n\r\nI have a couple minor comments and a generic comment about considering making the document more strict in the future. \r\nRight now it reads like a \"hands on experience\" document, which is a great start but I think the end goal could be to make some of the text more strict to provide more precise guidelines to QLOG (and QLOG tools) implementors. \r\n\r\nBut that's a separate discussion. \r\nShip it!",
          "createdAt": "2021-05-10T16:44:54Z",
          "updatedAt": "2021-05-10T20:19:40Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "why is HTTPS2 and HTTP3 ? \r\nIf Secure is implicit with QUIC but not with TCP, maybe this should be `[\"TCP\", \"TLS\", \"HTTP2\"]` ? ",
              "createdAt": "2021-05-10T16:44:55Z",
              "updatedAt": "2021-05-10T20:19:40Z"
            },
            {
              "originalPosition": 206,
              "body": "I think this is fine for now, but it could be more prescriptive in the future. \r\nAllowing total freedom in the events definition can make the development of generic tools harder. ",
              "createdAt": "2021-05-10T17:24:57Z",
              "updatedAt": "2021-05-10T20:19:40Z"
            },
            {
              "originalPosition": 198,
              "body": "is this a SHOULD ? not sure",
              "createdAt": "2021-05-10T20:13:59Z",
              "updatedAt": "2021-05-10T20:19:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 161,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgxNjU3NDgx",
      "title": "Rename stream_id to id for the GOAWAY frame",
      "url": "https://github.com/quicwg/qlog/pull/161",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #160. Oversight when keeping up with the latest H3 drafts.",
      "createdAt": "2021-07-01T09:15:05Z",
      "updatedAt": "2021-07-01T12:48:40Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "d7af14438aeefd3d24a8d76d41352515ff0ed3ff",
      "headRepository": "quicwg/qlog",
      "headRefName": "goaway-id",
      "headRefOid": "698cc5790d1d1bd9ce11b3cd6d49d528e0821067",
      "closedAt": "2021-07-01T12:48:29Z",
      "mergedAt": "2021-07-01T12:48:29Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "56b907899f5e20a58dfa651d6922377d3108effd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3MTYyMjQ4",
          "commit": {
            "abbreviatedOid": "698cc57"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-01T12:06:15Z",
          "updatedAt": "2021-07-01T12:06:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 162,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgxODI5MTI2",
      "title": "circles are so 2020",
      "url": "https://github.com/quicwg/qlog/pull/162",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-01T12:52:36Z",
      "updatedAt": "2021-08-18T09:42:39Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "56b907899f5e20a58dfa651d6922377d3108effd",
      "headRepository": "quicwg/qlog",
      "headRefName": "closing-the-loop-on-the-circle",
      "headRefOid": "5e8c4ed7fb8c7d4780c9958b3c08b7b40786f476",
      "closedAt": "2021-08-18T09:42:39Z",
      "mergedAt": "2021-08-18T09:42:39Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "5796bb5a608d2459fa03fa5782d7c2ad71cc9ab0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 177,
      "id": "PR_kwDOCrLn6M4r8_iN",
      "title": "Fix 0RTT and 1RTT definitions in PacketType",
      "url": "https://github.com/quicwg/qlog/pull/177",
      "state": "MERGED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #128\n",
      "createdAt": "2021-09-20T09:41:50Z",
      "updatedAt": "2021-10-06T09:53:58Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "27690bdf78b94592ffe21e70c8ade862b2e64036",
      "headRepository": "quicwg/qlog",
      "headRefName": "fix_packet_type",
      "headRefOid": "f1eb852fd7628daccaa38ed74a6b62c1799f2e14",
      "closedAt": "2021-10-06T09:53:51Z",
      "mergedAt": "2021-10-06T09:53:51Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "a64268dc17a7beebbf8df7567da8a5cf2ac360d3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M4tNVcS",
          "commit": {
            "abbreviatedOid": "f1eb852"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-20T10:28:30Z",
          "updatedAt": "2021-09-20T10:28:37Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "nit: one could argue that RTT should be lowercase for consistency with the other types.",
              "createdAt": "2021-09-20T10:28:31Z",
              "updatedAt": "2021-09-20T10:28:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4tNWV0",
          "commit": {
            "abbreviatedOid": "f1eb852"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-20T10:33:19Z",
          "updatedAt": "2021-09-20T10:33:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Somewhat disagree. RTT is an acronym and the others are not. The RFCs also use the uppercased version of this. Finally, for backwards-compat with existing qlog implementations, 0RTT and 1RTT is easiest. ",
              "createdAt": "2021-09-20T10:33:19Z",
              "updatedAt": "2021-09-20T10:33:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4tb-Lh",
          "commit": {
            "abbreviatedOid": "f1eb852"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-23T17:25:32Z",
          "updatedAt": "2021-09-23T17:25:32Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "@rmarx sounds good. \r\nAre there any other concerns, or can this be merged?",
              "createdAt": "2021-09-23T17:25:32Z",
              "updatedAt": "2021-09-23T17:25:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4uCpOS",
          "commit": {
            "abbreviatedOid": "f1eb852"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T09:53:57Z",
          "updatedAt": "2021-10-06T09:53:58Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This is fine I think. \r\n\r\nFor other, larger changes, we'd ideally also add an entry in the changelist on the bottom. But this is such a small thing that it's not needed. ",
              "createdAt": "2021-10-06T09:53:57Z",
              "updatedAt": "2021-10-06T09:53:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 181,
      "id": "PR_kwDOCrLn6M4tcxPk",
      "title": "Move from NDJSON to JSON Text Sequences",
      "url": "https://github.com/quicwg/qlog/pull/181",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Additionally also specified Media Types and file extensions for the various formats\r\n\r\nPertains to #180, #172 and #158.",
      "createdAt": "2021-10-20T16:23:17Z",
      "updatedAt": "2021-10-25T11:42:35Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "b56e74ab9c2e3a09edfc37985d840d2587bcd8cd",
      "headRepository": "quicwg/qlog",
      "headRefName": "text-sequences",
      "headRefOid": "46a5b051afc2837bcb091e93e1f9000bcd0ec170",
      "closedAt": "2021-10-25T11:42:35Z",
      "mergedAt": "2021-10-25T11:42:35Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "0a0d7a78c492ff0fa0b3845b467731fd5cbc711c"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hello all,\r\n\r\nI've tried to resolve all the excellent comments as well as possible. \r\n\r\nIf you have time, please try to review the new changes, and then I will mint a new draft-01 tomorrow!",
          "createdAt": "2021-10-24T10:42:55Z",
          "updatedAt": "2021-10-24T10:42:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M4u0vwh",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T11:46:42Z",
          "updatedAt": "2021-10-21T11:52:35Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nqlog event is interpreted as an individual JSON Text Sequence record, and can\r\n```",
              "createdAt": "2021-10-21T11:46:42Z",
              "updatedAt": "2021-10-21T11:52:35Z"
            },
            {
              "originalPosition": 166,
              "body": "Is there any way we can make it more obvious that `RS` are not the ASCII characters `R` and `S`?",
              "createdAt": "2021-10-21T11:47:49Z",
              "updatedAt": "2021-10-21T11:52:35Z"
            },
            {
              "originalPosition": 367,
              "body": "Is this correct? Wouldn't the media type be `application/gzip` or something like that?",
              "createdAt": "2021-10-21T11:52:10Z",
              "updatedAt": "2021-10-21T11:52:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u06Z8",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T12:29:26Z",
          "updatedAt": "2021-10-21T12:29:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "It would be good to provide a reference for JSON and/or JSON Text Sequences here.",
              "createdAt": "2021-10-21T12:29:27Z",
              "updatedAt": "2021-10-21T12:29:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u0--v",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T12:45:26Z",
          "updatedAt": "2021-10-21T13:21:30Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "We should think strongly about version management moving forward. It appears here that you are reverting back to linking the version of qlog to the version of I-D revision. That has some serious downsides:\r\n\r\n1. I-Ds are cheap. We should be releasing them at a pace it make sense for the contents of an I-D, including non-functional editorial changes.\r\n1. Conversely, having the draft version tied to meaningful changes encourages not releasing new drafts. Or means that people need to alias multiple draft versions as the same logical thing.\r\n1. We have 3 documents. Needing to synchronize those draft versions adds coordination overhead\r\n\r\nAt this point, I would recommend versioning that is decoupled from the I-D versions. That way, you can simply change the \"qlog_version\" whenever you like and people have a clearer idea of the intention. You might also want to start at version `00` then.\r\n",
              "createdAt": "2021-10-21T12:45:27Z",
              "updatedAt": "2021-10-21T13:21:30Z"
            },
            {
              "originalPosition": 65,
              "body": "if this is a normative recommendation, the reference should be too. This applies to other instances and other refs.\r\n\r\n```suggestion\r\nand the Media Type (if any) SHOULD be \"application/qlog+json\" {{!RFC6839}}.\r\n```",
              "createdAt": "2021-10-21T12:47:16Z",
              "updatedAt": "2021-10-21T13:21:30Z"
            },
            {
              "originalPosition": 166,
              "body": "What I would do here is update the above comment to say something like \r\n\r\n```\r\n// list of qlog events, serialized in accordance with RFC 7464.\r\n// For display purposes, record separators are rendered as <RS>\r\n```\r\n\r\nand then use <RS> (which is what RFC 7464 does)",
              "createdAt": "2021-10-21T12:58:29Z",
              "updatedAt": "2021-10-21T13:21:30Z"
            },
            {
              "originalPosition": 201,
              "body": "I think it would help to move these notes above the example. The use of newlines in the body was a little surprise!",
              "createdAt": "2021-10-21T13:02:01Z",
              "updatedAt": "2021-10-21T13:21:30Z"
            },
            {
              "originalPosition": 327,
              "body": "I opened https://github.com/NTAP/isb-ietf-config/issues/10",
              "createdAt": "2021-10-21T13:11:17Z",
              "updatedAt": "2021-10-21T13:21:30Z"
            },
            {
              "originalPosition": 364,
              "body": "what is cbor-seq? Maybe just a typo?",
              "createdAt": "2021-10-21T13:21:08Z",
              "updatedAt": "2021-10-21T13:21:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u4EQ6",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T05:50:25Z",
          "updatedAt": "2021-10-22T05:50:26Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "I have a question that is most likely something you'll tell me to spin off as a new issue (and maybe relates to the planned schema chages CDDL), but I'l mention it here since you're touching things. Not taking action in this PR is ok but I think it might need answering long term.\r\n\r\nBased on the definition of `class QLogFile` and `class QlogFileSeq`, the only difference seems to be that `traces: Array<Trace>` vs `trace: Trace`.\r\n\r\n Now if I read the prose, it suggests that the JSON-SEQ version of `Trace` is actually different because it doesn't contain events.\r\n\r\nThere's inconsistency of approach here. On one hand, because there is a difference in cardinality of traces, you are defining two different `file` types. On the other hand, there is a different in cardinality of events but you don't define two different trace types. It would seem better to me to have a consistent approach - either a single `file` type that can accommodate the different requirements of traces, **or** multiple trace types for JSON and JSON-SEQ respectively.",
              "createdAt": "2021-10-22T05:50:25Z",
              "updatedAt": "2021-10-22T05:50:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u6Bqm",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T15:00:29Z",
          "updatedAt": "2021-10-22T15:00:30Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Agreed that this is needed and I like Lucas' suggestion",
              "createdAt": "2021-10-22T15:00:30Z",
              "updatedAt": "2021-10-22T15:00:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u6DMl",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T15:05:53Z",
          "updatedAt": "2021-10-22T15:05:53Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "That's a good point... I just keep bikeshedding version names in my mind...\r\n\r\n- `ietf-00` is a bit weird, as older drafts were also at the IETF...\r\n- `00` is also a bit weird, since we'd probably like that for the final versions\r\n- `WIP-00` is ok, but I like to keep WIP versions for editor's copies (e.g., people already implementing and testing editor's copies before a new draft is minted. We had this previously between draft-01 and -02). Though maybe if we are more aggressive about releasing drafts this isn't needed anymore. \r\n- `0.1` (or similar semantic versioning) seems good enough, but then maybe it's nicer to start from 0.3 (keeping `draft-01` and `draft-02` as aliases for `0.1` and `0.2`? ",
              "createdAt": "2021-10-22T15:05:53Z",
              "updatedAt": "2021-10-22T15:05:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u6EUy",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T15:09:56Z",
          "updatedAt": "2021-10-22T15:09:56Z",
          "comments": [
            {
              "originalPosition": 364,
              "body": "This strangely actually exists, see https://www.iana.org/assignments/media-type-structured-suffix/media-type-structured-suffix.xhtml and https://www.rfc-editor.org/rfc/rfc8742.html\r\n\r\nWasn't sure how to refer to that registry though... maybe also just link to the RFC?",
              "createdAt": "2021-10-22T15:09:56Z",
              "updatedAt": "2021-10-22T15:09:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u6E4s",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T15:11:58Z",
          "updatedAt": "2021-10-22T15:11:58Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "I understand what you're saying and feel this should be fixed in this PR, not a separate issue. \r\n\r\nI think defining a new Trace class is probably the best way forward here. The exact way of defining that will change with CDDL, but for now making this more explicit is probably best. ",
              "createdAt": "2021-10-22T15:11:58Z",
              "updatedAt": "2021-10-22T15:11:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u6GMv",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T15:16:35Z",
          "updatedAt": "2021-10-22T15:16:35Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "yes, picking the answer here is tricky.\r\n\r\nI agree we should keep WIP for the changes-in-flight between one version and the next.\r\n\r\nSemantic versioning could be ok, since we won't be stablising things until \"1.0\" which would coincide with an RFC. However, I wonder how that might break any current qlog tools because its a departure from the kind of format already used. If there's not trouble there then I can get behind a \"0.3\".\r\n",
              "createdAt": "2021-10-22T15:16:35Z",
              "updatedAt": "2021-10-22T15:16:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u6LKf",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T15:35:25Z",
          "updatedAt": "2021-10-22T15:35:25Z",
          "comments": [
            {
              "originalPosition": 364,
              "body": "interesting! And it's cool that RFC 8742 mentions how JSON-SEQ and CBOR-SEQ relate to each other. \r\n\r\nI think the most straightforward way for now is to leave the table simple but highlight the releationship between these two in the {{binary}} section.",
              "createdAt": "2021-10-22T15:35:25Z",
              "updatedAt": "2021-10-22T15:35:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u7-Ag",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-24T06:18:19Z",
          "updatedAt": "2021-10-24T06:18:19Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "`\"records\"` (with quotes) feels a bit colloquial. \r\nI'd say use either `records` (no quotes), or just `objects` ? ",
              "createdAt": "2021-10-24T06:18:19Z",
              "updatedAt": "2021-10-24T06:18:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u7-HX",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-24T06:23:49Z",
          "updatedAt": "2021-10-24T06:23:50Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "NIT: \r\nif `\".(s)qlog.A.B\"` is meant to be a regex should it be \".(s)?qlog.A.B\" ?\r\nBut that would impact readability perhaps. Not feeling strongly about this, just pointing it out",
              "createdAt": "2021-10-24T06:23:50Z",
              "updatedAt": "2021-10-24T06:23:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u8DQ8",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-24T10:23:47Z",
          "updatedAt": "2021-10-24T10:23:47Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "It's not meant to be a regex, as I assume a letter encased in ( ) would mean optional to the reader, much like in normal prose. ",
              "createdAt": "2021-10-24T10:23:47Z",
              "updatedAt": "2021-10-24T10:23:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u8DZk",
          "commit": {
            "abbreviatedOid": "8cb5956"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-24T10:29:55Z",
          "updatedAt": "2021-10-24T10:29:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I feel like the format change shouldn't matter for tooling, as they should have been handling the version as an opaque string. At least for qvis, this would mean just aliasing 0.3 to our existing draft-02 parser (with some extra checks for JSON-SEQ). \r\n\r\nAs supporters of 0.3 need to make changes for JSON-SEQ anyway, I think this shouldn't be a problem and a good way forward in general, so I've made the change. ",
              "createdAt": "2021-10-24T10:29:55Z",
              "updatedAt": "2021-10-24T10:29:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M4u8KnH",
          "commit": {
            "abbreviatedOid": "f4ba514"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Design changes LGTM.\r\n\r\nThere are some broader editorial improvements that could be made but they can be done later on (when we're not up agaisnt the publish cutoff date).",
          "createdAt": "2021-10-24T15:16:00Z",
          "updatedAt": "2021-10-24T15:16:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M4u8Liu",
          "commit": {
            "abbreviatedOid": "f4ba514"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-24T15:56:55Z",
          "updatedAt": "2021-10-24T15:56:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 189,
      "id": "PR_kwDOCrLn6M4yzX0_",
      "title": "Fix main schema build errors and wrapping",
      "url": "https://github.com/quicwg/qlog/pull/189",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "- main: temporarily remove {: .language-json} tags until diagrams are changed\r\n- main: wrap lines to appease xml2rfc\r\n\r\nHelps address part of #188.\r\n\r\nIn this spec, you have a fundamental problem that the json in examples is malformed and kramdown complains. So let's just disable that for now. \r\n\r\nThe rest of the changes are tedious but also not too onerous. The main issue you have is that there's lots of comments here and there that break length limits. So I've just picked a line length that will appease xml2rfc. \r\n\r\nIn some cases, you have comments inside JSON, which won't work. In one case I deleted some because the qlog properties might get deleted anyway.\r\n\r\nThe changes you have in mind might have obviated the errors anyway. But if not, these changes will set a strong foundation to know how to shut xml2rfc up.",
      "createdAt": "2022-02-14T17:30:05Z",
      "updatedAt": "2022-02-18T11:17:39Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "0a0d7a78c492ff0fa0b3845b467731fd5cbc711c",
      "headRepository": "quicwg/qlog",
      "headRefName": "lucas/fix-main-schema",
      "headRefOid": "335cdbc19b1195a62e75e6c3682b9ce884ea5cb6",
      "closedAt": "2022-02-18T11:17:39Z",
      "mergedAt": "2022-02-18T11:17:39Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "fac519ace6ed637d406170db1aab36768a3b730e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M40kdTh",
          "commit": {
            "abbreviatedOid": "335cdbc"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T17:34:18Z",
          "updatedAt": "2022-02-14T17:34:19Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "Why these changes?",
              "createdAt": "2022-02-14T17:34:18Z",
              "updatedAt": "2022-02-14T17:34:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M40kiYK",
          "commit": {
            "abbreviatedOid": "335cdbc"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T17:52:41Z",
          "updatedAt": "2022-02-14T17:52:41Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "in this specific case, the newlines matter. While the format does support them, it might confuse readers. So I changed the events to ones that had a slightly shorter name but still seemed to be semantically valid.",
              "createdAt": "2022-02-14T17:52:41Z",
              "updatedAt": "2022-02-14T17:52:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M40kjRY",
          "commit": {
            "abbreviatedOid": "335cdbc"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T17:55:55Z",
          "updatedAt": "2022-02-14T17:55:56Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "Ok.",
              "createdAt": "2022-02-14T17:55:55Z",
              "updatedAt": "2022-02-14T17:55:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M40kjSY",
          "commit": {
            "abbreviatedOid": "335cdbc"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T17:55:58Z",
          "updatedAt": "2022-02-14T17:55:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M404Mog",
          "commit": {
            "abbreviatedOid": "335cdbc"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-18T11:16:56Z",
          "updatedAt": "2022-02-18T11:16:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 190,
      "id": "PR_kwDOCrLn6M4yzYaa",
      "title": "Fix H3 and QPACK wrapping",
      "url": "https://github.com/quicwg/qlog/pull/190",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes part of #188. The changes are tedious but also not too onerous. The main issue you have is that there's lots of comments here and there that break length limits. So I've just picked a line length that will appease xml2rfc.\r\n\r\nThe changes you have in mind might have obviated the errors anyway. But if not, these changes will set a strong foundation to know how to shut xml2rfc up.",
      "createdAt": "2022-02-14T17:32:31Z",
      "updatedAt": "2022-02-18T11:20:22Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "0a0d7a78c492ff0fa0b3845b467731fd5cbc711c",
      "headRepository": "quicwg/qlog",
      "headRefName": "lucas/fix-h3-line-width",
      "headRefOid": "a527786789d2349b0f308f26dc0cb24a94b144f1",
      "closedAt": "2022-02-18T11:20:22Z",
      "mergedAt": "2022-02-18T11:20:22Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "8dd481ad98f85bc5db16fc8d01bdf20b312f39e1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M40kePg",
          "commit": {
            "abbreviatedOid": "a527786"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T17:37:37Z",
          "updatedAt": "2022-02-14T17:37:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M40kyym",
          "commit": {
            "abbreviatedOid": "a527786"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T18:56:05Z",
          "updatedAt": "2022-02-14T18:56:05Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "yes, xml2rfc even moans about the title length :laughing: ",
              "createdAt": "2022-02-14T18:56:05Z",
              "updatedAt": "2022-02-14T18:56:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M404NaP",
          "commit": {
            "abbreviatedOid": "a527786"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-18T11:20:14Z",
          "updatedAt": "2022-02-18T11:20:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 191,
      "id": "PR_kwDOCrLn6M4yzg_L",
      "title": "Fix QUIC events wrapping and errors",
      "url": "https://github.com/quicwg/qlog/pull/191",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "- quic: fix artwork line length\r\n- quic: stick commas between refs to unfool xml2rfc\r\n\r\nFixes part of https://github.com/quicwg/qlog/issues/188. The changes are tedious but also not too onerous. The main issue you have is that there's lots of comments here and there that break length limits. So I've just picked a line length that will appease xml2rfc.\r\n\r\nThe changes you have in mind might have obviated the errors anyway. But if not, these changes will set a strong foundation to know how to shut xml2rfc up.",
      "createdAt": "2022-02-14T18:11:09Z",
      "updatedAt": "2022-02-18T11:23:19Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "0a0d7a78c492ff0fa0b3845b467731fd5cbc711c",
      "headRepository": "quicwg/qlog",
      "headRefName": "lucas/fix-quic-events",
      "headRefOid": "fd68ca3d9f5f60beaaf9c62f48d9538afc10c640",
      "closedAt": "2022-02-18T11:23:19Z",
      "mergedAt": "2022-02-18T11:23:19Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "9b28c154492e6dac2491dfded48d2def56ed3179"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M40kqpr",
          "commit": {
            "abbreviatedOid": "fd68ca3"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T18:23:19Z",
          "updatedAt": "2022-02-14T18:23:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M404OEU",
          "commit": {
            "abbreviatedOid": "fd68ca3"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-18T11:23:10Z",
          "updatedAt": "2022-02-18T11:23:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 193,
      "id": "PR_kwDOCrLn6M4zLk9j",
      "title": "Move to CDDL - main schema",
      "url": "https://github.com/quicwg/qlog/pull/193",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR bundles the TypeScript-to-CDDL changes for draft 0.4 for the main schema document (see other PRs for the QUIC and H3/QPACK documents). \r\n\r\nList of intended changes:\r\n\r\n- [x] Replace TypeScript with CDDL descriptions\r\n- [x] Split up CDDL definitions and JSON examples\r\n- [ ] Properly explain the $ProtocolEventBody extension point + include trigger in the example \r\n- [ ] Properly discuss how event docs should define triggers in the CDDL \r\n- [x] Replace TypeScript explanation in `Notational Conventions` and `qlog to JSON mapping` with CDDL and I-JSON references, basic explanations and considerations.\r\n- [x] Refer to main schema CDDL introduction in H3 and QUIC docs as well\r\n- [x] Explain the need for custom uint64 and hexstring CDDL types\r\n- [x] Add uint32, uint16 and uint8 types\r\n- [x] Add $ProtocolEventBody listings in the QUIC and H3 docs as well!\r\n- [x] Update QUIC and H3 docs to use uint32 instead of normal uint",
      "createdAt": "2022-02-19T19:09:46Z",
      "updatedAt": "2022-03-07T19:08:14Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "9b28c154492e6dac2491dfded48d2def56ed3179",
      "headRepository": "quicwg/qlog",
      "headRefName": "cddl-main-04",
      "headRefOid": "d136d07b91496333a7f54f1af8c3bbd740b33ca8",
      "closedAt": "2022-03-07T19:08:14Z",
      "mergedAt": "2022-03-07T19:08:14Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "781d63e864f06baeebb271d1ab5d685d671ad75e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M41PUK3",
          "commit": {
            "abbreviatedOid": "05f015f"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T02:26:00Z",
          "updatedAt": "2022-02-25T02:26:00Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "in #194 I have used `~~~~ cddl` to open the block instead of this line. \r\nIt seems to generate the same HTML, it's a bit less verbose and it also is easier to parse with some simple awk so I have found it to be quite handy of a syntax compared to what you are using here.\r\n\r\nIt would be nice to keep things consistent. ",
              "createdAt": "2022-02-25T02:26:00Z",
              "updatedAt": "2022-02-25T02:26:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M41P_fe",
          "commit": {
            "abbreviatedOid": "05f015f"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T08:19:38Z",
          "updatedAt": "2022-02-25T08:19:38Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "I agree your approach is probably the better option (and potentially makes it easier to extract CDDL from the markdown docs), so I'll change my side. Thanks!",
              "createdAt": "2022-02-25T08:19:38Z",
              "updatedAt": "2022-02-25T08:19:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 194,
      "id": "PR_kwDOCrLn6M4zMoiq",
      "title": "Move to CDDL - HTTP3, QPACK",
      "url": "https://github.com/quicwg/qlog/pull/194",
      "state": "MERGED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-21T00:34:43Z",
      "updatedAt": "2022-03-07T19:11:12Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "9b28c154492e6dac2491dfded48d2def56ed3179",
      "headRepository": "quicwg/qlog",
      "headRefName": "cddl_http3",
      "headRefOid": "d79bf4b82368104f3c2cca23671d3622ab095f1d",
      "closedAt": "2022-03-07T19:11:12Z",
      "mergedAt": "2022-03-07T19:11:11Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "d899e04d031e14b60b98e4bf3f62d8745944d4fb"
      },
      "comments": [
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "I have checked the CDDL syntax with this command \r\n```\r\ncat draft-ietf-quic-qlog-h3-events.md | awk 'BEGIN{flag=0} /~~~ cddl-definition/{flag=1; printf \"\\n\"; next} /~~~/{flag=0; next} flag' | cddl - generate | jq .\r\n``` \r\n\r\nmost definitions are unused though at this time \r\ncommand output\r\n```\r\n*** Unused rule HTTP3ParametersRestore\r\n*** Unused rule HTTP3StreamType\r\n*** Unused rule HTTP3StreamTypeSet\r\n*** Unused rule HTTP3FrameCreated\r\n*** Unused rule HTTP3FrameParsed\r\n*** Unused rule HTTP3PushResolved\r\n*** Unused rule QPACKStateUpdate\r\n*** Unused rule QPACKStreamStateUpdate\r\n*** Unused rule QPACKStreamState\r\n*** Unused rule QPACKDynamicTableUpdate\r\n*** Unused rule QPACKDynamicTableUpdateType\r\n*** Unused rule QPACKDynamicTableEntry\r\n*** Unused rule QPACKHeadersEncoded\r\n*** Unused rule QPACKHeadersDecoded\r\n*** Unused rule QPACKInstructionCreated\r\n*** Unused rule QPACKInstructionParsed\r\n*** Unused rule HTTP3Frame\r\n*** Unused rule HTTP3DataFrame\r\n*** Unused rule HTTP3HeadersFrame\r\n*** Unused rule HTTPHeader\r\n*** Unused rule HTTP3CancelPushFrame\r\n*** Unused rule HTTP3SettingsFrame\r\n*** Unused rule HTTP3Settings\r\n*** Unused rule HTTP3PushPromiseFrame\r\n*** Unused rule HTTP3GoawayFrame\r\n*** Unused rule HTTP3MaxPushIdFrame\r\n*** Unused rule HTTP3ReservedFrame\r\n*** Unused rule HTTP3ApplicationError\r\n*** Unused rule QPACKInstruction\r\n*** Unused rule SetDynamicTableCapacityInstruction\r\n*** Unused rule InsertWithNameReferenceInstruction\r\n*** Unused rule InsertWithoutNameReferenceInstruction\r\n*** Unused rule DuplicateInstruction\r\n*** Unused rule SectionAcknowledgementInstruction\r\n*** Unused rule StreamCancellationInstruction\r\n*** Unused rule InsertCountIncrementInstruction\r\n*** Unused rule QPACKHeaderBlockRepresentation\r\n*** Unused rule IndexedHeaderField\r\n*** Unused rule LiteralHeaderFieldWithName\r\n*** Unused rule LiteralHeaderFieldWithoutName\r\n*** Unused rule QPACKHeaderBlockPrefix\r\n*** Unused rule QPACKTableType\r\n{\r\n  \"bather\": 1044930698034052400,\r\n  \"upaithric\": 15980487929328420000,\r\n  \"uxorially\": 14932785096873822000,\r\n  \"verminer\": 3648320349101929000\r\n}\r\n```\r\n",
          "createdAt": "2022-02-21T00:37:27Z",
          "updatedAt": "2022-02-21T00:37:27Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey @lnicco,\r\n\r\n Thanks for the work and the cool one-liner to extract CDDL from the draft.\r\n\r\nSome initial feedback:\r\n1. I've found that the CDDL tool doesn't really properly validate the \"unused rules\" so you need to make sure they are referenced somewhere. For the main schema I've forced this with kind of an ugly hack by adding the rules manually to a debugging definition ([see here](https://github.com/quiclog/qlog/blob/master/CDDL/schema/qlog-0.4.cddl#L175)). It's probably best to have that here as well (can even be in the draft for now imo).\r\n2. using the `~~~ cddl-definition` ends up with slightly different generated HTML than the main schema where I use the `{: .language-cddl}`. Your version generates `class=\"lang-cddl-definition sourcecode\"` while mine does `class=\"lang-cddl sourcecode\"`. I don't really care which method we use, as long as it creates consistent output. \r\n3. We're not totally consistent about how we use string \"enums\". E.g., you've added a separate `QPACKDynamicTableUpdateType`, but HTTP3PushResolved has an inline `decision: \"claimed\" / \"abandoned\"`. I'd prefer having separate types for these things (have done this in the main schema as well).\r\n4. You've prefixed the HTTP/3 type names with `HTTP3` instead of `HTTP`. My idea was that tools can eventually generate the qlog event name from the type names (i.e., `TransportPacketSent` can be transformed to `transport:packet_sent`). In this case, the category name is `http` and not `http3`, so your events should be called `HTTPMyEventName` not `HTTP3MyEventName`. At least for now... maybe we should discuss renaming the category to `http3` instead... (now I assumed it would be implied by the `protocol_type` field) cc @LPardue and see #146.\r\n5. I think now in CDDL you can indeed have a single definition for FrameParsed and FrameCreated and have both alias to that.   \r\n6. Please also run the `make` command (at least for the final PR commit). This didn't have glaring errors, but a few trailing whitespaces (fixed with `make fix-lint`). ",
          "createdAt": "2022-02-21T08:12:02Z",
          "updatedAt": "2022-02-21T08:12:02Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @rmarx! Very valuable feedback and advice. \r\nI'll try to fix the generated HTML and use `{: .language-cddl}`. \r\nFor the time being I admit that I cut corners to get a quick continuous CDDL validation :)  \r\n\r\nAs far as using the HTTP3 prefix instead of HTTP I thought that it was valuable to distinguish between HTTP/3 and HTTP/2 especially around Frames (e.g. HTTP/2 Frames have flags?) but I'll revert to using HTTP and we can discuss further for future versions. \r\n\r\nI'll have a second iteration ready soon.",
          "createdAt": "2022-02-21T21:51:46Z",
          "updatedAt": "2022-02-21T22:08:30Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "@rmarx I addressed almost all the comments. I can use some guidance on how to address having shared types for Parameters and Frames. \r\n\r\nI also created a PR for the full CDDL file in case you want to link it all together \r\n \r\nhttps://github.com/quiclog/qlog/pull/7",
          "createdAt": "2022-02-25T02:23:10Z",
          "updatedAt": "2022-02-25T02:23:10Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey @lnicco,\r\n\r\nThanks for the updates and the very useful script, which I was also able to use for the QUIC events draft!\r\n\r\nI have added a new commit that primarily adds some overall consistency with the other two drafts (e.g., in terms of the code block ids, nothing major). I also noticed you were using `(` and `)` to wrap your enums, which isn't necessary (it works without as well, so I removed the brackets). \r\n\r\n4 main things though:\r\n\r\n1. You stated that HTTPHeader should become HTTPMessage, but it seems to me that should be HTTPField instead? Reading [this part of HTTP/3](https://datatracker.ietf.org/doc/html/draft-ietf-quic-http-34#section-4.1), it seems that the Message is -everything- (headers, content, trailers), while the HEADERS frame (and similarly QPACK) only deals with the headers/trailers Fields? I haven't kept up enough with the new HTTP semantics documents or the QPACK rewording, but Fields does seem to be the proper term if I look at those documents (e.g., https://datatracker.ietf.org/doc/html/draft-ietf-quic-qpack-21#section-4.5 and https://www.ietf.org/archive/id/draft-ietf-httpbis-semantics-19.html#section-5 and https://datatracker.ietf.org/doc/html/draft-ietf-quic-http-34#section-7.2.2). As such, I've renamed `HTTPHeader` to `HTTPField`. \r\n\r\n2. That makes it even clearer however that the QPACK event terminology is woefully out of date and we have to rename a lot of that to align with the newest QPACK draft text. I do propose we keep that for the draft after this however (-02, as the new one we're now preparing will be -01), as that would take us too much time and be too error prone to get done by Monday. \r\n\r\n3. I found a relatively clean way to have re-usable `HTTPParameters`, though it does require a new piece of CDDL syntax called the \"unwrap operator\" `~`, which is [defined here](https://www.rfc-editor.org/rfc/rfc8610.html#section-3.7). Essentially, that just takes the contents of the unwrapped type and puts them at the unwrap location, extending the target type. I do feel that will not be very clear for qlog readers, so we should explain that (better than what I tried atm...). Alternatively though, since they are just a few fields and only re-used at two locations, I wonder if it wouldn't make more sense to just keep it as it was (define them twice), to improve readability. \r\n\r\n4. Finally, while I understood what you meant by reuse for the `HTTPParameters` (see point 3 above), I wasn't sure what you meant with \"shared types for Frames\"? Could you clarify? Maybe my approach for the `HTTPParameters` works for that as well and you can adapt it? \r\n\r\nWith that, I believe this draft is (99%) ready for submission on Monday, so please review and let me know if you find any issues @lnicco @marten-seemann @LPardue. \r\n",
          "createdAt": "2022-03-04T22:41:02Z",
          "updatedAt": "2022-03-04T22:41:02Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "@rmarx thanks for the fixes and comments. \r\nYou are right that Fields is the most updated terminology to refer to headers. \r\nHowever, my comment about using HTTPMessage instead of HTTPHeaders is pointing to the fact that Headers alone are not representing a full message and that Method and Target for a request and status code for a response would be good to have. Also, Trailers should be considered. All of these are QPACK-encoded in HTTP/3 and HPACK-encoded in HTTP/2.\r\n\r\nI was thinking that we could even use the Known-length binary HTTP Message representation?\r\nhttps://www.ietf.org/archive/id/draft-thomson-http-binary-message-00.html#name-known-length-messages",
          "createdAt": "2022-03-05T18:55:23Z",
          "updatedAt": "2022-03-05T18:55:23Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "on a second thought the binary representation is not needed at all. \r\nAnd for a request we can use the pseudo-headers to represent method/scheme/authority/path, and status pseudo-header for a response.",
          "createdAt": "2022-03-05T19:23:43Z",
          "updatedAt": "2022-03-05T19:26:28Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@lnicco I'm not entirely sure I follow what you're saying wrt representation of full HTTPMessage here.\r\n\r\nHowever, I do get the impression that that is something that goes (way) beyond simply updating to CDDL here, and so I'd propose you open a new issue describing this (with ideally a concrete example/proposal) so we don't hold up this PR on that. Would you agree? ",
          "createdAt": "2022-03-05T21:44:27Z",
          "updatedAt": "2022-03-05T21:44:27Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "absolutely, not related to the CDDL conversion. It's a separate discussion. \nSorry for the noise",
          "createdAt": "2022-03-07T00:48:15Z",
          "updatedAt": "2022-03-07T00:48:15Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 195,
      "id": "PR_kwDOCrLn6M4zn8BQ",
      "title": "cddlify QUIC",
      "url": "https://github.com/quicwg/qlog/pull/195",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This will still need a bit of work, but\r\n```\r\ncat draft-ietf-quic-qlog-quic-events.md | awk 'BEGIN{flag=0} /~~~ cddl/{flag=1; printf \"\\n\"; next} /~~~/{flag=0; next} flag' | cddl - generate\r\n```\r\nsucceeds (as long as I insert the definitions for `uint64` and for `hexstring` from the main document). I'm not 100% sure if that means that my definitions are ok, as CDDL just tells me that almost all of the rules are unused.\r\n\r\nThere are a few TODOs left (search the doc for TODO), which we probably want to resolve before merging this PR. @rmarx, your opinion on those would be highly appreciated.",
      "createdAt": "2022-02-27T16:13:31Z",
      "updatedAt": "2022-03-07T19:10:03Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "9b28c154492e6dac2491dfded48d2def56ed3179",
      "headRepository": "quicwg/qlog",
      "headRefName": "cddl-quic",
      "headRefOid": "d410c14854a866b365faaa73f7d46583f01d5531",
      "closedAt": "2022-03-07T19:10:03Z",
      "mergedAt": "2022-03-07T19:10:03Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "dccb32eb0059128c592bb031363dcc72d48cc94f"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hello @marten-seemann,\r\n\r\nThanks for this. As you surmised however, there were indeed still quite a few problems with the first attempt that I tried to solve with my new commit. \r\n\r\nPrimarily, you were indeed not properly checking your CDDL definitions. The CDDL tool doesn't properly validate \"unused\" rules (only does high-level syntax checking, but no CDDL semantics) which are like... almost all of them :( @lnicco had [the same problem in his PR](https://github.com/quicwg/qlog/pull/194#issuecomment-1046581128) and he eventually solved it by generating stubs for the unused rules with [a custom script](https://gist.github.com/lnicco/3418e0d7cab2363e3600ff7c6b9988a1). I've gone and changed that script minimally to work for the quic draft as well. You can find my version here: https://gist.github.com/rmarx/85b7b86130f8a8dcbe58f3c0d05620ff.  \r\n\r\nDoing that highlighted a few omissions (e.g., no definitions for ConnectionID/Owner/QuicVersion/uint16/...) which I added (or will add in the main schema).\r\n\r\nIt also showed you were not using the correct syntax to create the trigger lists (not using the / concatenation operator). For some reason this is valid overall CDDL syntax, but it generates bogus JSON results and doesn't work well in many situations. I've updated all those as well.\r\n\r\nI was also able to resolve your 3 TODO's in (I think) a satisfactory way. Please validate my proposed solution for those.\r\n\r\nFinally, to prevent global CDDL name collisions, we've been adding the category name in front of each event name (so TransportParametersSet instead of just ParametersSet). I've done that for all the events here as well. Similarly, we should add an ID to each CDDL block (e.g., `{: #transport-datagramsreceived-def title=\"TransportDatagramsReceived definition\"}`) to aid in later automated extraction/code generation. I've added those as well. \r\n\r\nThe latest version generates properly with the CDDL tool (using the gist script above) and also passes the id-nits check builtin to the draft make command. \r\n\r\nTo me, this is ready to submit as a new draft by Monday. Please review and let me know if you detect any more issues @marten-seemann @lnicco @LPardue \r\n\r\n",
          "createdAt": "2022-03-04T21:41:08Z",
          "updatedAt": "2022-03-04T21:41:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M41xXhm",
          "commit": {
            "abbreviatedOid": "d410c14"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T19:08:47Z",
          "updatedAt": "2022-03-07T19:08:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 203,
      "id": "PR_kwDOCrLn6M435et5",
      "title": "Fix #202: Add PRIORITY_UPDATE support",
      "url": "https://github.com/quicwg/qlog/pull/203",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Adds support for HTTP/3 PRIORITY_UPDATE frame.\r\n\r\nCloses #202 ",
      "createdAt": "2022-05-16T18:06:56Z",
      "updatedAt": "2022-07-25T16:05:36Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "3909bbb9cd3b958b23528f40c9f191851ec26b6d",
      "headRepository": "quicwg/qlog",
      "headRefName": "lucas/priority-update-frame",
      "headRefOid": "66e1e3ad9c4a1607bd1a373b9b408f82937b0070",
      "closedAt": "2022-07-25T16:05:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "After further thought, keeping the qlog H3 spec focussed on core frames seems better. Closing this.",
          "createdAt": "2022-07-25T16:05:35Z",
          "updatedAt": "2022-07-25T16:05:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M4-EWN9",
          "commit": {
            "abbreviatedOid": "66e1e3a"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Good catch! \r\nLooks good to me. ",
          "createdAt": "2022-07-18T06:30:50Z",
          "updatedAt": "2022-07-18T06:30:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 206,
      "id": "PR_kwDOCrLn6M46jiC0",
      "title": "rename the key retiring to key discarding",
      "url": "https://github.com/quicwg/qlog/pull/206",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #185.",
      "createdAt": "2022-06-29T10:19:02Z",
      "updatedAt": "2022-09-09T13:39:00Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "3909bbb9cd3b958b23528f40c9f191851ec26b6d",
      "headRepository": "quicwg/qlog",
      "headRefName": "key-discard",
      "headRefOid": "84b69dd25fce9c496f436f808fd892e2e21fbe61",
      "closedAt": "2022-09-09T13:39:00Z",
      "mergedAt": "2022-09-09T13:39:00Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "6521609d885b3ec8e2cc1dfdfb25d7ea09f0686c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M4-EWeM",
          "commit": {
            "abbreviatedOid": "84b69dd"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-18T06:32:21Z",
          "updatedAt": "2022-07-18T06:32:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 207,
      "id": "PR_kwDOCrLn6M46jjBQ",
      "title": "fix regex for TLS alert codes",
      "url": "https://github.com/quicwg/qlog/pull/207",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #200.\r\n\r\nTLS alerts are from 0x100 - 0x1ff, not 0x100 - 0x199.",
      "createdAt": "2022-06-29T10:23:16Z",
      "updatedAt": "2022-09-09T13:38:45Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "3909bbb9cd3b958b23528f40c9f191851ec26b6d",
      "headRepository": "quicwg/qlog",
      "headRefName": "fix-tls-alert-range",
      "headRefOid": "42994c95e451e6820198144f885d971a8f55c9fc",
      "closedAt": "2022-09-09T13:38:45Z",
      "mergedAt": "2022-09-09T13:38:45Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "798f48baa67cb96e7de6b4aadd18e909abfde27b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M4-EV1W",
          "commit": {
            "abbreviatedOid": "42994c9"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "this looks good, \r\nnot sure if we want to also match uppercase A-F in which case you could use `[0-9a-fA-F]` but if not, this commit looks good",
          "createdAt": "2022-07-18T06:28:35Z",
          "updatedAt": "2022-07-18T06:28:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 208,
      "id": "PR_kwDOCrLn6M46jmzU",
      "title": "add an environment field to the trace",
      "url": "https://github.com/quicwg/qlog/pull/208",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #136.",
      "createdAt": "2022-06-29T10:39:41Z",
      "updatedAt": "2023-03-01T19:38:54Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "3909bbb9cd3b958b23528f40c9f191851ec26b6d",
      "headRepository": "quicwg/qlog",
      "headRefName": "trace-environment",
      "headRefOid": "64cea727290997a78cbbe9b6a739e7d7d9f0516b",
      "closedAt": "2023-03-01T19:38:54Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I suggest a hybrid - put the environment field in the Configuration object.",
          "createdAt": "2022-09-08T01:14:56Z",
          "updatedAt": "2022-09-08T01:14:56Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Although, https://github.com/quicwg/qlog/issues/187 suggests removing the configuration field. So we have a conflict of idealogies going on.,",
          "createdAt": "2022-09-08T01:41:41Z",
          "updatedAt": "2022-09-08T01:41:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M4-EcA3",
          "commit": {
            "abbreviatedOid": "64cea72"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "As @rmarx recommended on #136: could the `configuration` field above serve the same purpose? \r\n\r\nFrom the current text:\r\n```\r\nThe configuration field can be viewed as a generic metadata field that tools can\r\nfill with their own fields, based on per-tool logic. \r\n```\r\n",
          "createdAt": "2022-07-18T07:01:39Z",
          "updatedAt": "2022-07-18T07:01:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5CNW_s",
          "commit": {
            "abbreviatedOid": "64cea72"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "See comment on #136 ",
          "createdAt": "2022-09-16T14:41:04Z",
          "updatedAt": "2022-09-16T14:41:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 209,
      "id": "PR_kwDOCrLn6M46jyRV",
      "title": "introduce a type for stateless reset tokens",
      "url": "https://github.com/quicwg/qlog/pull/209",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #122.",
      "createdAt": "2022-06-29T11:25:00Z",
      "updatedAt": "2022-07-27T20:27:29Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "3909bbb9cd3b958b23528f40c9f191851ec26b6d",
      "headRepository": "quicwg/qlog",
      "headRefName": "stateless-reset-token-hexstring",
      "headRefOid": "4b641e5d13c40a26937cd7a83fccbcc0915d7abc",
      "closedAt": "2022-07-27T20:27:29Z",
      "mergedAt": "2022-07-27T20:27:29Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "c2a302d9bf9b97c36e264ff1db42c14aa6e6705e"
      },
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! Fixed.",
          "createdAt": "2022-07-27T20:11:25Z",
          "updatedAt": "2022-07-27T20:11:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M4-EeVP",
          "commit": {
            "abbreviatedOid": "a2cce2d"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "if not using the `Token` type for stateless reset anymore you may want to remove `\"stateless_reset\" as the Token type here https://github.com/quicwg/qlog/blame/main/draft-ietf-quic-qlog-quic-events.md#L1522",
          "createdAt": "2022-07-18T07:12:15Z",
          "updatedAt": "2022-07-18T16:20:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M4-xlA8",
          "commit": {
            "abbreviatedOid": "4b641e5"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-27T20:25:21Z",
          "updatedAt": "2022-07-27T20:25:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 210,
      "id": "PR_kwDOCrLn6M46k7Pj",
      "title": "add fields and events for DPLPMTUD",
      "url": "https://github.com/quicwg/qlog/pull/210",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #135.",
      "createdAt": "2022-06-29T15:32:44Z",
      "updatedAt": "2022-09-09T13:59:41Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "3909bbb9cd3b958b23528f40c9f191851ec26b6d",
      "headRepository": "quicwg/qlog",
      "headRefName": "mtu",
      "headRefOid": "063e37e8104f2b3ecdf53c3b26d2ae4c125b4e22",
      "closedAt": "2022-09-09T13:59:41Z",
      "mergedAt": "2022-09-09T13:59:41Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "b48b8c42380f1af2b1ca3f5444be9abac5f12618"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5BtLfO",
          "commit": {
            "abbreviatedOid": "063e37e"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-09T13:56:19Z",
          "updatedAt": "2022-09-09T13:56:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 211,
      "id": "PR_kwDOCrLn6M47inbz",
      "title": "Add optional src and dst address for `TransportPacket*` events",
      "url": "https://github.com/quicwg/qlog/pull/211",
      "state": "CLOSED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add optional src and dst address for TransportPacketSent, TransportPacketReceived, TransportPacketDropped, TransportPacketBuffered\r\n\r\nFixes #57\r\n",
      "createdAt": "2022-07-18T05:49:15Z",
      "updatedAt": "2024-06-27T18:38:13Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "3909bbb9cd3b958b23528f40c9f191851ec26b6d",
      "headRepository": "quicwg/qlog",
      "headRefName": "optional_ip_address_packet_events",
      "headRefOid": "c74241ee874844f16306b844f5f963538f6dff52",
      "closedAt": "2024-06-27T18:38:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually this should be for the Datagram events and not for Packet events \r\nTransportDatagramsSent\r\nTransportDatagramsReceived\r\nTransportDatagramDropped",
          "createdAt": "2022-07-18T16:08:04Z",
          "updatedAt": "2022-07-18T16:08:04Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As mentioned in #57, I would rather see this (and some of the other events we have that list IPs/ports, like `ConnectivityConnectionStarted`) updated to a generic `PathInfo` struct (or similar).\r\n\r\nThis does depend a bit on how we approach migration events (as they probably want to re-use this too). (also depends on multipath approach, but since it looks like we're not doing that, we can skip it).\r\n\r\nIn short: this is not yet ready for review/merge atm :) ",
          "createdAt": "2022-09-16T13:44:04Z",
          "updatedAt": "2022-09-16T13:44:23Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Overtaken by #336?",
          "createdAt": "2023-11-17T21:22:00Z",
          "updatedAt": "2023-11-17T21:22:00Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was indeed solved (or at least changed in a different way) by #336, so closing without merging. ",
          "createdAt": "2024-06-27T18:38:13Z",
          "updatedAt": "2024-06-27T18:38:13Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 213,
      "id": "PR_kwDOCrLn6M4-kQ3V",
      "title": "give some advice how to associate VN and Retry with connections",
      "url": "https://github.com/quicwg/qlog/pull/213",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #105.",
      "createdAt": "2022-09-08T07:53:21Z",
      "updatedAt": "2023-10-18T15:12:26Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "c2a302d9bf9b97c36e264ff1db42c14aa6e6705e",
      "headRepository": "quicwg/qlog",
      "headRefName": "rewrite-events-not-belonging-to-conn",
      "headRefOid": "9164baf59144b5a522aced345f793e965252a572",
      "closedAt": "2023-10-18T15:12:26Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "@huitema could you take a look at this PR and see if it addresses your issue in #105 please.",
          "createdAt": "2022-09-09T13:37:36Z",
          "updatedAt": "2022-09-09T13:37:36Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I would claim that PR is obsolete, now that we have https://github.com/quicwg/qlog/pull/279. Unless anybody objects within the next 24h, I'm going to close this PR and the associated issue (#105).",
          "createdAt": "2023-10-18T11:27:33Z",
          "updatedAt": "2023-10-18T11:27:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5Bp37G",
          "commit": {
            "abbreviatedOid": "43dcc5d"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-08T22:33:10Z",
          "updatedAt": "2022-09-08T22:33:10Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I don't quite  like the way the text read says \"MAY take extra effort\". Mainly because this text is also there to be read by consumers who want to know what events to expect but don't care about effort. \r\n\r\nA suggested rewording to avoid. Other options would work just too.\r\n\r\n```suggestion\r\nServers MAY include such events in the connection trace but need to ensure those\r\nevents are correctly associated with the correct connection, which can take\r\nextra effort or resource. For example, version negotiation events can be matched\r\nto a connection by identifying a connection attempt by its four-tuple;\r\nsimilarly, retry events be matched by their ODCID.\r\n```",
              "createdAt": "2022-09-08T22:33:10Z",
              "updatedAt": "2022-09-08T22:33:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5Brgqc",
          "commit": {
            "abbreviatedOid": "43dcc5d"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-09T08:40:50Z",
          "updatedAt": "2022-09-09T08:40:50Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Suggestion sounds good. Thank you!",
              "createdAt": "2022-09-09T08:40:50Z",
              "updatedAt": "2022-09-09T08:40:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5BtD9C",
          "commit": {
            "abbreviatedOid": "8936ca7"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-09T13:36:26Z",
          "updatedAt": "2022-09-09T13:36:27Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "think this was my fault, sorry\r\n\r\n```suggestion\r\nsimilarly, retry events can be matched by their ODCID.\r\n```",
              "createdAt": "2022-09-09T13:36:26Z",
              "updatedAt": "2022-09-09T13:36:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5BtEy7",
          "commit": {
            "abbreviatedOid": "d29f105"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM but I'd like to hear from Christian before merging",
          "createdAt": "2022-09-09T13:38:22Z",
          "updatedAt": "2022-09-09T13:38:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5BtVN9",
          "commit": {
            "abbreviatedOid": "d29f105"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-09T14:21:10Z",
          "updatedAt": "2022-09-09T14:21:16Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "In a server farm, there is no guarantee that VN and later connection are handled by the same server -- in contrast with the ODCID mechanism that can be used to achieve that. That means it could be hard to associate VN and connection at logging time. And then, the is also no guarantee that either Retry or VN is followed by an actual connection. Retry may be caused by a DDOS attack. VN can be caused by something like [quicping](https://github.com/ooni/probe/issues/1994). In fact, I could see a need for an easy way to track orphans, and see how the world is using or abusing the server. Something like a global log, with events like VN, Retry, Connection arrival, Connection final.",
              "createdAt": "2022-09-09T14:21:10Z",
              "updatedAt": "2022-09-09T14:21:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5B0Usr",
          "commit": {
            "abbreviatedOid": "d29f105"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-12T14:21:50Z",
          "updatedAt": "2022-09-12T14:21:50Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "This makes sense. I think it is already covered by the preceeding paragraph though? Maybe what we need to say is that events can be put in multiple logs - the global one, and the conenction-specific one if the match succeeds.",
              "createdAt": "2022-09-12T14:21:50Z",
              "updatedAt": "2022-09-12T14:21:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5ka8yi",
          "commit": {
            "abbreviatedOid": "d29f105"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T11:15:22Z",
          "updatedAt": "2023-10-18T11:15:22Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I'm going to merge this PR, so we can make progress here. If you think that additional clarification is needed, a follow-up PR would be appreciated.",
              "createdAt": "2023-10-18T11:15:22Z",
              "updatedAt": "2023-10-18T11:15:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5ka9P8",
          "commit": {
            "abbreviatedOid": "d29f105"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T11:16:28Z",
          "updatedAt": "2023-10-18T11:16:32Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nextra effort or resources. For example, version negotiation events can be matched\r\n```",
              "createdAt": "2023-10-18T11:16:28Z",
              "updatedAt": "2023-10-18T11:16:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 214,
      "id": "PR_kwDOCrLn6M4-o88V",
      "title": "Fix JSON serialization examples.",
      "url": "https://github.com/quicwg/qlog/pull/214",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #165 and #127\n",
      "createdAt": "2022-09-08T23:03:54Z",
      "updatedAt": "2022-09-09T13:35:32Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "c2a302d9bf9b97c36e264ff1db42c14aa6e6705e",
      "headRepository": "quicwg/qlog",
      "headRefName": "fixup-json-serialization",
      "headRefOid": "ed2b1395ec86c5d5683f37d48ca10f98108c0712",
      "closedAt": "2022-09-09T13:35:29Z",
      "mergedAt": "2022-09-09T13:35:28Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "14a25e113f27fd8ac0f382c8ac430c679cd8bb09"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5BqNIX",
          "commit": {
            "abbreviatedOid": "ed2b139"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-09T01:15:09Z",
          "updatedAt": "2022-09-09T01:15:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5BrPtf",
          "commit": {
            "abbreviatedOid": "ed2b139"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-09T07:48:12Z",
          "updatedAt": "2022-09-09T07:48:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 215,
      "id": "PR_kwDOCrLn6M4-o_ES",
      "title": "Add some RFC editor marks, use notation macro",
      "url": "https://github.com/quicwg/qlog/pull/215",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Some simple QoL editorial improvements that'll be required later on\n",
      "createdAt": "2022-09-08T23:21:21Z",
      "updatedAt": "2022-09-09T13:35:02Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "c2a302d9bf9b97c36e264ff1db42c14aa6e6705e",
      "headRepository": "quicwg/qlog",
      "headRefName": "add-rfc-note-use-boilerplate-macro",
      "headRefOid": "095180b2cac54e5aa9d4674b98530aa4433685cf",
      "closedAt": "2022-09-09T13:34:59Z",
      "mergedAt": "2022-09-09T13:34:59Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "f299b7c722e5582e079e016b8a55391e8d76b077"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5BqCN0",
          "commit": {
            "abbreviatedOid": "095180b"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me! thanks",
          "createdAt": "2022-09-08T23:49:44Z",
          "updatedAt": "2022-09-08T23:49:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5Brg6o",
          "commit": {
            "abbreviatedOid": "095180b"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-09T08:41:40Z",
          "updatedAt": "2022-09-09T08:41:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 217,
      "id": "PR_kwDOCrLn6M4-pCtg",
      "title": "Improve referencing",
      "url": "https://github.com/quicwg/qlog/pull/217",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "First, these documents can now refer to the published QUIC RFCs.\r\n\r\nWhile doing that, let's just replace all [REF] with {{REF}}, which\r\nworks better for our tooling.\r\n\r\nLastly, lets brush up the cross references between documents a bit.\r\n\r\nCloses #216 \r\n",
      "createdAt": "2022-09-08T23:52:03Z",
      "updatedAt": "2022-09-09T13:34:25Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "7eb1db07e8cd3a2d17922350dc7a325921787962",
      "headRepository": "quicwg/qlog",
      "headRefName": "sort-out-refs",
      "headRefOid": "49fe703dd577cce3b9deed4ad36b0bbeb856089d",
      "closedAt": "2022-09-09T13:34:21Z",
      "mergedAt": "2022-09-09T13:34:21Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "57cc9a673a7c258ccd0f7548c7c95b555ffed046"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I checked this locally and everything was good. It's easy enough to fix up later if I did break something. ",
          "createdAt": "2022-09-09T13:34:15Z",
          "updatedAt": "2022-09-09T13:34:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5BrZyy",
          "commit": {
            "abbreviatedOid": "0c2f28e"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm, assuming that the build tool correctly sets the links to the RFCs",
          "createdAt": "2022-09-09T08:21:23Z",
          "updatedAt": "2022-09-09T08:21:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 219,
      "id": "PR_kwDOCrLn6M4-pGef",
      "title": "spellcheck",
      "url": "https://github.com/quicwg/qlog/pull/219",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-09T00:21:42Z",
      "updatedAt": "2022-09-09T13:27:54Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "c2a302d9bf9b97c36e264ff1db42c14aa6e6705e",
      "headRepository": "quicwg/qlog",
      "headRefName": "spellcheck",
      "headRefOid": "7c3ccfa7dad27a73f03decf519001fdfae187dab",
      "closedAt": "2022-09-09T13:27:49Z",
      "mergedAt": "2022-09-09T13:27:49Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "7eb1db07e8cd3a2d17922350dc7a325921787962"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5BqKEF",
          "commit": {
            "abbreviatedOid": "4492952"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "found one thing to fix. approving to unblock you though. \r\nFeel free to merge after fixing the typo",
          "createdAt": "2022-09-09T00:56:59Z",
          "updatedAt": "2022-09-09T00:59:35Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "subtracting",
              "createdAt": "2022-09-09T00:56:59Z",
              "updatedAt": "2022-09-09T00:59:35Z"
            },
            {
              "originalPosition": 5,
              "body": "this kinda looks fine as it is? but I'll leave it to you, I don't feel strongly",
              "createdAt": "2022-09-09T00:58:02Z",
              "updatedAt": "2022-09-09T00:59:35Z"
            },
            {
              "originalPosition": 49,
              "body": "great catch!",
              "createdAt": "2022-09-09T00:58:31Z",
              "updatedAt": "2022-09-09T00:59:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5BqrnX",
          "commit": {
            "abbreviatedOid": "4492952"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-09T05:10:08Z",
          "updatedAt": "2022-09-09T05:10:08Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "oops",
              "createdAt": "2022-09-09T05:10:08Z",
              "updatedAt": "2022-09-09T05:10:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5BrDfE",
          "commit": {
            "abbreviatedOid": "4492952"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm, modulo @lnicco's comments",
          "createdAt": "2022-09-09T07:09:26Z",
          "updatedAt": "2022-09-09T07:09:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5Bs-3M",
          "commit": {
            "abbreviatedOid": "4492952"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-09T13:22:50Z",
          "updatedAt": "2022-09-09T13:22:51Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This was my opinionated spellchecker, I'll revert.",
              "createdAt": "2022-09-09T13:22:50Z",
              "updatedAt": "2022-09-09T13:22:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 222,
      "id": "PR_kwDOCrLn6M4-rmP-",
      "title": "Rename HTTPStreamType::data to HTTPStreamType::request",
      "url": "https://github.com/quicwg/qlog/pull/222",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #204\n",
      "createdAt": "2022-09-09T13:59:34Z",
      "updatedAt": "2022-09-28T14:42:58Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6521609d885b3ec8e2cc1dfdfb25d7ea09f0686c",
      "headRepository": "quicwg/qlog",
      "headRefName": "h3-data-stream-to-request",
      "headRefOid": "1a15660b54c4f8390edc86c82cbb23e5e4920b05",
      "closedAt": "2022-09-28T14:42:55Z",
      "mergedAt": "2022-09-28T14:42:55Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "f6de0d6bed6d18790ee4d85a066115c5c7f6fb76"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5CNRFp",
          "commit": {
            "abbreviatedOid": "1a15660"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This was probably indeed a leftover from earlier days. Just checked RFC9114 and the enum seems to equal what's in there, so LGTM. \r\n\r\nNot merging yet because @lnicco is owner of the H3 doc. ",
          "createdAt": "2022-09-16T14:24:53Z",
          "updatedAt": "2022-09-16T14:25:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 223,
      "id": "PR_kwDOCrLn6M4-rmq5",
      "title": "Tweak .gitignore",
      "url": "https://github.com/quicwg/qlog/pull/223",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-09T14:01:05Z",
      "updatedAt": "2022-09-09T17:03:03Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "b48b8c42380f1af2b1ca3f5444be9abac5f12618",
      "headRepository": "quicwg/qlog",
      "headRefName": "tweak-gitignore",
      "headRefOid": "2b2abaad1f15d8443f4b2a84ef151276b59b1215",
      "closedAt": "2022-09-09T17:03:03Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5BtOg-",
          "commit": {
            "abbreviatedOid": "2b2abaa"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-09T14:03:55Z",
          "updatedAt": "2022-09-09T14:03:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This probably should go into your global .gitignore file ;)",
              "createdAt": "2022-09-09T14:03:55Z",
              "updatedAt": "2022-09-09T14:03:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5BtQit",
          "commit": {
            "abbreviatedOid": "2b2abaa"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-09T14:08:35Z",
          "updatedAt": "2022-09-09T14:08:36Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": " lol fair",
              "createdAt": "2022-09-09T14:08:35Z",
              "updatedAt": "2022-09-09T14:08:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 224,
      "id": "PR_kwDOCrLn6M4-rn9l",
      "title": "Define HTTPUnknownFrame type for H3",
      "url": "https://github.com/quicwg/qlog/pull/224",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Avoid confusing use of QUIC's UnknownFrame type.\n\nFixes #201\n",
      "createdAt": "2022-09-09T14:04:58Z",
      "updatedAt": "2022-10-05T14:31:50Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "b48b8c42380f1af2b1ca3f5444be9abac5f12618",
      "headRepository": "quicwg/qlog",
      "headRefName": "h3-unknown-frame",
      "headRefOid": "6601995cbf8f58d04ec321fa5e2a9df153782bca",
      "closedAt": "2022-10-05T14:31:47Z",
      "mergedAt": "2022-10-05T14:31:47Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "10c6619bd2283649bca7378f8b38d23bcce3c792"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5BtPxO",
          "commit": {
            "abbreviatedOid": "6601995"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-09T14:06:30Z",
          "updatedAt": "2022-09-09T14:06:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5BuDRN",
          "commit": {
            "abbreviatedOid": "6601995"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks! ",
          "createdAt": "2022-09-09T16:25:12Z",
          "updatedAt": "2022-09-09T16:25:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5DET-q",
          "commit": {
            "abbreviatedOid": "6601995"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I was confused about this yesterday because the `raw` stuff should use `RawInfo` instead, but that seems inconsistent across other events atm as well, so I'll make a new issue for that. ",
          "createdAt": "2022-09-29T12:28:08Z",
          "updatedAt": "2022-09-29T12:28:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 225,
      "id": "PR_kwDOCrLn6M4-yZyY",
      "title": "Add CODEOWNERS",
      "url": "https://github.com/quicwg/qlog/pull/225",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Saves having to manually request reviews.\n",
      "createdAt": "2022-09-12T14:07:59Z",
      "updatedAt": "2022-09-16T14:42:53Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "b48b8c42380f1af2b1ca3f5444be9abac5f12618",
      "headRepository": "quicwg/qlog",
      "headRefName": "codeowners",
      "headRefOid": "e21ca63178955f24c72f13efe427cc502e5e4b9b",
      "closedAt": "2022-09-16T14:42:53Z",
      "mergedAt": "2022-09-16T14:42:53Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "c4e3b386a4020e5cf67fc8e19adea152a3ae056e"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "We can split this down further if we want, but here's a start to avoid needless clicks when submitting PRs",
          "createdAt": "2022-09-12T14:08:39Z",
          "updatedAt": "2022-09-12T14:08:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 226,
      "id": "PR_kwDOCrLn6M4-y0gK",
      "title": "Flatten event definition ToC, add summary table",
      "url": "https://github.com/quicwg/qlog/pull/226",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is a subjective editorial change. The intent is to improve the\nreadability of the document and expose better how we expect people\nto use the \"name\" field. By splitting out the overview of events\nfrom the definitions themselves, we achieve those intents.\n",
      "createdAt": "2022-09-12T15:25:37Z",
      "updatedAt": "2022-10-05T14:24:57Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "1cc928ac75154f545aa79240be591e1f7196715f",
      "headRepository": "quicwg/qlog",
      "headRefName": "summary-table",
      "headRefOid": "32810b9ac139df5d20ad46f872667e63659f364a",
      "closedAt": "2022-10-05T14:24:54Z",
      "mergedAt": "2022-10-05T14:24:54Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "cebeb9be194bbbf136e860ef65135df7d1e40876"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Easier to review as \r\n\r\n[HTML](https://quicwg.org/qlog/summary-table/draft-ietf-quic-qlog-quic-events.html)\r\n[diff](https://www.ietf.org/rfcdiff?url1=https://quicwg.github.io/qlog/draft-ietf-quic-qlog-quic-events.txt&url2=https://quicwg.github.io/qlog/summary-table/draft-ietf-quic-qlog-quic-events.txt)",
          "createdAt": "2022-09-12T15:31:42Z",
          "updatedAt": "2022-09-12T15:32:55Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In general looks good, but I wonder if we should be pedantic about the link names / align them with the CDDL definition names.\r\n\r\nConcretely:\r\n\r\nThe CDDL definition ID for the `transport:parameters_set` event is currently `#transport-parametersset-def` while the link to the section in this PR is `#trans-parameters-set`.\r\n\r\nFurthermore, few of the other events in the transport category have the `trans` prefix in this PR, while they are consistently prefixed with `transport-` in the CDDL block names.\r\n\r\nI of course have a preference for consistency and alignment, otherwise I wouldn't post this, but it's not necessarily a hill I'm willing to die on. \r\n\r\nFinally, this should have accompanying and similar PRs for the main and H3 documents down the line (maybe make an issue so we don't forget those?)",
          "createdAt": "2022-09-16T14:57:41Z",
          "updatedAt": "2022-09-16T14:58:20Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I have no issue with switching to consistent names. \r\n\r\nInitially I wanted to make the table multi-column and to keep its identifiers short. That's not how it turned out, so I'll push a fixup.",
          "createdAt": "2022-09-16T15:06:30Z",
          "updatedAt": "2022-09-16T15:06:30Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "> Finally, this should have accompanying and similar PRs for the main and H3 documents down the line (maybe make an issue so we don't forget those?)\r\n\r\nYes. I didn't want to invest any more effort if the editor team didn't like this approach. I'd suggest we refine this PR, get it merged, and then update the other documents using this as a template.",
          "createdAt": "2022-09-16T15:08:28Z",
          "updatedAt": "2022-09-16T15:08:28Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 227,
      "id": "PR_kwDOCrLn6M4-zDYX",
      "title": "Add unknown HTTPStreamType",
      "url": "https://github.com/quicwg/qlog/pull/227",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #205\n",
      "createdAt": "2022-09-12T16:14:54Z",
      "updatedAt": "2022-09-28T14:45:08Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "c4e3b386a4020e5cf67fc8e19adea152a3ae056e",
      "headRepository": "quicwg/qlog",
      "headRefName": "h3-unknown-stream-type",
      "headRefOid": "8b8fc3cb2cf9b1eeb1e8882ad06f1fbd8134ee24",
      "closedAt": "2022-09-28T14:45:05Z",
      "mergedAt": "2022-09-28T14:45:05Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "0a7340c403a8df2a2e94fb42322dd2db2f770100"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wonder if this needs some way to set the raw stream type instead of just logging \"unknown\"\r\n\r\nWe have precedent for this in the quic-events with:\r\n\r\n```\r\nConnectionCloseFrame = {\r\n    frame_type: \"connection_close\"\r\n\r\n    ? error_space: ErrorSpace\r\n    ? error_code: TransportError / $ApplicationError / uint32\r\n    ? raw_error_code: uint32\r\n    ? reason: text\r\n\r\n    ; For known frame types, the appropriate \"frame_type\" string\r\n    ; For unknown frame types, the hex encoded identifier value\r\n    ? trigger_frame_type: uint64 / text\r\n}\r\n```\r\n\r\nand \r\n\r\n```\r\nUnknownFrame = {\r\n    frame_type: \"unknown\"\r\n    raw_frame_type: uint64\r\n\r\n    ? raw_length: uint32\r\n    ? raw: hexstring\r\n}\r\n```\r\n\r\nSo potentially adding something like this here could help:\r\n\r\n```\r\nHTTPUnknownFrame = {\r\n    frame_type: \"unknown\"\r\n    raw_frame_type: uint64\r\n}\r\n```\r\n\r\n(assuming the raw payload is logged as part of `frameParsed`)",
          "createdAt": "2022-09-16T14:11:14Z",
          "updatedAt": "2022-09-16T14:21:06Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Looging the unknown value seems like a good idea. But there's no frame parsing going on here, it's just the first varint on the stream. So I think we'd need instead\r\n\r\n```\r\nHTTPStreamTypeSet = {\r\n    ... all the existing stuff\r\n    \r\n    ; add \r\n    raw_stream_type: uint64\r\n``\r\n\r\nWDYT?\r\n",
          "createdAt": "2022-09-16T14:32:43Z",
          "updatedAt": "2022-09-16T14:32:43Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I seem to have been conflating StreamType with FrameType here in my suggestion... yours is of course much better.\r\n\r\nIf included in StreamTypeSet though, I'd make it an optional field (as the known types don't have to set it), so\r\n\r\n```\r\nHTTPStreamTypeSet = {\r\n    ... all the existing stuff\r\n    \r\n    ; This should only be present if the value of new is \"unknown\" \r\n    ? raw_stream_type: uint64\r\n}\r\n```\r\n",
          "createdAt": "2022-09-16T14:48:19Z",
          "updatedAt": "2022-09-16T14:48:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "oops I meant it to be optional, and failed. I'll update the PR a bit later to reflect your suggestion. Cheers.",
          "createdAt": "2022-09-16T14:57:42Z",
          "updatedAt": "2022-09-16T14:57:42Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Seems a valid question. Spun off to #236",
          "createdAt": "2022-09-17T18:58:29Z",
          "updatedAt": "2022-09-17T18:58:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5CP3l4",
          "commit": {
            "abbreviatedOid": "8b8fc3c"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Sorry if that's a stupid question, but why do we have an `old` and a `new` field here? I thought you can only set it once.",
          "createdAt": "2022-09-17T17:32:11Z",
          "updatedAt": "2022-09-17T17:32:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 228,
      "id": "PR_kwDOCrLn6M4-zeTg",
      "title": "Update document editors",
      "url": "https://github.com/quicwg/qlog/pull/228",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "While we're at it, there's cross referencing of qlogs drafts. Rather\r\nthan update the editor info twice, let's just use the short-hand style.\r\n\r\n@rmarx should we update your affiliation? Feel free to push a commit to this branch with your new deets\r\n",
      "createdAt": "2022-09-12T17:38:54Z",
      "updatedAt": "2022-09-13T21:54:12Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "b48b8c42380f1af2b1ca3f5444be9abac5f12618",
      "headRepository": "quicwg/qlog",
      "headRefName": "update-editors",
      "headRefOid": "1a87a688741d3c8245ee4dd873b9a127f93af960",
      "closedAt": "2022-09-13T20:16:18Z",
      "mergedAt": "2022-09-13T20:16:18Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "f68fe3bdd5e717b6bcab42a9f96c43285d28afd5"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "merged to avoid bitrot. It's easy enough to make follow up changes.",
          "createdAt": "2022-09-13T20:16:24Z",
          "updatedAt": "2022-09-13T20:16:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5B2DUb",
          "commit": {
            "abbreviatedOid": "1a87a68"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-12T19:04:28Z",
          "updatedAt": "2022-09-12T19:04:28Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5B86Aj",
          "commit": {
            "abbreviatedOid": "1a87a68"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-13T21:43:26Z",
          "updatedAt": "2022-09-13T21:43:26Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "given that you are at it, my affiliation will also need to change from Facebook to Meta\r\n",
              "createdAt": "2022-09-13T21:43:26Z",
              "updatedAt": "2022-09-13T21:43:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5B86Nt",
          "commit": {
            "abbreviatedOid": "1a87a68"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-13T21:44:30Z",
          "updatedAt": "2022-09-13T21:44:30Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "not saying you have to do it. I can do it. But something that just came to mind when seeing this PR",
              "createdAt": "2022-09-13T21:44:30Z",
              "updatedAt": "2022-09-13T21:44:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5B88F8",
          "commit": {
            "abbreviatedOid": "1a87a68"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-13T21:54:05Z",
          "updatedAt": "2022-09-13T21:54:05Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Make a PR \ud83d\ude00",
              "createdAt": "2022-09-13T21:54:05Z",
              "updatedAt": "2022-09-13T21:54:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 231,
      "id": "PR_kwDOCrLn6M4-zrGq",
      "title": "Notational conventions aren't the place to discuss",
      "url": "https://github.com/quicwg/qlog/pull/231",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "There's too much text here that doesn't aid the reader. Delete it to be\nclear that we're using JSON as the notational convention for examples.\n\nIf this text was valuable, it should be somewhere else.\n",
      "createdAt": "2022-09-12T18:34:00Z",
      "updatedAt": "2022-10-24T14:33:03Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "bf7b97feb1ead4e1cf01c0490d1741f284feaebc",
      "headRepository": "quicwg/qlog",
      "headRefName": "simplify-serialization-notation",
      "headRefOid": "d6437ca3f2477049206cb873f24bbc6dc97ea6ad",
      "closedAt": "2022-10-24T14:33:00Z",
      "mergedAt": "2022-10-24T14:33:00Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "0628832b77cfe85f6ea10ef508a0204efd38042f"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I still feel we should have a \"forward reference\" here, indicating that we also discuss I-JSON and Streaming JSON considerations in this document, rather than making it seem we only do \"pure JSON\" due to the examples.\r\n\r\nPut differently, something like this should still be mentioned in this location imo:\r\n\r\n```\r\nThis document describes how to employ {{!JSON=RFC8259}}, its subset\r\n{{!I-JSON=RFC7493}}, and its streamable derivative\r\n{{!JSON-Text-Sequences=RFC7464}}.\r\n```\r\n",
          "createdAt": "2022-10-21T13:33:07Z",
          "updatedAt": "2022-10-21T13:33:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "But the fact it can be serialized to I-JSON has nothing to do with notational conventions used in this document, because we don't use any I-JSON.",
          "createdAt": "2022-10-21T15:28:58Z",
          "updatedAt": "2022-10-21T15:28:58Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue I just pushed a commit with a proposal to split up the original text to keep only a minimal amount in \"Notational Conventions\" but keep the core message alive in the introduction (which seemed the most logical location for now). \r\n\r\nI added the \"unless otherwise indicated\", as there are some examples of JSON-SEQ near the end of the document that obviously don't use RFC8259 notation directly. \r\n\r\nPlease review and if approved, merge :) ",
          "createdAt": "2022-10-24T12:12:39Z",
          "updatedAt": "2022-10-24T12:12:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5C_Kb5",
          "commit": {
            "abbreviatedOid": "d231c95"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-28T14:54:51Z",
          "updatedAt": "2022-09-28T14:54:52Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "We'll keep the definition of serialization example using JSON. But we need to keep the talk about serialization considerations somewhere else",
              "createdAt": "2022-09-28T14:54:51Z",
              "updatedAt": "2022-09-28T14:54:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5EufaO",
          "commit": {
            "abbreviatedOid": "d6437ca"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-24T12:14:12Z",
          "updatedAt": "2022-10-24T12:14:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5Eui8P",
          "commit": {
            "abbreviatedOid": "d6437ca"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-24T12:25:50Z",
          "updatedAt": "2022-10-24T12:25:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 232,
      "id": "PR_kwDOCrLn6M4-zvnU",
      "title": "Design goal wrt flexibiliy rephrasing",
      "url": "https://github.com/quicwg/qlog/pull/232",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It reads weird, especially the use of MUST\n",
      "createdAt": "2022-09-12T18:50:33Z",
      "updatedAt": "2022-09-16T14:04:55Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "b48b8c42380f1af2b1ca3f5444be9abac5f12618",
      "headRepository": "quicwg/qlog",
      "headRefName": "dont-eg-and-normative-language",
      "headRefOid": "da80ee4d29f238aaa2902b34720d7b226311ad0c",
      "closedAt": "2022-09-16T14:04:55Z",
      "mergedAt": "2022-09-16T14:04:55Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "37ea485015d175bf3372e23b56e804f82d4e816d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5B2BqW",
          "commit": {
            "abbreviatedOid": "da80ee4"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-12T18:58:33Z",
          "updatedAt": "2022-09-12T18:58:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 234,
      "id": "PR_kwDOCrLn6M4_GT--",
      "title": "Update document editors info",
      "url": "https://github.com/quicwg/qlog/pull/234",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update employer info and add consistency.\r\n\r\n@lnicco wasn't sure the move to Meta also updates your email address or not. If yes: please push a commit!",
      "createdAt": "2022-09-16T13:06:42Z",
      "updatedAt": "2022-10-12T14:18:32Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "eeade4790278da70be5b2006d166b1721220c669",
      "headRepository": "quicwg/qlog",
      "headRefName": "update-editors-2",
      "headRefOid": "98cbe94845a95911d25da7f08e761f0de0ff3297",
      "closedAt": "2022-09-28T14:48:06Z",
      "mergedAt": "2022-09-28T14:48:06Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "c3e2f5872655f33cbad718d40f28a36e3bb855ab"
      },
      "comments": [
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you! yes, I'll update the email address as well. ",
          "createdAt": "2022-10-12T14:18:32Z",
          "updatedAt": "2022-10-12T14:18:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5CM-wz",
          "commit": {
            "abbreviatedOid": "98cbe94"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-16T13:37:08Z",
          "updatedAt": "2022-09-16T13:37:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 235,
      "id": "PR_kwDOCrLn6M4_GZ4Q",
      "title": "Update MTU event definitions",
      "url": "https://github.com/quicwg/qlog/pull/235",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updates #210 as that had some problems:\n\n- used `boolean` instead of `bool` for CDDL type in some of the definitions (not in others)...\n- Made a separate category for the `mtu_updated` event. It's debatable imo whether it belongs in `connectivity` or `transport`, but it shouldn't be its own thing. \n\nIn general, I feel #210 was approved/merged too soon and this type of things should be checked for future PRs of a similar type. ",
      "createdAt": "2022-09-16T13:28:48Z",
      "updatedAt": "2022-10-05T14:13:57Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "eeade4790278da70be5b2006d166b1721220c669",
      "headRepository": "quicwg/qlog",
      "headRefName": "update-mtu",
      "headRefOid": "4cb63300644c3188eeb6087fe475fa5e24c41fb4",
      "closedAt": "2022-10-05T14:13:53Z",
      "mergedAt": "2022-10-05T14:13:53Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "1cc928ac75154f545aa79240be591e1f7196715f"
      },
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Changes look good to me.\r\n\r\n> In general, I feel https://github.com/quicwg/qlog/pull/210 was approved/merged too soon and this type of things should be checked for future PRs of a similar type.\r\n\r\nFirst of all, sorry for messing up the type name. I'm not sure I agree that it was merge too soon though, #210 was open for 3 months, and was approved by one of the editors. Sometimes it's better to make progress instead of not moving at all, even if some cleanup is necessary later.",
          "createdAt": "2022-09-16T13:42:42Z",
          "updatedAt": "2022-09-16T13:42:42Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@marten-seemann no problem, I mess up way worse than that :)\r\n\r\nLet me rephrase that to just \"approved\" too soon then, instead of \"merged\" too soon (which is again perfectly understandable with Lucas not used to watching for that type of issue, just wanted to indicate future approvals should). ",
          "createdAt": "2022-09-16T13:45:57Z",
          "updatedAt": "2022-09-16T13:45:57Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From the discussion in #236, it seems better to keep this consistent with other `*Updated` events.\r\n\r\nAlso noticed I forgot to prefix the event with Connectivity and add it to the CDDL list on the bottom...",
          "createdAt": "2022-09-28T13:01:08Z",
          "updatedAt": "2022-09-28T13:01:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5CNAEH",
          "commit": {
            "abbreviatedOid": "7bee570"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-16T13:40:51Z",
          "updatedAt": "2022-09-16T13:40:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5CNBoC",
          "commit": {
            "abbreviatedOid": "7bee570"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-16T13:44:41Z",
          "updatedAt": "2022-09-16T13:44:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5C-kF0",
          "commit": {
            "abbreviatedOid": "4cb6330"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-28T13:30:29Z",
          "updatedAt": "2022-09-28T13:30:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5C_N6P",
          "commit": {
            "abbreviatedOid": "4cb6330"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-28T15:02:36Z",
          "updatedAt": "2022-09-28T15:02:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5C_w21",
          "commit": {
            "abbreviatedOid": "4cb6330"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-28T16:30:15Z",
          "updatedAt": "2022-09-28T16:30:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 237,
      "id": "PR_kwDOCrLn6M4_xqAH",
      "title": "Flatten h3 and qpack event definition ToC, add summary table",
      "url": "https://github.com/quicwg/qlog/pull/237",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-28T12:51:58Z",
      "updatedAt": "2022-10-05T14:26:34Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "c4e3b386a4020e5cf67fc8e19adea152a3ae056e",
      "headRepository": "quicwg/qlog",
      "headRefName": "flatten-h3-toc-add-event-summary",
      "headRefOid": "70f42d274e1ba9148ff93af915c9876dabba49d7",
      "closedAt": "2022-10-05T14:26:30Z",
      "mergedAt": "2022-10-05T14:26:30Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "ce26357f7164fbb462bda0cd9fc4bc260eda7642"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5C_wih",
          "commit": {
            "abbreviatedOid": "9bc9d52"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-28T16:29:18Z",
          "updatedAt": "2022-09-28T16:29:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5DcY_S",
          "commit": {
            "abbreviatedOid": "9bc9d52"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-10-05T14:19:25Z",
          "updatedAt": "2022-10-05T14:22:55Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "```suggestion\r\n# HTTP/3 and QPACK event definitions\r\n```\r\n\r\nKeep consistent with QUIC document. Either change #226 to \"QUIC event summary\" or accept this suggestion here",
              "createdAt": "2022-10-05T14:19:25Z",
              "updatedAt": "2022-10-05T14:22:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 238,
      "id": "PR_kwDOCrLn6M4_xrhF",
      "title": "Remove editors from acknowledgements",
      "url": "https://github.com/quicwg/qlog/pull/238",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-28T12:56:26Z",
      "updatedAt": "2022-09-28T14:50:17Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "c4e3b386a4020e5cf67fc8e19adea152a3ae056e",
      "headRepository": "quicwg/qlog",
      "headRefName": "less-self-appreciation",
      "headRefOid": "29445324bb11d6b00e804580c6c9510c015e5a2c",
      "closedAt": "2022-09-28T14:50:14Z",
      "mergedAt": "2022-09-28T14:50:14Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "c5a659fb9da4772daf0728c561372e75629dfd3c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5C_IO1",
          "commit": {
            "abbreviatedOid": "2944532"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-28T14:50:02Z",
          "updatedAt": "2022-09-28T14:50:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5C_IWg",
          "commit": {
            "abbreviatedOid": "2944532"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-28T14:50:17Z",
          "updatedAt": "2022-09-28T14:50:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 240,
      "id": "PR_kwDOCrLn6M4_xv8M",
      "title": "Remove old and new fields from HTTPStreamTypeSet",
      "url": "https://github.com/quicwg/qlog/pull/240",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "rmarx"
      ],
      "labels": [
        "design"
      ],
      "body": "Builds on #227, which should be merged first.\r\n\r\nFixes #236\r\n",
      "createdAt": "2022-09-28T13:09:58Z",
      "updatedAt": "2022-10-05T14:30:24Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "ce26357f7164fbb462bda0cd9fc4bc260eda7642",
      "headRepository": "quicwg/qlog",
      "headRefName": "h3-stream-type-old-is-old",
      "headRefOid": "16ac1875f916adb1143cfa6de97080c34dd14879",
      "closedAt": "2022-10-05T14:30:21Z",
      "mergedAt": "2022-10-05T14:30:21Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "fb8cd63b006233711bed16ab3050986f1ad01023"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5C_I4T",
          "commit": {
            "abbreviatedOid": "094ae45"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-28T14:51:27Z",
          "updatedAt": "2022-09-28T14:51:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5DcclU",
          "commit": {
            "abbreviatedOid": "094ae45"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-05T14:27:51Z",
          "updatedAt": "2022-10-05T14:27:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 244,
      "id": "PR_kwDOCrLn6M4_2rPJ",
      "title": "Make packet_number optional",
      "url": "https://github.com/quicwg/qlog/pull/244",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #133\n\n(not sure whether to indent with spaces to vertically match the listing or to just let it wrap to the next line without prepended spaces though)",
      "createdAt": "2022-09-29T12:53:43Z",
      "updatedAt": "2022-10-05T14:40:22Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "c5a659fb9da4772daf0728c561372e75629dfd3c",
      "headRepository": "quicwg/qlog",
      "headRefName": "optional-pn",
      "headRefOid": "52732c824f569c17631f2a0af13baac9aa78ec8f",
      "closedAt": "2022-10-05T14:40:22Z",
      "mergedAt": "2022-10-05T14:40:22Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "b4e3f2634b27bdbb4566eceeeae6c79342a1efe8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5DEeIH",
          "commit": {
            "abbreviatedOid": "20ecfff"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "remove trailing space",
          "createdAt": "2022-09-29T12:55:37Z",
          "updatedAt": "2022-09-29T12:55:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5DEvqE",
          "commit": {
            "abbreviatedOid": "b294bf2"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-29T13:38:12Z",
          "updatedAt": "2022-09-29T13:38:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5DcfxT",
          "commit": {
            "abbreviatedOid": "b294bf2"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-05T14:35:32Z",
          "updatedAt": "2022-10-05T14:35:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 245,
      "id": "PR_kwDOCrLn6M5AOH36",
      "title": "move cddl explanation behind a note to remove before publication",
      "url": "https://github.com/quicwg/qlog/pull/245",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #230",
      "createdAt": "2022-10-05T14:41:54Z",
      "updatedAt": "2022-10-05T14:45:25Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "b4e3f2634b27bdbb4566eceeeae6c79342a1efe8",
      "headRepository": "quicwg/qlog",
      "headRefName": "move-cddl-restatement-into-a-tidy-up-note",
      "headRefOid": "6368ee334b4ba606e98c5ed558678e55ccecb462",
      "closedAt": "2022-10-05T14:45:22Z",
      "mergedAt": "2022-10-05T14:45:22Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "884557beb850075e683d0d0602239608d3415daf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5DcjDe",
          "commit": {
            "abbreviatedOid": "6368ee3"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-05T14:43:21Z",
          "updatedAt": "2022-10-05T14:43:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 247,
      "id": "PR_kwDOCrLn6M5A3BhZ",
      "title": "Add Importance column to quic overview table, tweak row order",
      "url": "https://github.com/quicwg/qlog/pull/247",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2022-10-15T14:26:25Z",
      "updatedAt": "2022-10-20T15:09:23Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "884557beb850075e683d0d0602239608d3415daf",
      "headRepository": "quicwg/qlog",
      "headRefName": "qlog-event-overview-importance",
      "headRefOid": "ababc5a39e58a2351d159222596e69b4c3fdc201",
      "closedAt": "2022-10-20T15:09:20Z",
      "mergedAt": "2022-10-20T15:09:20Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "225546e1dbef311c60e5984d7e41e62977949650"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5EI8Tj",
          "commit": {
            "abbreviatedOid": "ababc5a"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-15T14:36:26Z",
          "updatedAt": "2022-10-15T14:36:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5EYzU0",
          "commit": {
            "abbreviatedOid": "ababc5a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-19T11:17:13Z",
          "updatedAt": "2022-10-19T11:17:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 248,
      "id": "PR_kwDOCrLn6M5A3B4o",
      "title": "Add Importance column to h3 overview table",
      "url": "https://github.com/quicwg/qlog/pull/248",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2022-10-15T14:32:32Z",
      "updatedAt": "2022-10-20T15:07:57Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "884557beb850075e683d0d0602239608d3415daf",
      "headRepository": "quicwg/qlog",
      "headRefName": "h3-event-overview-importance",
      "headRefOid": "3bd47a55e58443168a4e7cb91035a3fe04eac703",
      "closedAt": "2022-10-20T15:07:53Z",
      "mergedAt": "2022-10-20T15:07:53Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "71d5c87cd059deedf744d741c871620f2495cfc0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5EI8S0",
          "commit": {
            "abbreviatedOid": "3bd47a5"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-15T14:35:57Z",
          "updatedAt": "2022-10-15T14:35:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5EYzrK",
          "commit": {
            "abbreviatedOid": "3bd47a5"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-19T11:18:22Z",
          "updatedAt": "2022-10-19T11:18:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 249,
      "id": "PR_kwDOCrLn6M5A3Edy",
      "title": "Extract H3 data definitions out of the appendix",
      "url": "https://github.com/quicwg/qlog/pull/249",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Part of addressing #221. I started with the h3 doc because it's smaller and simpler. This moves the category specific data definitions to be underneath the respective HTTP/3 or QPACK section of the document. \r\n\r\nThe markdown diff is hard to assess, better to look at the html and diff preview\r\n\r\n* https://quicwg.org/qlog/move-h3-data-outta-appendix/draft-ietf-quic-qlog-h3-events.html\r\n* https://www.ietf.org/rfcdiff?url1=https://quicwg.github.io/qlog/draft-ietf-quic-qlog-h3-events.txt&url2=https://quicwg.github.io/qlog/move-h3-data-outta-appendix/draft-ietf-quic-qlog-h3-events.txt\r\n",
      "createdAt": "2022-10-15T15:19:58Z",
      "updatedAt": "2022-10-20T15:06:34Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "884557beb850075e683d0d0602239608d3415daf",
      "headRepository": "quicwg/qlog",
      "headRefName": "move-h3-data-outta-appendix",
      "headRefOid": "addea42a8506ead5d99a8e952fd07758216d935a",
      "closedAt": "2022-10-20T15:06:29Z",
      "mergedAt": "2022-10-20T15:06:29Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "2f4198a95d8b39a5a153ccd9f3d52f775830653a"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Note that RFC format doesn't like more than 3 levels in a table of contents. This means that specific h3 frames, qpack instructions and block prefixes are not shown. If we think that matters, we either need to promote the data defitions one level, or flatten them into the thrid-level.",
          "createdAt": "2022-10-15T15:24:03Z",
          "updatedAt": "2022-10-15T15:24:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5EgsJz",
          "commit": {
            "abbreviatedOid": "addea42"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-20T14:52:03Z",
          "updatedAt": "2022-10-20T14:52:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 251,
      "id": "PR_kwDOCrLn6M5A3FGk",
      "title": "Remove Design Variations section",
      "url": "https://github.com/quicwg/qlog/pull/251",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Closes #250",
      "createdAt": "2022-10-15T15:32:00Z",
      "updatedAt": "2022-10-19T14:32:20Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "884557beb850075e683d0d0602239608d3415daf",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-design-variations-commentary",
      "headRefOid": "febd0fef3ce97ba85e7717210bfbfdd2a41bb91d",
      "closedAt": "2022-10-19T14:32:17Z",
      "mergedAt": "2022-10-19T14:32:17Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "ea44ab2ebe8098c58f753a1177d6b6c68784b86e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5EI-Za",
          "commit": {
            "abbreviatedOid": "febd0fe"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-15T16:08:13Z",
          "updatedAt": "2022-10-15T16:08:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5EZzwc",
          "commit": {
            "abbreviatedOid": "febd0fe"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-19T13:49:47Z",
          "updatedAt": "2022-10-19T13:49:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 252,
      "id": "PR_kwDOCrLn6M5BBp1l",
      "title": "Add privacy and security considerations section",
      "url": "https://github.com/quicwg/qlog/pull/252",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "Adding high-level discussion of privacy and security considerations operators should take into account.\r\n\r\nThis will walk a fine line between being too high-level/vague and trying to do too much in a qlog document that should be done in a more general IETF document that discusses these issues for all possible log formats, not just qlog. ",
      "createdAt": "2022-10-18T15:08:22Z",
      "updatedAt": "2022-10-24T15:17:08Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "0628832b77cfe85f6ea10ef508a0204efd38042f",
      "headRepository": "quicwg/qlog",
      "headRefName": "security-privacy",
      "headRefOid": "5d95aae1b592d685d812e8267e36bdaabc009587",
      "closedAt": "2022-10-24T15:14:20Z",
      "mergedAt": "2022-10-24T15:14:20Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "0813ca5da912cba3d0c730715e53332a41b09a6c"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This is a solid start. I think it treads the line well about what should be discussed in the scope of qlog. There might be a small discussion about whether we should mention so many QUIC things in the main schema, rather than in the qlog schema, but at the moment I'd fall on the side of leaving them here.",
          "createdAt": "2022-10-18T22:00:46Z",
          "updatedAt": "2022-10-18T22:00:46Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue I have now processed all of your comments, with 2 that probably deserve an extra look. The overall structure is more consistent now, and concrete QUIC/TLS/HTTP mentions are now clear as examples of data types, rather than specific data fields in qlog themselves. \r\n\r\nI think this is ready for broader review (and as we discussed yesterday, a first merge into the main doc if it can be approved by the editors here). \r\n\r\nThe main missing part is a proper reference to a recent differential privacy survey/discussion which I still need to research (suggestions welcome!).\r\n\r\nI will also add a `Security considerations` section to the event documents that references back to this soon. ",
          "createdAt": "2022-10-20T13:39:05Z",
          "updatedAt": "2022-10-20T13:39:05Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson Thank you for the review and extensive comments. \r\n\r\nIn discussion with @LPardue and because we really wanted to have -something- about this in the new drafts, I've merged this first version of the text, including fixes for your smaller but not larger remarks, with the intent of there being continued discussion going forward.\r\n\r\nTo that end, I will create 2 new issues, one for your high-level review about general structure, and one for the \"user consent\" remark to further track these points for future versions. \r\n\r\nThanks again!",
          "createdAt": "2022-10-24T15:17:07Z",
          "updatedAt": "2022-10-24T15:17:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5EVXDa",
          "commit": {
            "abbreviatedOid": "eda0101"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-18T20:08:45Z",
          "updatedAt": "2022-10-18T20:08:45Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "This is a good starter but it seems a little too informal and at the same too specific in citing QUIC. Also modern will soon be old :)\r\n\r\nHere's an alternative that builds on what you've put down already\r\n\r\n> Protocols such as TLS [cite] and QUIC [cite] provide secure protection, to varying degrees, for the wire image [cite  RFC 8546]. There is inevitably tension between security and observability, when logging can reveal aspects of the wire image, that would ordinarily be protected. This tension equally applies to any privacy considerations that build on security properties, especially if data can be correlated across data sources.\r\n\r\n> qlog operators and implementers should be mindful of the security and privacy risks inherent in handling qlog data. This includes but is not limited to logging, storing, or using the data. Data might be considered as non-sensitive, potentially-sensitive, or sensitive; applying the considerations in this section may produce different risks depending on the nature of the data itself, or its handling. However, in many cases the largest risk factors arise from data that can be considered as potenially-sensitive or sensitive. The following is a non-exhaustive list of such fields that can be carried in qlog data:",
              "createdAt": "2022-10-18T20:08:45Z",
              "updatedAt": "2022-10-18T20:08:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5EVXjV",
          "commit": {
            "abbreviatedOid": "eda0101"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-10-18T20:10:32Z",
          "updatedAt": "2022-10-18T21:55:12Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n  identify individual connections, endpoints, and potentially users.\r\n```",
              "createdAt": "2022-10-18T20:10:33Z",
              "updatedAt": "2022-10-18T21:55:12Z"
            },
            {
              "originalPosition": 33,
              "body": "Can this citation be more specific?",
              "createdAt": "2022-10-18T20:11:16Z",
              "updatedAt": "2022-10-18T21:55:12Z"
            },
            {
              "originalPosition": 35,
              "body": "For some reason the \"accurate\" bit is bugging me. I think I have a sense of what you're trying to say but I'm not sure it's specific enough to let me know if I have a problem or not. For instance, my qlogs only capture relative time, to high resolution; I don't think that actually has an accuracy problem for the purposes of correlation?",
              "createdAt": "2022-10-18T20:19:01Z",
              "updatedAt": "2022-10-18T21:55:12Z"
            },
            {
              "originalPosition": 35,
              "body": "Consider also inverting this sentence to \r\n\r\n> Data types that could be combined with other data sources (e.g. captures of encrypted packets) to correlate a connection or user. For example, event timestamps, event counts, or packet and frame sizes. \r\n\r\nThen you could add additional considerations about timestamps in a follow on sentence if you'd like.",
              "createdAt": "2022-10-18T20:33:54Z",
              "updatedAt": "2022-10-18T21:55:13Z"
            },
            {
              "originalPosition": 40,
              "body": "Not clear if this is the formal QUIC token, or something more general (like session tickets?). Being specific is good.",
              "createdAt": "2022-10-18T20:39:10Z",
              "updatedAt": "2022-10-18T21:55:12Z"
            },
            {
              "originalPosition": 44,
              "body": "This could be generalized a bit. Anything that's encrypted can be decrypted when an appropriate key can be logged. Think like an encrypted zip file transferred over HTTP, where a password is captured in the same (or correlatable) log as the payload.",
              "createdAt": "2022-10-18T20:41:44Z",
              "updatedAt": "2022-10-18T21:55:12Z"
            },
            {
              "originalPosition": 48,
              "body": "This second sentence feels like something we could break out from the list, since this is a list of data types not qlog considerations applied to the types.",
              "createdAt": "2022-10-18T20:45:26Z",
              "updatedAt": "2022-10-18T21:55:12Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\ndatasets might have different requirements to live operational troubleshooting). As\r\n```",
              "createdAt": "2022-10-18T20:46:40Z",
              "updatedAt": "2022-10-18T21:55:12Z"
            },
            {
              "originalPosition": 64,
              "body": "normative requirements (e.g SHOULD) are normally frowned upon. Furthermore, some people like for SHOULD's to add colour about the circumstances underwhich the requirement can or should be ignored (this isn't a unilateral rule though).\r\n\r\nA different way to paint this is to explain the consideration or motivation behind the requirement you are expressing. For example\r\n\r\n> Capturing the minimal amount of data required for a specific purpose can help to minimize the risks associated with data usage. qlog implementers that provide fine-grain control over the prescence of data fields, such as on a per-use-case or per-connection basis, improve the ability to minimize data.\r\n\r\nIf we really want SHOULDs, we can move this text out of security considerations (but where>) and xref  to that section in these considerations.",
              "createdAt": "2022-10-18T20:55:46Z",
              "updatedAt": "2022-10-18T21:55:12Z"
            },
            {
              "originalPosition": 68,
              "body": "```suggestion\r\nAny data that is determined to be necessary for a use case at hand could be \r\nlogged or captured. As per\r\n{{!RFC6973}}, operators must be aware that such data will be at risk of\r\ncompromise. As such, measures should be taken to firstly reduce the risk of\r\n```",
              "createdAt": "2022-10-18T21:37:03Z",
              "updatedAt": "2022-10-18T21:55:12Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\nparagraphs discuss high-level conciderations that can be applied to qlog data.\r\n```",
              "createdAt": "2022-10-18T21:37:38Z",
              "updatedAt": "2022-10-18T21:55:12Z"
            },
            {
              "originalPosition": 74,
              "body": "```suggestion\r\nthe length of time that data is stored, encrypting data in transit and at rest, limiting access\r\n```",
              "createdAt": "2022-10-18T21:38:34Z",
              "updatedAt": "2022-10-18T21:55:12Z"
            },
            {
              "originalPosition": 75,
              "body": "SHOULD here also",
              "createdAt": "2022-10-18T21:39:37Z",
              "updatedAt": "2022-10-18T21:55:13Z"
            },
            {
              "originalPosition": 73,
              "body": "maybe we should say \"unauthorized access or compromise\"?",
              "createdAt": "2022-10-18T21:40:43Z",
              "updatedAt": "2022-10-18T21:55:13Z"
            },
            {
              "originalPosition": 78,
              "body": "does it have to be just \"sensitive fields\"? Just saying data fields would likely hold true.",
              "createdAt": "2022-10-18T21:41:43Z",
              "updatedAt": "2022-10-18T21:55:13Z"
            },
            {
              "originalPosition": 82,
              "body": "```suggestion\r\n{{!DNS-PRIVACY=RFC8932}}. Operators should, however, be aware that many of these\r\n```",
              "createdAt": "2022-10-18T21:42:04Z",
              "updatedAt": "2022-10-18T21:55:13Z"
            },
            {
              "originalPosition": 85,
              "body": "```suggestion\r\nto protect user identity, especially if a qlog data set is large or easily correlated\r\nagainst other data sources. Differential privacy techniques might provide provide\r\n```",
              "createdAt": "2022-10-18T21:44:55Z",
              "updatedAt": "2022-10-18T21:55:13Z"
            },
            {
              "originalPosition": 87,
              "body": "\r\n```suggestion\r\nmitigations to this risk; see (TODO: add survey paper reference).\r\n```",
              "createdAt": "2022-10-18T21:47:24Z",
              "updatedAt": "2022-10-18T21:55:13Z"
            },
            {
              "originalPosition": 96,
              "body": "I find this one a little hard to align with as written. what is the trend? Will that trend be one in 10 years time?\r\n\r\nIt might be better to rephrase the start is in terms of qlog operators needing to consider something we didn't alread mention: then tention between their operational needs and end user rights or preferences (the rights is important here, such as cookie laws, GDPR, regional policies etc). We can then close out the paragraph information that might contain more information that is sensitive or confidential to the end user (where previously we talked abput sensitivity mainly through the lens of connections), and then use the packet or frame payloads as example of where that data might reside.",
              "createdAt": "2022-10-18T21:55:07Z",
              "updatedAt": "2022-10-18T21:55:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5EZ2Bo",
          "commit": {
            "abbreviatedOid": "eda0101"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T13:54:35Z",
          "updatedAt": "2022-10-19T13:54:35Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Not sure what \"this second sentence\" is here exactly. Do you mean \"HTTP Field values, HTTP response data, TLS SNI field values\" or the `RawInfo` bit? ",
              "createdAt": "2022-10-19T13:54:35Z",
              "updatedAt": "2022-10-19T13:54:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5EZ25G",
          "commit": {
            "abbreviatedOid": "eda0101"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T13:56:23Z",
          "updatedAt": "2022-10-19T13:56:24Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "As you mentioned elsewhere, I was trying to stay away from too much protocol (QUIC, TLS) specifics. This is meant to encompass the various QUIC tokens (e.g., retry, address validation) and also indeed session tickets. \r\n\r\nOne solution could be to list a few as examples like:\r\n\r\n```suggestion\r\n  Token values (e.g., QUIC address validation and retry tokens, TLS session tickets), which can contain address validation details\r\n```",
              "createdAt": "2022-10-19T13:56:24Z",
              "updatedAt": "2022-10-19T13:56:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5EZ4U_",
          "commit": {
            "abbreviatedOid": "eda0101"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T13:59:25Z",
          "updatedAt": "2022-10-19T13:59:25Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I'm currently using compromise as in RFC6973 (though there it also isn't really 100% defined), and that seems to encompass \"unauthorized access\" in compromise (the one thing it splits out is (intentional) disclosure)",
              "createdAt": "2022-10-19T13:59:25Z",
              "updatedAt": "2022-10-19T13:59:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5EgE6s",
          "commit": {
            "abbreviatedOid": "eda0101"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-20T13:33:55Z",
          "updatedAt": "2022-10-20T13:33:56Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I'm not sure I captured this 100% correctly. Probably worth a new look now. ",
              "createdAt": "2022-10-20T13:33:55Z",
              "updatedAt": "2022-10-20T13:33:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5EgFLv",
          "commit": {
            "abbreviatedOid": "eda0101"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-20T13:34:30Z",
          "updatedAt": "2022-10-20T13:34:30Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I've now removed the RawInfo bit here and placed it at the very end. Still not sure that's what you were saying here though, so please double-check.",
              "createdAt": "2022-10-20T13:34:30Z",
              "updatedAt": "2022-10-20T13:34:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5EgFkK",
          "commit": {
            "abbreviatedOid": "eda0101"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-20T13:35:19Z",
          "updatedAt": "2022-10-20T13:35:19Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I think that it should be clear enough what we're using RFC6973 here, so I didn't change this. If that turns out to be a problem for others down the line we can revisit. ",
              "createdAt": "2022-10-20T13:35:19Z",
              "updatedAt": "2022-10-20T13:35:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5EgfVj",
          "commit": {
            "abbreviatedOid": "db3b31d"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Looks good now, thanks!",
          "createdAt": "2022-10-20T14:25:30Z",
          "updatedAt": "2022-10-20T14:25:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5Er-oj",
          "commit": {
            "abbreviatedOid": "db3b31d"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "This is a lot of text.  I like the enumeration of the types of risk, but I fear that the extrapolation from there is both incomplete and a little long-winded.\r\n\r\nThe focus on anonymization is not one that I would emphasize.  I know that Christian has toyed with the concept, but that was idle speculation, not anything rigorous.\r\n\r\nIn the end, this text should be very clear that qlog files present a privacy risk to those participating in the connection.  They should therefore be treated accordingly.  Any notion that these files might be sanitized in a way that might remove that risk should be changed to focus more on defense in depth.  That is, look at access control and retention limits as primary means of protection, not anonymization.\r\n\r\nI would instead structure this roughly as follows:\r\n\r\n1. A brief introductory piece.\r\n1. An articulation of the types of privacy risk that might be presented by capture, storage, and use of qlog data.  This part is fairly lengthy and could probably be a subsection.\r\n1. A description of the operational implications and potential actions that might be taken first from a security standpoint, then for privacy remediation.  qlog files that are records of interactions with peers are data that those peers (or users) potentially have rights over (I like this point, so make it prominently, but do not refer to laws; do not refer to the GDPR especially).\r\n  a. Access controls required to enable qlog or to expand the information that is captured.\r\n  a. Access controls required to access stored qlog files.\r\n  a. Limits to retention of qlog files.\r\n  a. Finally, observe that limiting what is captured or anonymization might be possible, but that this could either be insufficient from a privacy perspective, reduce the usefulness of the data, or (highly likely) both.\r\n\r\nIt's easy to focus on the point about not being able to link qlog data with people.  But it's safer to treat that as an open research problem than invite implementations and deployments to indulge in amateur research on the topic.",
          "createdAt": "2022-10-23T21:45:51Z",
          "updatedAt": "2022-10-23T22:16:12Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "The split here between encrypted and plaintext is fairly significant.  Ciphertext can be used to correlate the log with captures and thus to the original session.  Whereas plaintext is what potentially carries sensitive information.\r\n\r\nMaybe split this one.",
              "createdAt": "2022-10-23T21:45:51Z",
              "updatedAt": "2022-10-23T22:16:13Z"
            },
            {
              "originalPosition": 89,
              "body": "```suggestion\r\naddress information) can be found in {{Appendix B of !DNS-PRIVACY=RFC8932}}.\r\n```\r\n\r\nThough I don't think that your emphasis on anonymization is appropriate.",
              "createdAt": "2022-10-23T21:47:33Z",
              "updatedAt": "2022-10-23T22:16:13Z"
            },
            {
              "originalPosition": 94,
              "body": "I remain skeptical about the potential application of DP here.\r\n\r\nMaybe someone has already done some research, but the amount of information contained in a qlog that might be used for correlation is very high and tightly coupled to the utility of that information.  See opening comments.",
              "createdAt": "2022-10-23T21:49:25Z",
              "updatedAt": "2022-10-23T22:16:13Z"
            },
            {
              "originalPosition": 98,
              "body": "Do not mention laws.  Do not mention the GDPR.",
              "createdAt": "2022-10-23T22:00:21Z",
              "updatedAt": "2022-10-23T22:16:13Z"
            },
            {
              "originalPosition": 103,
              "body": "This might be a personal bugbear, but I don't think that mention of \"user consent\" - particularly as it is applied here - is a good idea.  The idea that a typical user of a service might consent to this form of data collection is a little fanciful, especially given the nature of the risks.",
              "createdAt": "2022-10-23T22:01:55Z",
              "updatedAt": "2022-10-23T22:16:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5Evh7j",
          "commit": {
            "abbreviatedOid": "db3b31d"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-24T15:05:53Z",
          "updatedAt": "2022-10-24T15:05:53Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "I wasn't sure if you had doubts about this entire paragraph of just the \"user consent\" terminology in this one sentence. \r\n\r\nSince I personally feel it's important to at least mention user preference and that qlog collection should be tied to that (as should all data collection about a user), I interpreted it as just the terminology and changed to \"user preference\" for now. I will open a separate issue to discuss this further.",
              "createdAt": "2022-10-24T15:05:53Z",
              "updatedAt": "2022-10-24T15:05:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 253,
      "id": "PR_kwDOCrLn6M5BExKw",
      "title": "H3 CDDL: use consistent spacing",
      "url": "https://github.com/quicwg/qlog/pull/253",
      "state": "CLOSED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "in the H3 CDDL definitions we have been using extra lines to space things out, but it is a bit inconsistent. \r\nThis PR tries to make things more consistent by\r\n  * only keep empty lines between types in the same block\r\n  * split unions into multiple lines, except for when only two types are present",
      "createdAt": "2022-10-19T05:35:00Z",
      "updatedAt": "2023-05-16T17:30:12Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "884557beb850075e683d0d0602239608d3415daf",
      "headRepository": "quicwg/qlog",
      "headRefName": "h3_cddl_consistent_spacing",
      "headRefOid": "c55a625860598ad957ace1e359137969fdbc613d",
      "closedAt": "2023-05-16T17:30:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Thanks for this, a lot looks good.\r\n\r\nWhere I might disagree is something I noticed this week across all docus: my somewhat untrained eye found the lines with comments (\";\") to run on when there was no blank line preceding the first comment line.  ",
          "createdAt": "2022-10-19T07:30:34Z",
          "updatedAt": "2022-10-19T07:30:57Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in the meeting. Some TODOs:\r\n * one empty line before each comment line (but not after)\r\n * always use multiple lines for union types: even if there are just two alternatives\r\n * apply the changes to the other docs as well",
          "createdAt": "2022-10-19T14:33:03Z",
          "updatedAt": "2022-10-19T14:33:03Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "rebasing was a nightmare so I created a new (draft) PR https://github.com/quicwg/qlog/pull/298  \r\n\r\nI can force push the new commits here in case that is better. Let me know",
          "createdAt": "2023-05-14T20:02:27Z",
          "updatedAt": "2023-05-14T20:02:27Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "fixed in #298 ",
          "createdAt": "2023-05-16T17:30:11Z",
          "updatedAt": "2023-05-16T17:30:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5SzWx8",
          "commit": {
            "abbreviatedOid": "c55a625"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-18T02:58:42Z",
          "updatedAt": "2023-04-18T02:58:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 254,
      "id": "PR_kwDOCrLn6M5BEzkU",
      "title": "Fix email address",
      "url": "https://github.com/quicwg/qlog/pull/254",
      "state": "MERGED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-10-19T05:47:29Z",
      "updatedAt": "2022-10-19T14:31:45Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "884557beb850075e683d0d0602239608d3415daf",
      "headRepository": "quicwg/qlog",
      "headRefName": "fix_affiliation_luca",
      "headRefOid": "1f8c9fbc014d9302cd6337d049be92596946ba14",
      "closedAt": "2022-10-19T14:31:45Z",
      "mergedAt": "2022-10-19T14:31:45Z",
      "mergedBy": "lnicco",
      "mergeCommit": {
        "oid": "8479b76c43a34612423c5f4cdf345c1aa0c8f645"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5EXZar",
          "commit": {
            "abbreviatedOid": "1f8c9fb"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-19T07:25:03Z",
          "updatedAt": "2022-10-19T07:25:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5EXa8l",
          "commit": {
            "abbreviatedOid": "1f8c9fb"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-19T07:29:32Z",
          "updatedAt": "2022-10-19T07:29:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5EXhbC",
          "commit": {
            "abbreviatedOid": "1f8c9fb"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-19T07:48:15Z",
          "updatedAt": "2022-10-19T07:48:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 255,
      "id": "PR_kwDOCrLn6M5BGW3Z",
      "title": "Remove connection_retried event placeholder",
      "url": "https://github.com/quicwg/qlog/pull/255",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Connection retried was never properly specced. \r\n\r\nThe main reason is that a retried connection is completely separate from the original connection attempt, except for the `retry token` value, and as such is usually logged in a separate file / separate context from the original connection qlog data. \r\n\r\nCurrent qlog deployments either have other ways of correlating retried connections with the original attempts, or don't need to do this. Either way, there is no tangible need for `connection_retried` at this time. ",
      "createdAt": "2022-10-19T11:27:04Z",
      "updatedAt": "2022-10-24T11:59:58Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "8180b5741c033e615a9f341457a721b98f44d263",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-retry",
      "headRefOid": "87c544efeee3214e10148a61ee01089e4703ba76",
      "closedAt": "2022-10-24T11:51:47Z",
      "mergedAt": "2022-10-24T11:51:47Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "41bf9776aaa351f1002173f43bf3d87f1d9fd97d"
      },
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> The main reason is that a retried connection is completely separate from the original connection attempt, except for the retry token value, and as such is usually logged in a separate file / separate context from the original connection qlog data.\r\n\r\nI don't think that's correct. You also take your Connection IDs with you to the new connection. quic-go logs it to the same file, as _it is the same connection attempt_.\r\n\r\nI don't see value in `connection_retried` though.",
          "createdAt": "2022-10-20T08:54:20Z",
          "updatedAt": "2022-10-20T08:54:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5EebnL",
          "commit": {
            "abbreviatedOid": "567d000"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-20T08:54:31Z",
          "updatedAt": "2022-10-20T08:54:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5Egy_q",
          "commit": {
            "abbreviatedOid": "567d000"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-20T15:07:07Z",
          "updatedAt": "2022-10-20T15:07:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 256,
      "id": "PR_kwDOCrLn6M5BNUgu",
      "title": "Move QUIC events out of the appendix",
      "url": "https://github.com/quicwg/qlog/pull/256",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-10-20T15:41:58Z",
      "updatedAt": "2022-10-21T13:31:22Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "225546e1dbef311c60e5984d7e41e62977949650",
      "headRepository": "quicwg/qlog",
      "headRefName": "move-qlog-data-defs-outta-appendix",
      "headRefOid": "6354daa3e1ce17c5287431ea02b3b1578914b806",
      "closedAt": "2022-10-21T13:31:19Z",
      "mergedAt": "2022-10-21T13:31:19Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "8180b5741c033e615a9f341457a721b98f44d263"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5EianV",
          "commit": {
            "abbreviatedOid": "6354daa"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-20T19:47:07Z",
          "updatedAt": "2022-10-20T19:47:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5EmkPW",
          "commit": {
            "abbreviatedOid": "6354daa"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-21T13:29:22Z",
          "updatedAt": "2022-10-21T13:29:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 257,
      "id": "PR_kwDOCrLn6M5BWALI",
      "title": "Make QuicFrame and HTTPFrame into CDDL extension points",
      "url": "https://github.com/quicwg/qlog/pull/257",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rmarx"
      ],
      "labels": [],
      "body": "In doing the exercise to try and define a new DATAGRAM extension for qlog (at https://github.com/rmarx/draft-marx-quic-qlog-datagram), it became clear that we only had a CDDL extension point for the events themselves (`$ProtocolEventBody`) but NOT for the individual QUIC and HTTP/3 frames.\r\n\r\nThis is needed so we can add the CDDL definitions for new frames in other documents and have them properly matched to the CDDL expectations of \"main document\" events like `http:frame_parsed` and `transport:packet_sent`.",
      "createdAt": "2022-10-22T18:27:58Z",
      "updatedAt": "2022-10-24T11:59:42Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "8180b5741c033e615a9f341457a721b98f44d263",
      "headRepository": "quicwg/qlog",
      "headRefName": "frame-extensionpoints",
      "headRefOid": "95d7d68f4c6556d109085745033861d39138b15a",
      "closedAt": "2022-10-24T11:59:38Z",
      "mergedAt": "2022-10-24T11:59:38Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "bf7b97feb1ead4e1cf01c0490d1741f284feaebc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5EsOzq",
          "commit": {
            "abbreviatedOid": "e687b13"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-24T02:05:19Z",
          "updatedAt": "2022-10-24T02:05:20Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "I prefer the old title, its already clear the things in this document are defined in this document.",
              "createdAt": "2022-10-24T02:05:20Z",
              "updatedAt": "2022-10-24T02:05:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5EsPtk",
          "commit": {
            "abbreviatedOid": "e687b13"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM modulo some editorial nits",
          "createdAt": "2022-10-24T02:13:13Z",
          "updatedAt": "2022-10-24T02:15:19Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "The intent of the sentence isn't that clear to me. Who is wanting to automate validation, does somebody producing qlog or consuming qlog care?\r\n\r\nHow about simplifying to :\r\n\r\n```suggestion\r\nor \"plug\"). It can be extended to support additional QUIC frame types.\r\n```",
              "createdAt": "2022-10-24T02:13:13Z",
              "updatedAt": "2022-10-24T02:15:19Z"
            },
            {
              "originalPosition": 25,
              "body": "The intent of the sentence isn't that clear to me. Who is wanting to automate validation, does somebody producing qlog or consuming qlog care?\r\n\r\nHow about simplifying to :\r\n\r\n```suggestion\r\nor \"plug\"). It can be extended to support additional HTTP/3 frame types.\r\n```",
              "createdAt": "2022-10-24T02:13:42Z",
              "updatedAt": "2022-10-24T02:15:19Z"
            },
            {
              "originalPosition": 83,
              "body": "I prefer the old title, its already clear the things in this document are defined in this document.",
              "createdAt": "2022-10-24T02:14:42Z",
              "updatedAt": "2022-10-24T02:15:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 258,
      "id": "PR_kwDOCrLn6M5BYzyA",
      "title": "Take a stab at refactoring the use of `Note:`.",
      "url": "https://github.com/quicwg/qlog/pull/258",
      "state": "MERGED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is just a start. While these are editorial changes they will\ndefinitely require discussion for how it's best to change each Note:.\n",
      "createdAt": "2022-10-24T06:52:13Z",
      "updatedAt": "2023-05-16T17:48:18Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "e226e9f92fcadd0b9ff3a30bbfe3d61ea47c7bb8",
      "headRepository": "quicwg/qlog",
      "headRefName": "h3_notes",
      "headRefOid": "04e9d033aefae828dcc53704cea1776cc1aef2bc",
      "closedAt": "2023-05-16T17:48:18Z",
      "mergedAt": "2023-05-16T17:48:17Z",
      "mergedBy": "lnicco",
      "mergeCommit": {
        "oid": "9dc6d24f0f60223edccf1c2ce805b3f299d26e79"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5EvsuA",
          "commit": {
            "abbreviatedOid": "28475da"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-24T15:31:43Z",
          "updatedAt": "2023-01-18T20:07:20Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I still find this paragraph confusing even with the edits. How about cutting more text to something like,\r\n\r\n> The \"owner\" field reflects how Settings are exchanged on a connection. Sent settings have the value \"local\" and received settings have the value \"received\". A qlog can have multiple instances of this event.",
              "createdAt": "2022-10-24T15:31:44Z",
              "updatedAt": "2023-01-18T20:07:20Z"
            },
            {
              "originalPosition": 47,
              "body": "I think this is what we're trying to say?\r\n\r\n```suggestion\r\nThis event can contain any number of unspecified fields. This\r\nallows for representation of reserved settings (aka grease) or ad-hoc support for extension settings\r\nthat do not have a related qlog schema definition .\r\n```",
              "createdAt": "2022-10-24T15:40:31Z",
              "updatedAt": "2023-01-18T20:07:20Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\nSimilar to HTTPParametersSet, this event can contain any number of\r\n```",
              "createdAt": "2022-10-24T15:41:22Z",
              "updatedAt": "2023-01-18T20:07:20Z"
            },
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nunspecified fields to allow for reserved or extension settings.\r\n```",
              "createdAt": "2022-10-24T15:42:00Z",
              "updatedAt": "2023-01-18T20:07:20Z"
            },
            {
              "originalPosition": 94,
              "body": "```suggestion\r\nmight extend over multiple write operations, which would be logged using multiple data_moved events.\r\n```",
              "createdAt": "2022-10-24T15:45:04Z",
              "updatedAt": "2023-01-18T20:07:20Z"
            },
            {
              "originalPosition": 118,
              "body": "hangover fragment sentence?",
              "createdAt": "2022-10-24T15:50:05Z",
              "updatedAt": "2023-01-18T20:07:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5VJUse",
          "commit": {
            "abbreviatedOid": "04e9d03"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2023-05-16T12:51:23Z",
          "updatedAt": "2023-05-16T12:51:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 263,
      "id": "PR_kwDOCrLn6M5GRk6u",
      "title": "add ECN events",
      "url": "https://github.com/quicwg/qlog/pull/263",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #212.",
      "createdAt": "2022-12-28T02:20:34Z",
      "updatedAt": "2023-10-22T03:46:38Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "57a8c67bea1d35aa585fb7c2fadbd98faf3cfb39",
      "headRepository": "quicwg/qlog",
      "headRefName": "ecn",
      "headRefOid": "fbd35192f2162b6c8867c7a678b26db135964de3",
      "closedAt": "2023-10-22T03:46:38Z",
      "mergedAt": "2023-10-22T03:46:38Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "245c66c12e022013f4a93e00969956af9442f79a"
      },
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "2023-01-05 conversation:\r\n* should this be on the datagram_ instead of packet_ event?\r\n* is there a default value? Should this be a separate event like the spin bit?\r\n* use semantic names?",
          "createdAt": "2023-01-04T19:47:22Z",
          "updatedAt": "2023-01-04T19:47:22Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I've updated the PR to:\r\n* use the semantic names instead of the two bits\r\n* defined Non-ECT as the default value\r\n* moved this to the datagram_ events\r\n\r\nWhile technically more correct, I'm not a big fan of the last one, as the datagram_ events have an importance of \"Extra\", so it's more likely ECN won't be logged. For example, quic-go currently doesn't use the datagram_ events at all.",
          "createdAt": "2023-03-12T08:59:34Z",
          "updatedAt": "2023-03-12T08:59:34Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that's a fair point about `datagrams_` vs `packet_`. IIUC, the only place where this matters anyway is during the handshake, as there can be only a single 1-RTT packet in one datagram. I'm not sure if/how much ECN comes into play during the handshake?\r\n\r\nI think the argument could be made that for the handshake, the ECN bits could be reflected on/copied to each of the potentially coalesced QUIC `packet_` events. They can still be tracked to the singular datagram they were in using the `datagram_id` construction after all. \r\n\r\nIt's a bit less \"clean\"/\"correct\", but that can be said of many things in qlog ;) What do you think, @LPardue?",
          "createdAt": "2023-03-13T09:34:13Z",
          "updatedAt": "2023-03-13T09:34:13Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "We could also put it on both event types, and allow implementations that don\u2019t log datagram events to put it in the packet. Of course, this shifts some complexity to consumers of the qlog.",
          "createdAt": "2023-03-13T19:53:17Z",
          "updatedAt": "2023-03-13T19:53:17Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "I added events for the ECN testing state machine from RFC 9000, A.4. This should now cover the (non-L4S) use case of ECN.\r\n\r\nWould appreciate a review of this PR.",
          "createdAt": "2023-08-11T21:27:25Z",
          "updatedAt": "2023-08-11T21:27:25Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks good to me overall, but I wonder if it would be better to make the ECN enum extensible as well (to allow for easy expansion into L4S in the future if needed):\r\n\r\ne.g., something like\r\n\r\n```\r\n$ECNfield /= {\r\n    * text => any\r\n}\r\n\r\nECN = \"Non-ECT\" / \"ECT(1)\" / \"ECT(0)\" / \"CE\"\r\n\r\n$ECNfield /= ECN\r\n```\r\n\r\nAdditionally, I wonder if we want some way to remove some chattiness here... I imagine that most values in DatagramsSent will be identical once the probing is done, and that you really only want to log when a CE is received in DatagramsReceived. Not sure if it's needed, but maybe some text to state that explicitly like \"no need to log with EVERY packet, only if values change from previously logged value\"? (though arguably you could say that's also observable through the reflected values in the ACKs...). ",
          "createdAt": "2023-08-14T09:09:38Z",
          "updatedAt": "2023-08-14T09:09:38Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> This looks good to me overall, but I wonder if it would be better to make the ECN enum extensible as well (to allow for easy expansion into L4S in the future if needed):\r\n> \r\n> e.g., something like\r\n> \r\n> ```\r\n> $ECNfield /= {\r\n>     * text => any\r\n> }\r\n> \r\n> ECN = \"Non-ECT\" / \"ECT(1)\" / \"ECT(0)\" / \"CE\"\r\n> \r\n> $ECNfield /= ECN\r\n> ```\r\n\r\nI don't think that's needed. There are only 4 ECN values (2 bits) allowed by the IP header. L4S doesn't change that.\r\n\r\n\r\n\r\n> Additionally, I wonder if we want some way to remove some chattiness here... I imagine that most values in DatagramsSent will be identical once the probing is done, and that you really only want to log when a CE is received in DatagramsReceived. Not sure if it's needed, but maybe some text to state that explicitly like \"no need to log with EVERY packet, only if values change from previously logged value\"? (though arguably you could say that's also observable through the reflected values in the ACKs...).\r\n\r\nIt's not observable from the ACKs, the ACK only tells you what happened along the path. Not logging it on every packet sounds good though.",
          "createdAt": "2023-09-01T03:57:00Z",
          "updatedAt": "2023-09-01T03:57:00Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It's not observable from the ACKs, the ACK only tells you what happened along the path.\r\n\r\nnot sure what you mean by this. The ACKs reflect the incoming ECN info to the sender, so looking at incoming ACKs shows you what happened from YOU -> THEM and looking at outgoing ACKs (the one's we're sending) should show what happened THEM -> US. Put differently: your outgoing ACKs should reflect what you saw in DatagramsReceived, no? (though, to be fair, maybe I'm misunderstanding how all of this works). ",
          "createdAt": "2023-09-01T09:10:03Z",
          "updatedAt": "2023-09-01T09:10:03Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> > It's not observable from the ACKs, the ACK only tells you what happened along the path.\r\n> \r\n> not sure what you mean by this. The ACKs reflect the incoming ECN info to the sender, so looking at incoming ACKs shows you what happened from YOU -> THEM and looking at outgoing ACKs (the one's we're sending) should show what happened THEM -> US. Put differently: your outgoing ACKs should reflect what you saw in DatagramsReceived, no? (though, to be fair, maybe I'm misunderstanding how all of this works).\r\n\r\nYou're right, for the receive side. For the send side this doesn't work though.",
          "createdAt": "2023-09-01T09:18:42Z",
          "updatedAt": "2023-09-01T09:18:42Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, agreed then :) \r\nThough, as I said, for the send side the codepoints will (probably?) usually always be the same after detection/negotiation/testing (e.g., if capable, you always send ECT(0) from then on), so no need to keep logging after that. Hence the original comment above. ",
          "createdAt": "2023-09-01T09:24:48Z",
          "updatedAt": "2023-09-01T09:24:48Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "That makes sense. I updated the definition such that the default is now the value on the last event of that type (c7cd9bbcf21e7065ef51c26cb726b5c870522221).\r\n\r\n@LPardue @rmarx Would you mind taking another look at this PR? Would love to get it in before the draft cutoff date for Prague.",
          "createdAt": "2023-10-18T11:24:50Z",
          "updatedAt": "2023-10-18T11:24:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5fvG4F",
          "commit": {
            "abbreviatedOid": "676a680"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-01T04:21:46Z",
          "updatedAt": "2023-09-01T04:21:46Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "See https://en.wikipedia.org/wiki/Explicit_Congestion_Notification#Operation_of_ECN_with_IP\r\n```suggestion\r\nECN = \"Not-ECT\" / \"ECT(1)\" / \"ECT(0)\" / \"CE\"\r\n```",
              "createdAt": "2023-09-01T04:21:46Z",
              "updatedAt": "2023-09-01T04:21:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5fvzA9",
          "commit": {
            "abbreviatedOid": "e127b22"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-01T06:55:38Z",
          "updatedAt": "2023-09-01T06:55:38Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "This is backwards. Testing comes first, and after that comes unknown.\r\n```suggestion\r\n  ; ECN testing in progress\r\n  \"testing\" /\r\n  ; ECN state unknown, waiting for acknowledgements for testing packets\r\n  \"unknown\" /\r\n```",
              "createdAt": "2023-09-01T06:55:38Z",
              "updatedAt": "2023-09-01T06:55:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5kzzuk",
          "commit": {
            "abbreviatedOid": "c7cd9bb"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM modulo 2 nits",
          "createdAt": "2023-10-21T17:24:16Z",
          "updatedAt": "2023-10-21T17:56:24Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n    ; if not set, defaults to the value used on the last\r\n```",
              "createdAt": "2023-10-21T17:24:16Z",
              "updatedAt": "2023-10-21T17:56:24Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nA.4 of {{QUIC-TRANSPORT}}.\r\n```",
              "createdAt": "2023-10-21T17:56:13Z",
              "updatedAt": "2023-10-21T17:56:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 264,
      "id": "PR_kwDOCrLn6M5GRl2m",
      "title": "don't call the AEAD auth tag \"trailer\"",
      "url": "https://github.com/quicwg/qlog/pull/264",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Neither RFC 9000 nor 9001 call this a \"trailer\". We should avoid this terminology, since it could potentially be confused with HTTP trailers.",
      "createdAt": "2022-12-28T02:32:46Z",
      "updatedAt": "2023-03-01T19:31:37Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "259419ac04780bce3183dc5f8f81f4be6376fd02",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-trailer",
      "headRefOid": "4030e396f90472566cafe86b72d3f0c531217a78",
      "closedAt": "2023-03-01T19:31:36Z",
      "mergedAt": "2023-03-01T19:31:36Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "7b3c14029d08af1d1a8e42433ff020b52c7fcecf"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First make a decision on #265, then revise this one, as it might need changes depending on that. ",
          "createdAt": "2023-01-09T14:31:25Z",
          "updatedAt": "2023-01-09T14:31:25Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 265,
      "id": "PR_kwDOCrLn6M5GRnBN",
      "title": "remove the aead_tag_length field from TransportParametersSet",
      "url": "https://github.com/quicwg/qlog/pull/265",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This field is not particularly useful, because\r\n1. it will always be 16, see https://datatracker.ietf.org/doc/html/rfc9001#name-aead-usage\r\n2. it's a property of the TLS cipher suite in use, so it can be trivially looked up, if necessary",
      "createdAt": "2022-12-28T02:46:09Z",
      "updatedAt": "2023-03-13T20:07:53Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "439244f16b3b596179a184dda57e7fbbacf6f47e",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-aead-tag-length",
      "headRefOid": "caecb3eb03388342314b01c737eaa38bbe46a139",
      "closedAt": "2023-03-13T20:07:52Z",
      "mergedAt": "2023-03-13T20:07:52Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "e226e9f92fcadd0b9ff3a30bbfe3d61ea47c7bb8"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So this is a bit of a tough one for me, since I've gone through the pain of trying to determine the length of the TLS trailer for TLS-over-TCP from wireshark output that does NOT explicitly include the size and also makes it difficult to get the proper cipher name to heuristically determine it. \r\n\r\nThat said, for QUIC V1 it's indeed all 16, so you -could- make an argument we can drop it here and add it back in with a V2.1/V3 if new ciphers start being used. I don't have a particularly big preference either way.\r\n\r\nIf we do this change though, the prose could use tightening, because in the current version we have 2 sentences after another that indicate the aead_length depends on the cipher suite. ",
          "createdAt": "2023-01-04T15:51:53Z",
          "updatedAt": "2023-01-04T15:51:53Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I'm leaning on the side of removing this field. The information is made redundant by the cipher suite. Things that care about the tag length can do a lookup or make their own assumptions based on other information",
          "createdAt": "2023-01-09T15:23:24Z",
          "updatedAt": "2023-01-09T15:23:24Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on call. @marten-seemann will make the requested prose change and should be good to go. ",
          "createdAt": "2023-03-01T19:28:22Z",
          "updatedAt": "2023-03-01T19:28:22Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and tightened the text around the tag length.",
          "createdAt": "2023-03-03T00:20:17Z",
          "updatedAt": "2023-03-03T00:20:17Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Minus the comment above, this LGTM. ",
          "createdAt": "2023-03-10T13:57:27Z",
          "updatedAt": "2023-03-10T13:57:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5JjT4w",
          "commit": {
            "abbreviatedOid": "df2498c"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "looks good to me",
          "createdAt": "2023-01-02T22:00:37Z",
          "updatedAt": "2023-01-02T22:00:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5PkRqR",
          "commit": {
            "abbreviatedOid": "f806ecf"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T13:57:02Z",
          "updatedAt": "2023-03-10T13:57:02Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I wonder if we should be explicit in saying \"used for QUIC v1\" or \"used in RFC9001\" for future-proofness? ",
              "createdAt": "2023-03-10T13:57:02Z",
              "updatedAt": "2023-03-10T13:57:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5PkSFP",
          "commit": {
            "abbreviatedOid": "f806ecf"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-10T13:58:07Z",
          "updatedAt": "2023-03-10T13:58:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5Pqizm",
          "commit": {
            "abbreviatedOid": "caecb3e"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-13T09:27:17Z",
          "updatedAt": "2023-03-13T09:27:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 266,
      "id": "PR_kwDOCrLn6M5GRo1G",
      "title": "rephrase sentences containing \"we\"",
      "url": "https://github.com/quicwg/qlog/pull/266",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Work towards resolving #233, for the QUIC events document.",
      "createdAt": "2022-12-28T03:06:59Z",
      "updatedAt": "2023-01-04T19:39:45Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "259419ac04780bce3183dc5f8f81f4be6376fd02",
      "headRepository": "quicwg/qlog",
      "headRefName": "fewer-wes",
      "headRefOid": "d387cb9881e524037a4acce61e45c9a45af9ce21",
      "closedAt": "2023-01-04T19:39:45Z",
      "mergedAt": "2023-01-04T19:39:45Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "ec25b5849940e7aa3d26045de405fe6d37fd8f9d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5JjSnT",
          "commit": {
            "abbreviatedOid": "d387cb9"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is great. There are 2-3 instances in the h3 document as well that could use similar re-wording. I'll post a PR for that",
          "createdAt": "2023-01-02T21:32:23Z",
          "updatedAt": "2023-01-02T21:32:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5JrUb4",
          "commit": {
            "abbreviatedOid": "d387cb9"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-04T15:47:12Z",
          "updatedAt": "2023-01-04T15:47:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 267,
      "id": "PR_kwDOCrLn6M5GgeJA",
      "title": "fix typo in cddl definition",
      "url": "https://github.com/quicwg/qlog/pull/267",
      "state": "MERGED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-02T21:52:02Z",
      "updatedAt": "2023-01-03T00:55:43Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "259419ac04780bce3183dc5f8f81f4be6376fd02",
      "headRepository": "quicwg/qlog",
      "headRefName": "fix_ccdl",
      "headRefOid": "c3fa27464903518c1e1b6c3ff72889d5df9b4414",
      "closedAt": "2023-01-03T00:55:43Z",
      "mergedAt": "2023-01-03T00:55:43Z",
      "mergedBy": "lnicco",
      "mergeCommit": {
        "oid": "9aaa61db8cee475810954e78473f87492d0f6e23"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5JjTo8",
          "commit": {
            "abbreviatedOid": "c3fa274"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-02T21:54:40Z",
          "updatedAt": "2023-01-02T21:54:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 268,
      "id": "PR_kwDOCrLn6M5Ggexv",
      "title": "remove the use of \"we\" in the H3 events file",
      "url": "https://github.com/quicwg/qlog/pull/268",
      "state": "MERGED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Same as #266 but for the h3 events file.\nSee Issue #233\n",
      "createdAt": "2023-01-02T21:58:18Z",
      "updatedAt": "2023-01-04T19:37:43Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "259419ac04780bce3183dc5f8f81f4be6376fd02",
      "headRepository": "quicwg/qlog",
      "headRefName": "h3_we",
      "headRefOid": "fedf9d1f402e655d222e6c2e28b75750fe6ae50b",
      "closedAt": "2023-01-04T19:37:43Z",
      "mergedAt": "2023-01-04T19:37:43Z",
      "mergedBy": "lnicco",
      "mergeCommit": {
        "oid": "eaca9048510081cea1fe22908a030abcbfc79996"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5JjT3T",
          "commit": {
            "abbreviatedOid": "fedf9d1"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-02T22:00:03Z",
          "updatedAt": "2023-01-02T22:00:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 269,
      "id": "PR_kwDOCrLn6M5GgpAf",
      "title": "can a hexstring field be empty ?",
      "url": "https://github.com/quicwg/qlog/pull/269",
      "state": "CLOSED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A zero-length connection id is the only use-cases I can find where an empty hexstring would make sense. But we are using an optional field for those?\nThis is a minor thing. Posting for discussion more than anything\n",
      "createdAt": "2023-01-02T23:37:31Z",
      "updatedAt": "2023-01-18T20:05:45Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "259419ac04780bce3183dc5f8f81f4be6376fd02",
      "headRepository": "quicwg/qlog",
      "headRefName": "hexstring_def",
      "headRefOid": "9ba588a638941d42ec240b224fa5dbfa0c35f687",
      "closedAt": "2023-01-18T20:05:45Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is of course a subtle difference between \"the field was absent/empty\" or \"we have omitted the field in this log due to privacy/size reasons\"... somewhat related to https://github.com/quicwg/qlog/issues/72.\r\n\r\nI think this might be bigger than just the hexstring though (e.g., see the FIN bit on a STREAM frame, which we currently also just treat as optional to indicate it was present or not)",
          "createdAt": "2023-01-04T15:55:58Z",
          "updatedAt": "2023-01-04T15:55:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I think we should support empty. For instance packets using 0-length connection IDs.\r\n\r\nHelp me understand the change though. Does the PR propose allowing empty or restricting it?",
          "createdAt": "2023-01-06T15:28:09Z",
          "updatedAt": "2023-01-06T15:28:09Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue the PR restricts it. Currently, we do allow empty. However, nowhere in the text do we indicate this nuance between empty/omitted, which we probably should if we keep the current behaviour. \r\n\r\nAs I said above and as discussed on the call, I don't really have a preference. \r\n\r\nFor the CID case specifically though, I don't think anyone would actually log empty strings for the CID in each event. You can get the info that a 0-length CID was used from the long-header packet information, where the CID lengths are also logged. The `empty string` CIDs here would only be needed if you somehow didn't log the connection setup. ",
          "createdAt": "2023-01-09T15:06:44Z",
          "updatedAt": "2023-01-09T15:07:17Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on call. No clear preference, so keep as-is. ",
          "createdAt": "2023-01-18T20:05:45Z",
          "updatedAt": "2023-01-18T20:05:45Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 270,
      "id": "PR_kwDOCrLn6M5Ggu8k",
      "title": "Script to validate CDDL for all documents",
      "url": "https://github.com/quicwg/qlog/pull/270",
      "state": "MERGED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "the main_schema file is validated on its own,\nboth the http and quic event documents also include the main schema\n\nSample run\n```\n~/github/qlog (main*) \u00bb make cddl                                                                                  lnicco@Lucas-MacBook-Air\nValidating draft-ietf-quic-qlog-h3-events.md\n  OK\nValidating draft-ietf-quic-qlog-main-schema.md\n  OK\nValidating draft-ietf-quic-qlog-quic-events.md\n  ERROR\n  debug with: ./cddl_validate.sh draft-ietf-quic-qlog-quic-events.md\n```\n\nThe quic events file error is fixed in #267\n",
      "createdAt": "2023-01-03T00:55:06Z",
      "updatedAt": "2023-01-11T21:04:20Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "259419ac04780bce3183dc5f8f81f4be6376fd02",
      "headRepository": "quicwg/qlog",
      "headRefName": "cddl_validate",
      "headRefOid": "007acb9937d6ae505386445184bd006be98880a0",
      "closedAt": "2023-01-11T21:04:20Z",
      "mergedAt": "2023-01-11T21:04:20Z",
      "mergedBy": "lnicco",
      "mergeCommit": {
        "oid": "eba303c1ac9e4f8cabe48c9dc1ef067b549bb41d"
      },
      "comments": [
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "I addressed the comments, by actually removing the `deps` override target all together. \r\nThe lib/ Makefile already takes care of that and checking for ruby installation. \r\n\r\nI will merge this and #272 and see how it works with Github actions. \r\nI'll address any issue separately",
          "createdAt": "2023-01-11T21:04:12Z",
          "updatedAt": "2023-01-11T21:04:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5JkO2_",
          "commit": {
            "abbreviatedOid": "28f099e"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-03T08:53:02Z",
          "updatedAt": "2023-01-03T08:54:02Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "oops, forgot to cleanup this line",
              "createdAt": "2023-01-03T08:53:03Z",
              "updatedAt": "2023-01-03T08:54:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5J8mxf",
          "commit": {
            "abbreviatedOid": "41c7b39"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-01-09T14:52:39Z",
          "updatedAt": "2023-01-09T14:56:27Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n# override lib/main.mk all target, to also run the cddl validation on each make invocation\r\n```",
              "createdAt": "2023-01-09T14:52:39Z",
              "updatedAt": "2023-01-09T14:56:27Z"
            },
            {
              "originalPosition": 25,
              "body": "Looking at the makefiles from https://github.com/martinthomson/i-d-template, it seems it doesn't install ruby itself. This is somewhat fine, since the base template can function without Ruby, but the qlog repo can't. \r\n\r\nSo I'd say either make ruby auto-install as well here, or, if too difficult, check for ruby (e.g., as https://github.com/martinthomson/i-d-template/blob/main/deps.mk#L86) and throw error if not present?",
              "createdAt": "2023-01-09T14:54:57Z",
              "updatedAt": "2023-01-09T14:56:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5J88n-",
          "commit": {
            "abbreviatedOid": "41c7b39"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM modulo nits that others have raised",
          "createdAt": "2023-01-09T15:43:00Z",
          "updatedAt": "2023-01-09T15:43:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5J_O8G",
          "commit": {
            "abbreviatedOid": "41c7b39"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-09T22:53:02Z",
          "updatedAt": "2023-01-09T22:53:02Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "very good point. \r\nI think checking and throwing an error is the best course of action. \r\n\r\nInstalling ruby or python is something that the lib makefile also doesn't do because it would get into the multi-platform rabbit hole. \r\nI'll call it out of scope \ud83d\ude05 and just check for ruby",
              "createdAt": "2023-01-09T22:53:02Z",
              "updatedAt": "2023-01-11T19:53:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5KLzid",
          "commit": {
            "abbreviatedOid": "41c7b39"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-11T21:02:17Z",
          "updatedAt": "2023-01-11T21:02:18Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "turns out the lib makefile is pure magic and it already does everything we want just by already checking for the presence of a local Gemfile .. MT for the win. ",
              "createdAt": "2023-01-11T21:02:18Z",
              "updatedAt": "2023-01-11T21:02:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 271,
      "id": "PR_kwDOCrLn6M5GgxY8",
      "title": "cddl validate github action",
      "url": "https://github.com/quicwg/qlog/pull/271",
      "state": "CLOSED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Script to validate CDDL for all documents\n- Github Action to validate CDDL\n",
      "createdAt": "2023-01-03T01:24:55Z",
      "updatedAt": "2023-01-03T04:13:10Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "9aaa61db8cee475810954e78473f87492d0f6e23",
      "headRepository": "quicwg/qlog",
      "headRefName": "cddl_validate_github_action",
      "headRefOid": "a784c6464f1a2227c5cbef0bc5bd1c5573f5cf0e",
      "closedAt": "2023-01-03T03:57:32Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 272,
      "id": "PR_kwDOCrLn6M5GhAto",
      "title": "Github Action to validate CDDL",
      "url": "https://github.com/quicwg/qlog/pull/272",
      "state": "MERGED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "tested locally (on macos) with `act` https://github.com/nektos/act\n\n```\nact -j validate --container-architecture linux/amd64\n```\n",
      "createdAt": "2023-01-03T04:19:11Z",
      "updatedAt": "2023-01-11T21:05:10Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "9aaa61db8cee475810954e78473f87492d0f6e23",
      "headRepository": "quicwg/qlog",
      "headRefName": "cddl_validate_gh_action",
      "headRefOid": "7ddc34972bb759d9a10e48b7b6400584d0d64ef9",
      "closedAt": "2023-01-11T21:05:09Z",
      "mergedAt": "2023-01-11T21:05:09Z",
      "mergedBy": "lnicco",
      "mergeCommit": {
        "oid": "a6fc758cb1c7402055417500ec3689d2102b70d5"
      },
      "comments": [
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "depends on https://github.com/quicwg/qlog/pull/270",
          "createdAt": "2023-01-03T04:19:55Z",
          "updatedAt": "2023-01-03T04:19:55Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "Sample output to show that `if: success() || failure()` works as expected:\r\n\r\n```\r\n)>'\r\n| \tfrom /opt/hostedtoolcache/Ruby/2.6.10/x64/bin/cddl:23:in `load'\r\n| \tfrom /opt/hostedtoolcache/Ruby/2.6.10/x64/bin/cddl:23:in `<main>'\r\n[CDDL Validation/Validates CDDL for all documents]   \u274c  Failure - Main validate CDDL (quic events)\r\n[CDDL Validation/Validates CDDL for all documents] exitcode '1': failure\r\n[CDDL Validation/Validates CDDL for all documents] \u2b50 Run Main validate CDDL (h3 events)\r\n[CDDL Validation/Validates CDDL for all documents]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/7] user= workdir=\r\n| *** Unused rule uint8\r\n| *** Ignoring .default for now.\r\n[CDDL Validation/Validates CDDL for all documents]   \u2705  Success - Main validate CDDL (h3 events)\r\n[CDDL Validation/Validates CDDL for all documents] \ud83c\udfc1  Job failed\r\nError: Job 'Validates CDDL for all documents' failed\r\n```",
          "createdAt": "2023-01-04T22:51:24Z",
          "updatedAt": "2023-01-04T22:51:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5JtDqK",
          "commit": {
            "abbreviatedOid": "7ddc349"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-04T22:13:41Z",
          "updatedAt": "2023-01-04T22:13:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5J8kZS",
          "commit": {
            "abbreviatedOid": "7ddc349"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-09T14:46:58Z",
          "updatedAt": "2023-01-09T14:46:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5J885s",
          "commit": {
            "abbreviatedOid": "7ddc349"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-09T15:43:40Z",
          "updatedAt": "2023-01-09T15:43:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 274,
      "id": "PR_kwDOCrLn6M5HFXjy",
      "title": "Make use of raw and RawInfo more consistent",
      "url": "https://github.com/quicwg/qlog/pull/274",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #243, #54 and #173.\r\nPartially fixes #174.",
      "createdAt": "2023-01-10T15:57:46Z",
      "updatedAt": "2023-01-19T10:56:56Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "2cfb43774779407f8bdc1100d3785f1a5997b54e",
      "headRepository": "quicwg/qlog",
      "headRefName": "rawinfo_consistency",
      "headRefOid": "731b1ac7e896177dc4ea4e1f30f33f5697112dfe",
      "closedAt": "2023-01-19T10:56:48Z",
      "mergedAt": "2023-01-19T10:56:48Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "148d91306aa96ee6af6e08554cecb6c0e7277b0f"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Looks good to me modulo a few nits and editorials",
          "createdAt": "2023-01-11T19:49:26Z",
          "updatedAt": "2023-01-11T19:49:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5KLXRz",
          "commit": {
            "abbreviatedOid": "94b072c"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-11T19:28:31Z",
          "updatedAt": "2023-01-11T19:28:32Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\ntake up considerable space, and can have a considerable privacy and security\r\n```",
              "createdAt": "2023-01-11T19:28:31Z",
              "updatedAt": "2023-01-11T19:28:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5KLXX8",
          "commit": {
            "abbreviatedOid": "94b072c"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-11T19:28:51Z",
          "updatedAt": "2023-01-11T19:47:34Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "worth xref to security considerations?",
              "createdAt": "2023-01-11T19:28:51Z",
              "updatedAt": "2023-01-11T19:47:34Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nimpact. Where applicable, these fields are grouped in a separate, optional, field\r\n```",
              "createdAt": "2023-01-11T19:29:20Z",
              "updatedAt": "2023-01-11T19:47:34Z"
            },
            {
              "originalPosition": 65,
              "body": "```suggestion\r\n{{truncated-values}}. In this case, the length and payload_length fields should\r\n```",
              "createdAt": "2023-01-11T19:30:34Z",
              "updatedAt": "2023-01-11T19:47:34Z"
            },
            {
              "originalPosition": 65,
              "body": "is this a SHOULD requirement?\r\n\r\nEither way, it might help to explain why keeping the non-truncated length is advised.",
              "createdAt": "2023-01-11T19:33:29Z",
              "updatedAt": "2023-01-11T19:47:34Z"
            },
            {
              "originalPosition": 80,
              "body": "```suggestion\r\nAEAD tag), event definitions documents SHOULD define a how to support\r\nheader_length calculation.\r\n```",
              "createdAt": "2023-01-11T19:34:58Z",
              "updatedAt": "2023-01-11T19:47:34Z"
            },
            {
              "originalPosition": 52,
              "body": "Is this paragraph necessary? There are no events with a `direction` field. The purpose of from/too fields is already desdcribed in the earlier paragraphs. This text seems superflous to me.",
              "createdAt": "2023-01-11T19:40:16Z",
              "updatedAt": "2023-01-11T19:47:34Z"
            },
            {
              "originalPosition": 102,
              "body": "I find this a bit ambigous to read. How about something like\r\n\r\n```suggestion\r\nThe error_code_value is the numerical value without VLIE encoding.\r\nThis is useful because some error types are spread out over a range of\r\ncodes (e.g., QUIC's crypto_error).\r\n```",
              "createdAt": "2023-01-11T19:45:15Z",
              "updatedAt": "2023-01-11T19:47:34Z"
            },
            {
              "originalPosition": 125,
              "body": "Again, reads ambiguous to me.",
              "createdAt": "2023-01-11T19:45:38Z",
              "updatedAt": "2023-01-11T19:47:34Z"
            },
            {
              "originalPosition": 141,
              "body": "```suggestion\r\n## Since draft-ietf-qlog-quic-events-03:\r\n```",
              "createdAt": "2023-01-11T19:47:25Z",
              "updatedAt": "2023-01-11T19:47:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5KYO_w",
          "commit": {
            "abbreviatedOid": "0f00195"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T15:43:50Z",
          "updatedAt": "2023-01-13T15:59:32Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nThis event is emitted when the HTTP/3 framing actually happens. This does\r\nnot necessarily coincide with HTTP/3 data getting passed to the QUIC layer.\r\n```",
              "createdAt": "2023-01-13T15:43:50Z",
              "updatedAt": "2023-01-13T15:59:32Z"
            },
            {
              "originalPosition": 89,
              "body": "This seems like it can be genericised and moved somewhere else: there is no tight coupling between H3 and QUIC frame boundaries meaning a H3 frames could span many packets, or many frames could be in a single packet.\r\n\r\nImplementations can deploy streaming strategies to any H3 frame parsing. I agree that DATA frames are the most likely, but really any frame could be larger than a packet. \r\n\r\nFurthermore, due to varint H3 frame fields and the lack of preserved boundaries, some implementations might generate data_moved events before frame_parsed events. Cloudlfare quiche does this, for example. \r\n\r\nThe text is better than the old text, so lets not block the PR. I'll open a separate issue.",
              "createdAt": "2023-01-13T15:54:13Z",
              "updatedAt": "2023-01-13T15:59:32Z"
            },
            {
              "originalPosition": 23,
              "body": "I realise this text was already there but why is it per-endpoint?",
              "createdAt": "2023-01-13T15:56:20Z",
              "updatedAt": "2023-01-13T15:59:32Z"
            },
            {
              "originalPosition": 28,
              "body": "Consider moving this above the previous paragraph to match the ordering of the fields",
              "createdAt": "2023-01-13T15:57:19Z",
              "updatedAt": "2023-01-13T15:59:32Z"
            },
            {
              "originalPosition": 55,
              "body": "This would just render as a section number right? That's not very reader-friendly.\r\n```suggestion\r\nother reasons, packet_dropped ({{transport-packetdropped}}) should be used instead.\r\n```",
              "createdAt": "2023-01-13T15:58:43Z",
              "updatedAt": "2023-01-13T15:59:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5KYcEB",
          "commit": {
            "abbreviatedOid": "0f00195"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T16:02:44Z",
          "updatedAt": "2023-01-13T16:02:44Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Because there is no (obvious?) in-band way to share datagram-ids between individually logging endpoints? To keep them consistent, you'd have to have a stable hash or something? ",
              "createdAt": "2023-01-13T16:02:44Z",
              "updatedAt": "2023-01-13T16:02:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5KhE4j",
          "commit": {
            "abbreviatedOid": "0f00195"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-16T13:36:15Z",
          "updatedAt": "2023-01-16T13:36:16Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Opened a separate issue for this. see #281 ",
              "createdAt": "2023-01-16T13:36:15Z",
              "updatedAt": "2023-01-16T13:47:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5KhxHj",
          "commit": {
            "abbreviatedOid": "1bb53cf"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-16T15:36:21Z",
          "updatedAt": "2023-01-16T15:36:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 276,
      "id": "PR_kwDOCrLn6M5HMT40",
      "title": "[test-only] checking GH Actions for CDDL checl",
      "url": "https://github.com/quicwg/qlog/pull/276",
      "state": "CLOSED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "test only, not for commit",
      "createdAt": "2023-01-11T21:08:28Z",
      "updatedAt": "2023-01-11T21:29:18Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6e40c4e0d342a09aa0bebdfa94856e8a76d821fa",
      "headRepository": "quicwg/qlog",
      "headRefName": "lnicco-test-gh-actions",
      "headRefOid": "4be61faf88071e7fd0bb62ad1fe326c9603b6b67",
      "closedAt": "2023-01-11T21:29:17Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "Fantastic, it works. Thanks a lot @LPardue for the reviews \r\n\r\n<img width=\"322\" alt=\"image\" src=\"https://user-images.githubusercontent.com/54891/211921503-6c4447aa-5b14-47b0-a70d-2d53f3753cf7.png\">\r\n\r\n",
          "createdAt": "2023-01-11T21:28:36Z",
          "updatedAt": "2023-01-11T21:28:36Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "test was successful. Closing",
          "createdAt": "2023-01-11T21:29:17Z",
          "updatedAt": "2023-01-11T21:29:17Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 277,
      "id": "PR_kwDOCrLn6M5HMVX7",
      "title": "run CDDL GH Action on all commits and pull requests",
      "url": "https://github.com/quicwg/qlog/pull/277",
      "state": "MERGED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\nI sent a sample PR (#276) and the Action didn't run\nhttps://github.com/quicwg/qlog/actions/workflows/cddl_validate.yml\n\nThis should fix it\n",
      "createdAt": "2023-01-11T21:14:44Z",
      "updatedAt": "2023-01-11T21:23:27Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "a6fc758cb1c7402055417500ec3689d2102b70d5",
      "headRepository": "quicwg/qlog",
      "headRefName": "gh_action_cddl_always_run",
      "headRefOid": "12ed20fbaabebfd89429bbb824c8abdd5dbd8a7f",
      "closedAt": "2023-01-11T21:23:26Z",
      "mergedAt": "2023-01-11T21:23:26Z",
      "mergedBy": "lnicco",
      "mergeCommit": {
        "oid": "6e40c4e0d342a09aa0bebdfa94856e8a76d821fa"
      },
      "comments": [
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "First successful run! \r\nhttps://github.com/quicwg/qlog/actions/runs/3896812322/jobs/6653788943",
          "createdAt": "2023-01-11T21:22:05Z",
          "updatedAt": "2023-01-11T21:22:05Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5KL46H",
          "commit": {
            "abbreviatedOid": "12ed20f"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-11T21:22:11Z",
          "updatedAt": "2023-01-11T21:22:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 278,
      "id": "PR_kwDOCrLn6M5HVwkB",
      "title": "Clean up packet_dropped",
      "url": "https://github.com/quicwg/qlog/pull/278",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #25. ",
      "createdAt": "2023-01-13T15:28:17Z",
      "updatedAt": "2023-02-13T09:21:33Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "148d91306aa96ee6af6e08554cecb6c0e7277b0f",
      "headRepository": "quicwg/qlog",
      "headRefName": "clean_packetdropped",
      "headRefOid": "c9c0cff096859131b9f019eabed45994b2f1880f",
      "closedAt": "2023-02-13T09:21:33Z",
      "mergedAt": "2023-02-13T09:21:33Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "7a35870f373e78e9b856b2418425d02a2f3d707f"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey @nibanks, we think this PR is ready to be merged. If you have some time this week for a quick review, that would be splendid :) ",
          "createdAt": "2023-01-19T10:55:46Z",
          "updatedAt": "2023-01-19T10:55:46Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5KYKoQ",
          "commit": {
            "abbreviatedOid": "3f85410"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM modulo nits",
          "createdAt": "2023-01-13T15:36:48Z",
          "updatedAt": "2023-01-13T15:40:34Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "```suggestion\r\n- internal_error: not initialized, out of memory\r\n```",
              "createdAt": "2023-01-13T15:36:48Z",
              "updatedAt": "2023-01-13T15:40:34Z"
            },
            {
              "originalPosition": 60,
              "body": "more generic version \r\n\r\n```suggestion\r\n- connection_unknown: packet does not relate to a known connection\r\n```",
              "createdAt": "2023-01-13T15:38:02Z",
              "updatedAt": "2023-01-13T15:40:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5LMhyv",
          "commit": {
            "abbreviatedOid": "aec792c"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-19T11:10:48Z",
          "updatedAt": "2023-01-19T11:10:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 279,
      "id": "PR_kwDOCrLn6M5HV8qX",
      "title": "Clean up text around events not belonging to a single connection",
      "url": "https://github.com/quicwg/qlog/pull/279",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #35 ",
      "createdAt": "2023-01-13T16:01:03Z",
      "updatedAt": "2023-03-02T10:00:26Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "71ebbfe8367fa5806d27ec0b7f0703aace203eac",
      "headRepository": "quicwg/qlog",
      "headRefName": "clean-serverguidance",
      "headRefOid": "af43e398867e0232a34f935209f1c163e3ce5843",
      "closedAt": "2023-03-02T10:00:26Z",
      "mergedAt": "2023-03-02T10:00:26Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "439244f16b3b596179a184dda57e7fbbacf6f47e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5KYlnJ",
          "commit": {
            "abbreviatedOid": "47d038e"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T16:18:02Z",
          "updatedAt": "2023-01-13T16:18:03Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "grammar police: more difficult to implement than what?\r\n\r\nIf there are challenges or difficulties we can say that, but the \"more\" qualifier makes the sentence a comparison and this could be misinterpreted to mean that we are comparing this option to the others. If we are actually trying to compare the options (I don't think we are but I could be wrong) then we probably want to restructure a bit.",
              "createdAt": "2023-01-13T16:18:03Z",
              "updatedAt": "2023-01-13T16:18:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5KwkwU",
          "commit": {
            "abbreviatedOid": "47d038e"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-18T20:13:36Z",
          "updatedAt": "2023-01-18T20:13:37Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Discussed on call. Best to just remove these parts here, unless we have concrete data/proof or examples. ",
              "createdAt": "2023-01-18T20:13:37Z",
              "updatedAt": "2023-01-18T20:13:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5OtOzp",
          "commit": {
            "abbreviatedOid": "2548d74"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-01T19:22:01Z",
          "updatedAt": "2023-03-01T19:22:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 282,
      "id": "PR_kwDOCrLn6M5Hi_BD",
      "title": "s/max_header_list_size/max_field_section_size",
      "url": "https://github.com/quicwg/qlog/pull/282",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #175\n",
      "createdAt": "2023-01-17T14:26:08Z",
      "updatedAt": "2023-01-18T20:00:39Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6e40c4e0d342a09aa0bebdfa94856e8a76d821fa",
      "headRepository": "quicwg/qlog",
      "headRefName": "max_field-section",
      "headRefOid": "5f6deb2981e7679ecdacdd780cd36d46eca4a84e",
      "closedAt": "2023-01-18T20:00:35Z",
      "mergedAt": "2023-01-18T20:00:35Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "2cfb43774779407f8bdc1100d3785f1a5997b54e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5Kmvus",
          "commit": {
            "abbreviatedOid": "5f6deb2"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-17T14:34:59Z",
          "updatedAt": "2023-01-17T14:34:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5KweCg",
          "commit": {
            "abbreviatedOid": "5f6deb2"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-18T20:00:27Z",
          "updatedAt": "2023-01-18T20:00:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 284,
      "id": "PR_kwDOCrLn6M5Hjjax",
      "title": "Add addtional_schema field",
      "url": "https://github.com/quicwg/qlog/pull/284",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This adds the additional_schema field to QlogFile defined in the main\nschema. The purpose being to explicitly identify the schema used for\nadditional events (possibly) included in qlog traces.\n\nThe field is free-forma and could be anything. We could go XML style\nand require a URL. I've started by just proposing that we reference\nthe document name:\n\nfor I-Ds, this makes it easy to manage iterative versions\nfor RFCs, these have a canonical source already. If an RFC update\nis published and an implementation switches to it, we can change\neasily.\n\nCloses #283\n",
      "createdAt": "2023-01-17T16:03:32Z",
      "updatedAt": "2024-03-18T08:07:12Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "57a8c67bea1d35aa585fb7c2fadbd98faf3cfb39",
      "headRepository": "quicwg/qlog",
      "headRefName": "versioning-schema",
      "headRefOid": "4af96f553158a2ee752335ffae70219b8c7d0351",
      "closedAt": "2024-03-18T08:07:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 285,
      "id": "PR_kwDOCrLn6M5Hj70_",
      "title": "Add missing QUIC transport error values",
      "url": "https://github.com/quicwg/qlog/pull/285",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Adds missing code points except for CRYPTO_ERROR. Since we make an\nexplicit choice to represent that as a CryptoError type, call that\nout in a note\n\nFixes #129\n",
      "createdAt": "2023-01-17T17:17:10Z",
      "updatedAt": "2023-01-18T19:59:47Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6e40c4e0d342a09aa0bebdfa94856e8a76d821fa",
      "headRepository": "quicwg/qlog",
      "headRefName": "add-missing-transport-errors",
      "headRefOid": "db4ed41b32b24d3ec21a5d102d98902ae118940e",
      "closedAt": "2023-01-18T19:59:46Z",
      "mergedAt": "2023-01-18T19:59:46Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "02574ec6fc6110e71f44c17ed0afc4370e632edb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5KswV8",
          "commit": {
            "abbreviatedOid": "5b36af6"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-18T10:50:59Z",
          "updatedAt": "2023-01-18T10:51:00Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n    ; there is no value to reflect CRYPTO_ERROR; use the CryptoError type instead\r\n```",
              "createdAt": "2023-01-18T10:51:00Z",
              "updatedAt": "2023-01-18T10:51:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5Kswbb",
          "commit": {
            "abbreviatedOid": "5b36af6"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM minus nit",
          "createdAt": "2023-01-18T10:51:14Z",
          "updatedAt": "2023-01-18T10:51:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5KwdoK",
          "commit": {
            "abbreviatedOid": "db4ed41"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-18T19:59:32Z",
          "updatedAt": "2023-01-18T19:59:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 287,
      "id": "PR_kwDOCrLn6M5HkMMd",
      "title": "Move HTTP/3 events and their related data to their own prefix",
      "url": "https://github.com/quicwg/qlog/pull/287",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Since most of these events are HTTP/3 specific, lets just rename them to\nuse an H3 prefix.\n\nThe one exception is `HTTPField` because it is actually aligned to HTTP\nSemantics rather than any particular wire format.\n\nFixes #286\n",
      "createdAt": "2023-01-17T18:18:53Z",
      "updatedAt": "2023-05-19T01:27:10Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6e40c4e0d342a09aa0bebdfa94856e8a76d821fa",
      "headRepository": "quicwg/qlog",
      "headRefName": "http-stop-squatting",
      "headRefOid": "96743bc0968d893607b9f6a56377e7a34e59911b",
      "closedAt": "2023-05-19T01:26:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This breaks lots of alignment in subtle ways, I can't recall if we decided on rules for that but let me know",
          "createdAt": "2023-01-17T18:21:05Z",
          "updatedAt": "2023-01-17T18:21:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "too bitrot, see #300 instead",
          "createdAt": "2023-05-19T01:27:10Z",
          "updatedAt": "2023-05-19T01:27:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5KwnaA",
          "commit": {
            "abbreviatedOid": "6bcb29a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-18T20:18:45Z",
          "updatedAt": "2023-01-18T20:18:46Z",
          "comments": [
            {
              "originalPosition": 319,
              "body": "Discussed on call. Rename to H3HTTPField. Dirty, but consistent. ",
              "createdAt": "2023-01-18T20:18:45Z",
              "updatedAt": "2023-01-18T20:18:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5OtP9K",
          "commit": {
            "abbreviatedOid": "6bcb29a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T19:25:26Z",
          "updatedAt": "2023-03-01T19:25:27Z",
          "comments": [
            {
              "originalPosition": 319,
              "body": "Discussed on call. Postpone merge until we have an equivalent transport PR to merge along and until #253 is merged. ",
              "createdAt": "2023-03-01T19:25:26Z",
              "updatedAt": "2023-03-01T19:25:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5OtQBo",
          "commit": {
            "abbreviatedOid": "6bcb29a"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T19:25:39Z",
          "updatedAt": "2023-03-01T19:25:54Z",
          "comments": [
            {
              "originalPosition": 372,
              "body": "NIT: case is not consistent GoAway in the title vs Goaway in the Frame definition",
              "createdAt": "2023-03-01T19:25:39Z",
              "updatedAt": "2023-03-01T19:25:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5OtQrG",
          "commit": {
            "abbreviatedOid": "6bcb29a"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T19:27:37Z",
          "updatedAt": "2023-03-01T19:27:59Z",
          "comments": [
            {
              "originalPosition": 319,
              "body": "```suggestion\r\nH3HTTPField = {\r\n```",
              "createdAt": "2023-03-01T19:27:37Z",
              "updatedAt": "2023-03-01T19:27:59Z"
            },
            {
              "originalPosition": 312,
              "body": "```suggestion\r\n    headers: [* H3HTTPField]\r\n```",
              "createdAt": "2023-03-01T19:27:47Z",
              "updatedAt": "2023-03-01T19:27:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 288,
      "id": "PR_kwDOCrLn6M5HknGl",
      "title": "Make minimum_congestion_window uint64 for consistency",
      "url": "https://github.com/quicwg/qlog/pull/288",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "If it's ok for the congestion_window and the initial_congestion_window to be uint64, lets make minimum_congestion_window the same.\r\n\r\nWe might split hairs about the initial being smaller in reality but that's presumptious and we don't want to retread Bill Gate's steps. Lets just pick uint64 and move on.\r\n\r\nCloses #164\r\n",
      "createdAt": "2023-01-17T19:54:58Z",
      "updatedAt": "2023-01-18T19:57:10Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6e40c4e0d342a09aa0bebdfa94856e8a76d821fa",
      "headRepository": "quicwg/qlog",
      "headRefName": "consistent-cwnd-primitive-types",
      "headRefOid": "0025a3fd4c2e484b14dd313d607f88d4c06173db",
      "closedAt": "2023-01-18T19:57:05Z",
      "mergedAt": "2023-01-18T19:57:05Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "a3ce09d53c259e87dc88036842a2f9cb01fd98d4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5KpvzV",
          "commit": {
            "abbreviatedOid": "0025a3f"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-17T21:08:41Z",
          "updatedAt": "2023-01-17T21:08:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5Kslvx",
          "commit": {
            "abbreviatedOid": "0025a3f"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-18T10:22:24Z",
          "updatedAt": "2023-01-18T10:22:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 289,
      "id": "PR_kwDOCrLn6M5HoODp",
      "title": "editorialize serialization section",
      "url": "https://github.com/quicwg/qlog/pull/289",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "- Judicious editorial change to section 6\n- move truncation section below json-seq\n- Split optimization to guidelines and survey/speculation\n- move conversion considerations to appendix\n- fixup: promote truncation a level\n",
      "createdAt": "2023-01-18T14:00:11Z",
      "updatedAt": "2023-12-09T20:26:42Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "67552f1d7022556a75abd545adf1c26004e0ed21",
      "headRepository": "quicwg/qlog",
      "headRefName": "editorialize-serialization-section",
      "headRefOid": "c903b6a391dcc7b2992f43d8f56fd6a5c1a96011",
      "closedAt": "2023-12-09T20:26:35Z",
      "mergedAt": "2023-12-09T20:26:35Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "9713e68e43e7eaba785c5c3f321be278bdc18f1d"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "To add more colour to this PR, section 6 is very large and ranges between discussing things we really want implementers to consider - like mapping to JSON or JSON-SEQ, to other information that verges on research results or speculation. optimizations. It then oddly appears to say we aren't defining these optimizations formally but that there's normative language for how their file extensions and media types are to be handled. This sort of mixed messaging is likely to come up in wider review.\r\n\r\nSo this PR is a strawman for breaking apart the section to focus on what implementers need to do in the main body. It punts the more subjective stuff to the appendix while also watering down our guidance about how they would treat extensions or media types.\r\n\r\nOne could make the argument that compression of JSON and JSON-SEQ is mature enough an optimization to make it into the main body. I could agree with that but wanted to start somewhere.",
          "createdAt": "2023-01-18T14:11:48Z",
          "updatedAt": "2023-01-18T14:11:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5OjVAu",
          "commit": {
            "abbreviatedOid": "b3ac2d4"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Generally, this is in good shape. The now-appendices need some editorial love to align with the (intended) tone of the rest of the text, but that might be done in another PR later. ",
          "createdAt": "2023-02-28T15:32:44Z",
          "updatedAt": "2023-02-28T16:19:42Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "```suggestion\r\nI-JSON {{format-ijson}}, and its streaming counterpart JSON Text Sequences ({{format-json-seq}}. Furthermore,\r\n```",
              "createdAt": "2023-02-28T15:32:45Z",
              "updatedAt": "2023-02-28T16:19:42Z"
            },
            {
              "originalPosition": 86,
              "body": "```suggestion\r\ngiven on how to map qlog to JSON ({{format-json}}, its subset\r\n```",
              "createdAt": "2023-02-28T15:33:19Z",
              "updatedAt": "2023-02-28T16:19:42Z"
            },
            {
              "originalPosition": 92,
              "body": "```suggestion\r\n\"qlog_format\" field ({{top-level}}) is used to indicate the chosen serialization\r\n```",
              "createdAt": "2023-02-28T15:33:55Z",
              "updatedAt": "2023-02-28T16:19:42Z"
            },
            {
              "originalPosition": 119,
              "body": "```suggestion\r\nUTF-8 both for the file itself and the string values it contains. In addition, all qlog\r\n```",
              "createdAt": "2023-02-28T15:36:44Z",
              "updatedAt": "2023-02-28T16:19:42Z"
            },
            {
              "originalPosition": 120,
              "body": "I've called this \"field names\" consistently throughout the qlog documents. However, double-checking this with the JSON RFC at https://www.rfc-editor.org/rfc/rfc8259#section-4, they use \"member names\" or \"object member names\" instead. \r\n\r\nI'm not sure that makes things any clearer for readers unfamiliar with JSON terminology, and changing things would be a big overall update across the docs, but potentially worth it for consistency? Either way, would require a new issue/PR. ",
              "createdAt": "2023-02-28T15:41:43Z",
              "updatedAt": "2023-02-28T16:19:42Z"
            },
            {
              "originalPosition": 150,
              "body": "```suggestion\r\nintegrated within a JavaScript environment (e.g., Web browsers, NodeJS). For use\r\n```",
              "createdAt": "2023-02-28T15:42:25Z",
              "updatedAt": "2023-02-28T16:19:42Z"
            },
            {
              "originalPosition": 171,
              "body": "I found this part to have a bit of a weird build-up, so thought maybe this flows better:\r\n\r\n\r\n> This can be problematic, as some protocols (e.g., QUIC, HTTP/3), might use the full int64/uint64\r\nrange and we therefore need a qlog serialization format to support it. One solution to this is to allow a string-based representation of 64-bit integers in addition to the numerical, but range-limited representation. \r\n\r\n> As such, when using I-JSON in these situations, the following CDDL definition of uint64 should override the original and parsers should take into account that a uint64 field can either be a number or string. \r\n",
              "createdAt": "2023-02-28T15:51:28Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 250,
              "body": "```suggestion\r\nmost JSON parsers will fail if a document is malformed. Some streaming JSON parsers are able to handle missing closing tags, however they are not widely deployed in popular environments (e.g., Web browsers)\r\n```",
              "createdAt": "2023-02-28T15:54:24Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 247,
              "body": "```suggestion\r\nthem, and then finalizing the log by appending appropriate closing tags e.g.,\r\n```",
              "createdAt": "2023-02-28T15:54:50Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 147,
              "body": "Since we removed truncation from this, it's a bit weird to have just a single subsection under JSON. It's also weird we don't explicitly say anything about \"qlog_format\"/file extension/MIME type when employing I-JSON (it's still just \"JSON\", but that should be explicitly spelled out imo).\r\n\r\nIt makes more sense to promote I-JSON to a `##` here, so we have 3 sections for the 3 formats (this is also how they're introduced atm). ",
              "createdAt": "2023-02-28T15:57:34Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 289,
              "body": "```suggestion\r\n\"events\" array. An example is provided in {{json-seq-ex}}.\r\n```",
              "createdAt": "2023-02-28T15:59:41Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 292,
              "body": "```suggestion\r\n\"JSON-SEQ\". The file extension/suffix SHOULD be \".sqlog\" (for \"streaming\" qlog).\r\n```",
              "createdAt": "2023-02-28T16:00:04Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 302,
              "body": "Imo this should be moved up to right after the Trace vs TraceSeq discussion (line 1400 above, \"which notably includes only a single trace (TraceSeq) and omits an explicit events field\")",
              "createdAt": "2023-02-28T16:02:29Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 339,
              "body": "```suggestion\r\ninstead a truncated value. For example, one might only store the first 100 bytes of an\r\nHTTP response body to be able to discern which file it actually\r\ncontained. In these cases, the original byte-size length cannot be\r\n```",
              "createdAt": "2023-02-28T16:04:12Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 421,
              "body": "```suggestion\r\n~~~~~~~~\r\n// both the content's value and its length are present\r\n// (length is redundant)\r\n{\r\n    \"content_length\": 5,\r\n    \"content\": \"051428abff\"\r\n}\r\n```",
              "createdAt": "2023-02-28T16:06:38Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 432,
              "body": "```suggestion\r\n// only the content value is present, indicating it\r\n// represents the content's full value. The byte\r\n// length is obtained by calculating content.length / 2\r\n{\r\n    \"content\": \"051428abff\"\r\n}\r\n```",
              "createdAt": "2023-02-28T16:07:16Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 439,
              "body": "```suggestion\r\n// only the length is present, meaning the value\r\n// was omitted\r\n{\r\n    \"content_length\": 5,\r\n}\r\n```",
              "createdAt": "2023-02-28T16:07:48Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 454,
              "body": "```suggestion\r\n// both value and length are present, but the lengths \r\n// do not match: the value was truncated to \r\n// the first three bytes.\r\n{\r\n    \"content_length\": 5,\r\n    \"content\": \"051428\"\r\n}\r\n```",
              "createdAt": "2023-02-28T16:10:26Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 593,
              "body": "This first sentence seems a bit... obvious. Did this get lost in \"translation\"? What are we actually trying to say? Process serialized JSON / I-JSON / JSON-SEQ qlog?",
              "createdAt": "2023-02-28T16:12:51Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 616,
              "body": "I really wonder if we should keep this kind of thing in here, especially if we don't include any concrete examples anymore. Then we should also remove a similar paragraph up-top when discussing `qlog_format` for the first time. ",
              "createdAt": "2023-02-28T16:14:06Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            },
            {
              "originalPosition": 651,
              "body": "I feel this one can be removed... it's unlikely people will return to this and I don't see much historical value having it in the RFC rather than people looking it up in earlier versions of the drafts themselves. ",
              "createdAt": "2023-02-28T16:15:56Z",
              "updatedAt": "2023-02-28T16:19:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5SzX4P",
          "commit": {
            "abbreviatedOid": "b3ac2d4"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-18T03:04:02Z",
          "updatedAt": "2023-04-18T03:04:03Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "given to is more proper, innit",
              "createdAt": "2023-04-18T03:04:02Z",
              "updatedAt": "2023-04-18T03:04:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5nBXtS",
          "commit": {
            "abbreviatedOid": "9a24e0a"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-13T22:52:25Z",
          "updatedAt": "2023-11-13T22:52:25Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "Spun off to #339 ",
              "createdAt": "2023-11-13T22:52:25Z",
              "updatedAt": "2023-11-13T22:52:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5nBYDv",
          "commit": {
            "abbreviatedOid": "9a24e0a"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-13T22:54:03Z",
          "updatedAt": "2023-11-13T22:54:03Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "Opened #340 ",
              "createdAt": "2023-11-13T22:54:03Z",
              "updatedAt": "2023-11-13T22:54:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5nBabF",
          "commit": {
            "abbreviatedOid": "e1773af"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-13T23:04:30Z",
          "updatedAt": "2023-11-13T23:04:30Z",
          "comments": [
            {
              "originalPosition": 616,
              "body": "Happy to do that but let's track in a followup issue. Created #341 ",
              "createdAt": "2023-11-13T23:04:30Z",
              "updatedAt": "2023-11-13T23:04:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5nBahw",
          "commit": {
            "abbreviatedOid": "e1773af"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-13T23:04:59Z",
          "updatedAt": "2023-11-13T23:04:59Z",
          "comments": [
            {
              "originalPosition": 651,
              "body": "Sure",
              "createdAt": "2023-11-13T23:04:59Z",
              "updatedAt": "2023-11-13T23:04:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5nBdjf",
          "commit": {
            "abbreviatedOid": "e1773af"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-13T23:19:23Z",
          "updatedAt": "2023-11-13T23:19:23Z",
          "comments": [
            {
              "originalPosition": 593,
              "body": "fixed!",
              "createdAt": "2023-11-13T23:19:23Z",
              "updatedAt": "2023-11-13T23:19:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5pqK8j",
          "commit": {
            "abbreviatedOid": "71ab602"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Also needs a pass to reduce line length/add wrapping at a few locations, but other than that and the nits I had, this look good to go. ",
          "createdAt": "2023-12-08T15:41:30Z",
          "updatedAt": "2023-12-08T16:05:53Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Not sure I'm the biggest fan of referring explicitly to the other 2 docs here, since this MAIN doc is supposed to be generic (except maybe for some examples).",
              "createdAt": "2023-12-08T15:41:30Z",
              "updatedAt": "2023-12-08T16:05:53Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\nconsideration when choosing a format. For instance, a textual format like JSON\r\n```",
              "createdAt": "2023-12-08T15:42:08Z",
              "updatedAt": "2023-12-08T16:05:53Z"
            },
            {
              "originalPosition": 120,
              "body": "Now tracked in https://github.com/quicwg/qlog/issues/340",
              "createdAt": "2023-12-08T15:44:04Z",
              "updatedAt": "2023-12-08T16:05:53Z"
            },
            {
              "originalPosition": 193,
              "body": "```suggestion\r\nJSON Text Sequences are very similar to JSON, except that objects are\r\n```",
              "createdAt": "2023-12-08T15:48:14Z",
              "updatedAt": "2023-12-08T16:05:53Z"
            },
            {
              "originalPosition": 225,
              "body": "```suggestion\r\n```\r\n\r\n(duplicates of 2 paragraphs up)",
              "createdAt": "2023-12-08T16:03:05Z",
              "updatedAt": "2023-12-08T16:05:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5pur4X",
          "commit": {
            "abbreviatedOid": "71ab602"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-09T20:12:29Z",
          "updatedAt": "2023-12-09T20:13:02Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Right but it's too wooly to say \"other related schema\" - all extensions of qlog are related to the main schema. So the question becomes are we levying recommendations on additional schema to be generic, or can they make optimization for serialization formats? The latter seems reasonable to me, it's part of tradeoff that we mention in this spec.\r\n\r\n We have two examples that are generic but don't think we can extapolate from that. This might lean towards having a serialization section in each of the documents so that they state if they are generic or specific. I created #357 to track that.",
              "createdAt": "2023-12-09T20:12:30Z",
              "updatedAt": "2023-12-09T20:13:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 290,
      "id": "PR_kwDOCrLn6M5IWoVt",
      "title": "Rework the Timestamps section, add monotonic",
      "url": "https://github.com/quicwg/qlog/pull/290",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Most of what was in here is good but we can tighten it up a bit.\r\n\r\nAfter tightening up, it makes it easier to introduce another TimeFormat\r\n- monotonic - that doesn't use an explicit reference_time.\r\n\r\nAddress the monotic request made in #198 but doesn't resolve the issue completely it because the discussion on clock drift is not expanded. I can add that if we like this direction.\r\n",
      "createdAt": "2023-01-23T19:04:33Z",
      "updatedAt": "2024-10-21T14:22:53Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "148d91306aa96ee6af6e08554cecb6c0e7277b0f",
      "headRepository": "quicwg/qlog",
      "headRefName": "define-monotonic-clock",
      "headRefOid": "a2b9d04fa9f32e5cb051511d27635f2f65f530f8",
      "closedAt": "2024-10-21T14:22:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "also note I removed any specific example of \"privacy-preserving timestamps\". The old example about using system up time seems the antithesis of privacy :smile: ",
          "createdAt": "2023-01-23T19:10:43Z",
          "updatedAt": "2023-01-23T19:10:43Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "As disscussed on the issue and at IETF 116, we'll probably go a different way than this PR. Keeping it open for my own reference but don't merge",
          "createdAt": "2023-05-31T19:55:31Z",
          "updatedAt": "2023-05-31T19:55:31Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Retiring this in favor of #433 ",
          "createdAt": "2024-10-21T14:22:53Z",
          "updatedAt": "2024-10-21T14:22:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5Lj7eG",
          "commit": {
            "abbreviatedOid": "a6bfb9a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-24T15:20:15Z",
          "updatedAt": "2023-01-24T15:20:15Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "```suggestion\r\n  The \"reference_time\" field MUST NOT be applied to this format, since it's based\r\n```",
              "createdAt": "2023-01-24T15:20:15Z",
              "updatedAt": "2023-01-24T15:20:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5Lj8PF",
          "commit": {
            "abbreviatedOid": "a6bfb9a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-24T15:21:50Z",
          "updatedAt": "2023-01-24T15:21:51Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "This whole sentence is hard to understand (I'm not even sure I really grasp it), and the `it's` is ambiguous: is it \"this format\" or \"the reference_time\"?\r\n\r\nOverall, imo this section does not really explain how monotonic is different from relative, nor why it's useful/needed.",
              "createdAt": "2023-01-24T15:21:50Z",
              "updatedAt": "2023-01-24T15:21:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5Lj8gJ",
          "commit": {
            "abbreviatedOid": "a6bfb9a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-24T15:22:22Z",
          "updatedAt": "2023-01-24T15:22:23Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "```suggestion\r\nThere is no default base clock for formats that rely on a shareable clock. Tools\r\n```",
              "createdAt": "2023-01-24T15:22:22Z",
              "updatedAt": "2023-01-24T15:22:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5Lj9oE",
          "commit": {
            "abbreviatedOid": "a6bfb9a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-24T15:24:39Z",
          "updatedAt": "2023-01-24T15:24:39Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "This is also a bit vague... what exactly is a \"shareable clock\", terminology not used before this. Does it mean sharing the same clock across traces (e.g., one taken at the server, one at the client, later combined?) or does it mean deriving timing values from a single clock reading (i.e., relative and delta). I assume the latter, but the quiche PR that triggered this is mainly talking about the former? ",
              "createdAt": "2023-01-24T15:24:39Z",
              "updatedAt": "2023-01-24T15:24:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5Lj93h",
          "commit": {
            "abbreviatedOid": "a6bfb9a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-24T15:25:09Z",
          "updatedAt": "2023-01-24T15:25:09Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "```suggestion\r\ntraces. Tools should not rely on timestamps to be consistent across traces, even\r\n```",
              "createdAt": "2023-01-24T15:25:09Z",
              "updatedAt": "2023-01-24T15:25:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5Lj_M3",
          "commit": {
            "abbreviatedOid": "a6bfb9a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I largely agree with the rewrites of the existing text.\r\n\r\nI however don't really see the need for the `monotonic` format. The text doesn't explain why it's useful, nor can I really find good arguments for it in the quiche PRs besides \"clock drift\". \r\n\r\nIIUC, monotonic is still a kind of relative, but you can't assume the events arrived at exactly `reference_time` + `time` milliseconds. That's fine, but then we should imo just say something general about all formats like:\r\n\r\n`timestamp values aren't always perfectly accurate, due to clock drift, implementation limitations, privacy or security considerations. They are only guaranteed to be monotonically increasing.`\r\n\r\nThat imo covers the load for the 3 existing formats, and allows you to use `relative` with a `reference_time` of 0 for monotonic (which, IIUC, is what quiche has been doing?)\r\n",
          "createdAt": "2023-01-24T15:27:54Z",
          "updatedAt": "2023-01-24T15:33:35Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "This enforces my confusion about why `monotonic` is needed and how it's different from `relative`... \r\n\r\nThe way I understand it is that monotonic does not necessarily adhere to milliseconds between events? \r\nSo say the relative values would be \r\n`0, 5, 22, 88`\r\n\r\nThen the monotonic ones for the same absolute event timestamps could be\r\n`0, 4, 17, 94`\r\n(due to clock drift, intentional fuzzing for privacy/timing attacks, etc.)\r\n\r\nIf that's true, the examples should reflect this better. ",
              "createdAt": "2023-01-24T15:27:57Z",
              "updatedAt": "2023-01-24T15:32:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5LkIPf",
          "commit": {
            "abbreviatedOid": "a6bfb9a"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-24T15:46:46Z",
          "updatedAt": "2023-01-24T15:46:46Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Yeah I'm not a fan of the word shareable here but struggled to find a suitable term. This is really just intended to be a rewording pf the old text that was focussed on unix-y time. If folks are using an abosulute timestamp, somewhere they should be indicating the actual format and rules for that, including where its epoch is anchored. Saying \"you don't have to use UNIX time\" like the old text is glossing over a lot of complexity.\r\n\r\nHappy to rewrite this part if we can agree on what should be communicated.",
              "createdAt": "2023-01-24T15:46:46Z",
              "updatedAt": "2023-01-24T15:46:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5LkSBH",
          "commit": {
            "abbreviatedOid": "537d75e"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-24T16:07:58Z",
          "updatedAt": "2023-01-24T16:07:59Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "Relative and monotonic are both formats that use a delta encoding but that's where the similarity ends.\r\n\r\nPer the current definition of reference format, it has to be related to something that various systems can agree on. For example, sticking January 1 2023 in all my logs and logging the duration in seconds since that date would work for a reference time. Ideally, you understand what that date is, so that you can add the time deltas in order determine their absolute timestamp. It is important to agree on a calendaring or date/time system because things like leap seconds, daylight savings, or clock skew can mean your relative-time event has negative values. This makes sorting qlogs fun.\r\n\r\nWith monotonic clocks, there is no universal calendaring or date/time. A system picks _something_ and you can  then calculate durations against that. As long a single system generates events, the durations are guaranteed to never decrement. See for example https://linux.die.net/man/3/clock_gettime where\r\n\r\n> CLOCK_MONOTONIC\r\nClock that cannot be set and represents monotonic time since some unspecified starting point.\r\n\r\nSo one core difference is that reference can be negative and montonic can never.  So the reference example might want to include that.\r\n\r\nAnother core difference is that monotonic typically has no reference_time that can be communicated meaningfully. Its literally not possible to obtain it on such systems.\r\n\r\nwe could make the monotonic values different for the sake of it, if it helps avoid confusion.",
              "createdAt": "2023-01-24T16:07:58Z",
              "updatedAt": "2023-01-24T16:07:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5LkTHQ",
          "commit": {
            "abbreviatedOid": "537d75e"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-24T16:10:28Z",
          "updatedAt": "2023-01-24T16:10:29Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n  The \"reference_time\" field MUST NOT be applied to this format, since monotonic\r\n  time is measured against an opaque clock that cannot be interpreted beyond the system that\r\n```",
              "createdAt": "2023-01-24T16:10:28Z",
              "updatedAt": "2023-01-24T16:10:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5LkUJW",
          "commit": {
            "abbreviatedOid": "a6bfb9a"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-24T16:12:45Z",
          "updatedAt": "2023-01-24T16:12:46Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I tried to clarify the sentence to make it clear what it being measured.\r\n\r\nBeyond that, I'm not sure how to more clearly describe that `relative` and `monotonic` are different. The monotonic description is succinct. So the relative format probably needs more wordsmithing for preciseness, rather than have people making assumptions.",
              "createdAt": "2023-01-24T16:12:46Z",
              "updatedAt": "2023-01-24T16:12:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 291,
      "id": "PR_kwDOCrLn6M5LDENH",
      "title": "Update description of datagram_id usage",
      "url": "https://github.com/quicwg/qlog/pull/291",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #281",
      "createdAt": "2023-03-01T16:20:58Z",
      "updatedAt": "2023-03-02T09:57:37Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "47c4c28d9262018206bcfc7a5d541b2c85bf3c3b",
      "headRepository": "quicwg/qlog",
      "headRefName": "clarify-datagramid",
      "headRefOid": "5db90c2d29cc61ff3c376af271066ed5b174e8f2",
      "closedAt": "2023-03-02T09:57:37Z",
      "mergedAt": "2023-03-02T09:57:37Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "71ebbfe8367fa5806d27ec0b7f0703aace203eac"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "rebase on main should fix the cddl tests",
          "createdAt": "2023-03-01T18:50:38Z",
          "updatedAt": "2023-03-01T18:50:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5OsYdj",
          "commit": {
            "abbreviatedOid": "948bec5"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T16:56:11Z",
          "updatedAt": "2023-03-01T16:56:12Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nSelecting identifier values is thus left to qlog implementations, which should\r\n```",
              "createdAt": "2023-03-01T16:56:11Z",
              "updatedAt": "2023-03-01T16:56:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5OshgT",
          "commit": {
            "abbreviatedOid": "948bec5"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM modulo nit",
          "createdAt": "2023-03-01T17:17:10Z",
          "updatedAt": "2023-03-01T17:17:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 292,
      "id": "PR_kwDOCrLn6M5LDSzf",
      "title": "bump CDDL workflow ubuntu version",
      "url": "https://github.com/quicwg/qlog/pull/292",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-01T17:03:07Z",
      "updatedAt": "2023-03-01T17:09:06Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "47c4c28d9262018206bcfc7a5d541b2c85bf3c3b",
      "headRepository": "quicwg/qlog",
      "headRefName": "bump-cddl-ubuntu",
      "headRefOid": "a0009ebaf7a73679f90a25fcb6f98f0f9d95abc0",
      "closedAt": "2023-03-01T17:09:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 293,
      "id": "PR_kwDOCrLn6M5LDVMP",
      "title": "Update cddl_validate.yml",
      "url": "https://github.com/quicwg/qlog/pull/293",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-01T17:10:00Z",
      "updatedAt": "2023-03-01T18:50:13Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "47c4c28d9262018206bcfc7a5d541b2c85bf3c3b",
      "headRepository": "quicwg/qlog",
      "headRefName": "bump-cddl-ubuntu",
      "headRefOid": "c070dcac36337ab4df5df28ea9812a84d3963875",
      "closedAt": "2023-03-01T18:50:13Z",
      "mergedAt": "2023-03-01T18:50:13Z",
      "mergedBy": "lnicco",
      "mergeCommit": {
        "oid": "91bd4b71ee1e3b29f9353f735fb436fc5b2d41ce"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5Os9Nq",
          "commit": {
            "abbreviatedOid": "c070dca"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-01T18:32:33Z",
          "updatedAt": "2023-03-01T18:32:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5OtDZ_",
          "commit": {
            "abbreviatedOid": "c070dca"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "thanks! ",
          "createdAt": "2023-03-01T18:49:39Z",
          "updatedAt": "2023-03-01T18:49:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 294,
      "id": "PR_kwDOCrLn6M5M4wIy",
      "title": "key_updated: don't require logging the actual key",
      "url": "https://github.com/quicwg/qlog/pull/294",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #52.",
      "createdAt": "2023-03-25T06:50:42Z",
      "updatedAt": "2023-10-18T11:13:35Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "e226e9f92fcadd0b9ff3a30bbfe3d61ea47c7bb8",
      "headRepository": "quicwg/qlog",
      "headRefName": "key-updated-no-key-logging",
      "headRefOid": "d6609b29d63913090e97e2e53df78ef6c86de00d",
      "closedAt": "2023-10-18T11:13:34Z",
      "mergedAt": "2023-10-18T11:13:34Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "6f8eb826a380beb0619662c6b9d956d49cb8822f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5Q7jIw",
          "commit": {
            "abbreviatedOid": "d6609b2"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-25T07:01:52Z",
          "updatedAt": "2023-03-25T07:01:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 296,
      "id": "PR_kwDOCrLn6M5M4ziq",
      "title": "Make HTTPField name optional",
      "url": "https://github.com/quicwg/qlog/pull/296",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-25T07:57:52Z",
      "updatedAt": "2023-05-31T19:53:22Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "e226e9f92fcadd0b9ff3a30bbfe3d61ea47c7bb8",
      "headRepository": "quicwg/qlog",
      "headRefName": "lucas/field-name-optional",
      "headRefOid": "aa2dbbf02d665a9fd121278814d076a282cbc0fc",
      "closedAt": "2023-05-31T19:53:22Z",
      "mergedAt": "2023-05-31T19:53:22Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "e23666f50fca058502b27ac44448ca5167fa3f1d"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Fixes #295 ",
          "createdAt": "2023-03-25T07:59:02Z",
          "updatedAt": "2023-03-25T07:59:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5Q7k1m",
          "commit": {
            "abbreviatedOid": "a3b0915"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-03-25T08:03:54Z",
          "updatedAt": "2023-03-25T08:04:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n    ? value: text\r\n```",
              "createdAt": "2023-03-25T08:03:54Z",
              "updatedAt": "2023-03-25T08:04:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 298,
      "id": "PR_kwDOCrLn6M5Qdau2",
      "title": "CDDL: use consistent spacing",
      "url": "https://github.com/quicwg/qlog/pull/298",
      "state": "MERGED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a re-do of #253 ",
      "createdAt": "2023-05-14T20:00:21Z",
      "updatedAt": "2023-05-16T18:16:55Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "e226e9f92fcadd0b9ff3a30bbfe3d61ea47c7bb8",
      "headRepository": "quicwg/qlog",
      "headRefName": "cddl_consistent_spacing",
      "headRefOid": "a2f2e4c5477fd35208b3b923f0828b76557ee642",
      "closedAt": "2023-05-16T17:29:52Z",
      "mergedAt": "2023-05-16T17:29:52Z",
      "mergedBy": "lnicco",
      "mergeCommit": {
        "oid": "6e4d304f5765bedb4bc5a137eafe9bb816fe1013"
      },
      "comments": [
        {
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "body": "> It's 99.9 % correct. Lets merge soon to avoid bitrot again\r\n\r\nIterated on #299. \r\nLet me know if I caught all the missing ones or if there are more",
          "createdAt": "2023-05-16T18:16:54Z",
          "updatedAt": "2023-05-16T18:16:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5VJS0n",
          "commit": {
            "abbreviatedOid": "a2f2e4c"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "It's 99.9 % correct. Lets merge soon to avoid bitrot again",
          "createdAt": "2023-05-16T12:47:25Z",
          "updatedAt": "2023-05-16T12:47:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 299,
      "id": "PR_kwDOCrLn6M5QpDDX",
      "title": "Add more whitespaces after CDDL comment lines (continues #298)",
      "url": "https://github.com/quicwg/qlog/pull/299",
      "state": "MERGED",
      "author": "lnicco",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-16T18:15:47Z",
      "updatedAt": "2023-05-16T20:20:26Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "9dc6d24f0f60223edccf1c2ce805b3f299d26e79",
      "headRepository": "quicwg/qlog",
      "headRefName": "moar_whitespaces",
      "headRefOid": "046fea6b32d56056ec480c503351093b45572f62",
      "closedAt": "2023-05-16T20:20:26Z",
      "mergedAt": "2023-05-16T20:20:26Z",
      "mergedBy": "lnicco",
      "mergeCommit": {
        "oid": "be1b50fa6e5046a62b0914e7db4cb81d4ee848ee"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5VL4pZ",
          "commit": {
            "abbreviatedOid": "046fea6"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Its a trivial problem. Let's just merge this as is and fixup any stragglers if and when we find any.\r\n\r\n",
          "createdAt": "2023-05-16T18:33:27Z",
          "updatedAt": "2023-05-16T18:33:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5VMaag",
          "commit": {
            "abbreviatedOid": "046fea6"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-16T20:01:18Z",
          "updatedAt": "2023-05-16T20:01:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 300,
      "id": "PR_kwDOCrLn6M5Q2ga3",
      "title": "Move HTTP/3 events and their related data to their own prefix",
      "url": "https://github.com/quicwg/qlog/pull/300",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Since most of these events are HTTP/3 specific, lets just rename them to\r\nuse an H3 prefix.\r\n\r\nThe one exception is `HTTPField` because it is actually aligned to HTTP\r\nSemantics rather than any particular wire format.\r\n\r\nAlternative to #287 because it got bitrot and conflicted.\r\n\r\nFixes #286\r\n",
      "createdAt": "2023-05-19T01:25:08Z",
      "updatedAt": "2023-05-31T19:51:42Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "be1b50fa6e5046a62b0914e7db4cb81d4ee848ee",
      "headRepository": "quicwg/qlog",
      "headRefName": "http-stop-squatting-2",
      "headRefOid": "fb5d0bad266b472a3f955b8ab307c30318b8d4db",
      "closedAt": "2023-05-31T19:51:37Z",
      "mergedAt": "2023-05-31T19:51:37Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "79c31fccc904e6c498fb78dd389070161312ef2a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5Wqg0x",
          "commit": {
            "abbreviatedOid": "810de27"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-31T19:16:08Z",
          "updatedAt": "2023-05-31T19:16:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "whoops\r\n```suggestion\r\nconvention: hh3 ({{h3-ev}}) and qpack ({{qpack-ev}}).\r\n```\r\n\r\n```suggestion\r\nconvention: h3 ({{h3-ev}}) and qpack ({{qpack-ev}}).\r\n```",
              "createdAt": "2023-05-31T19:16:08Z",
              "updatedAt": "2023-05-31T19:16:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 302,
      "id": "PR_kwDOCrLn6M5Q2ifh",
      "title": "Rename QUIC 'transport' events to 'quic'",
      "url": "https://github.com/quicwg/qlog/pull/302",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Since the events are QUIC specific, the intention is to avoid ambiguity by using a QUIC label. It reads a little janky in places but I think that highlights the areas where we already know there's jank. For example, the old `TransportDatagramsSent` was about UDP datagrams not QUIC datagrams. It's new name, `QUICDatagramsSent` risks confusion with QUIC DATAGRAM frames. I do not want to fix that jank in this PR though, since it already existed,",
      "createdAt": "2023-05-19T01:40:34Z",
      "updatedAt": "2023-05-31T19:13:13Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "be1b50fa6e5046a62b0914e7db4cb81d4ee848ee",
      "headRepository": "quicwg/qlog",
      "headRefName": "transport-to-quic-category",
      "headRefOid": "337d3d6ac4ad40d0ae636bfa07159a78cfb5f3e3",
      "closedAt": "2023-05-31T19:13:09Z",
      "mergedAt": "2023-05-31T19:13:09Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "8c0e115d0e2ca7d058a61438d69939351bc9c411"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5WqXOm",
          "commit": {
            "abbreviatedOid": "337d3d6"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-31T18:53:59Z",
          "updatedAt": "2023-05-31T18:53:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5WqYQZ",
          "commit": {
            "abbreviatedOid": "337d3d6"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-31T18:55:37Z",
          "updatedAt": "2023-05-31T18:55:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 303,
      "id": "PR_kwDOCrLn6M5R1IGs",
      "title": "remove use of \"we\" and \"our\"",
      "url": "https://github.com/quicwg/qlog/pull/303",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This touches text that we might later decide to remove but lets just fix\nthe low hanging fruit in an easy pass.\n\nFixes #233\n",
      "createdAt": "2023-05-31T20:31:27Z",
      "updatedAt": "2023-06-07T13:55:30Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "e23666f50fca058502b27ac44448ca5167fa3f1d",
      "headRepository": "quicwg/qlog",
      "headRefName": "there-is-no-we-in-ietf-but-there-is-an-I",
      "headRefOid": "121f2f093224d1626121472c37c320cc55b8f626",
      "closedAt": "2023-06-07T13:55:25Z",
      "mergedAt": "2023-06-07T13:55:25Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "9d51d8ee9e72fed9f5131aeeff557723ce595dbf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5WrA0a",
          "commit": {
            "abbreviatedOid": "ff54970"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-31T20:35:58Z",
          "updatedAt": "2023-05-31T20:37:29Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "```suggestion\r\nThere are several ways of defining qlog events. In practice, two main\r\n```",
              "createdAt": "2023-05-31T20:35:59Z",
              "updatedAt": "2023-05-31T20:37:30Z"
            },
            {
              "originalPosition": 93,
              "body": "Not 100% sure about this one\r\n```suggestion\r\ntypes of approaches have been observed: a) those that map directly to concepts seen in the protocols\r\n```",
              "createdAt": "2023-05-31T20:36:27Z",
              "updatedAt": "2023-05-31T20:37:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5WrJW4",
          "commit": {
            "abbreviatedOid": "ff54970"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-31T20:57:51Z",
          "updatedAt": "2023-05-31T20:57:51Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "I'll skip this one. The RFC editor can be the grammar police in case I'm wrong and I'll owe you a donut.",
              "createdAt": "2023-05-31T20:57:51Z",
              "updatedAt": "2023-05-31T20:57:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 304,
      "id": "PR_kwDOCrLn6M5R1PvT",
      "title": "Remove 99% of Notes:",
      "url": "https://github.com/quicwg/qlog/pull/304",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Most of these are real simple. Some remain, either because I\nthink they are being touched by other PRs or I didn't want to\nspend time thinking about them.\n",
      "createdAt": "2023-05-31T20:54:06Z",
      "updatedAt": "2023-06-07T13:56:37Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "e23666f50fca058502b27ac44448ca5167fa3f1d",
      "headRepository": "quicwg/qlog",
      "headRefName": "note-well-no-note-it-makes-me-unwell",
      "headRefOid": "a7369397478a18dd3b1128ba5b9eaac79404caca",
      "closedAt": "2023-06-07T13:56:33Z",
      "mergedAt": "2023-06-07T13:56:33Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "87a926b0f60c3960184a2dd9ad8b535e3da50dc1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5WtTf5",
          "commit": {
            "abbreviatedOid": "a736939"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-01T06:55:15Z",
          "updatedAt": "2023-06-01T06:55:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 305,
      "id": "PR_kwDOCrLn6M5Up00q",
      "title": "Add optional sys_info field to events",
      "url": "https://github.com/quicwg/qlog/pull/305",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #152 by adding a field to capture information related to CPUs or\nthreads.\n",
      "createdAt": "2023-07-05T00:41:04Z",
      "updatedAt": "2023-07-05T18:11:25Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "87a926b0f60c3960184a2dd9ad8b535e3da50dc1",
      "headRepository": "quicwg/qlog",
      "headRefName": "add-hardware-related-fields",
      "headRefOid": "0444d7cb909dbd507f5dd04db95022c9c8be3d85",
      "closedAt": "2023-07-05T18:11:22Z",
      "mergedAt": "2023-07-05T18:11:22Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "13e1a123e24240dd9cf007b92ddf8de5c6b902b8"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "cc @nibanks ",
          "createdAt": "2023-07-05T00:41:35Z",
          "updatedAt": "2023-07-05T00:41:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aNpH2",
          "commit": {
            "abbreviatedOid": "7c667af"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-07-05T01:12:43Z",
          "updatedAt": "2023-07-05T01:12:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5aNpGZ",
          "commit": {
            "abbreviatedOid": "7c667af"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-05T01:12:30Z",
          "updatedAt": "2023-07-05T01:13:03Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "This only works if the QUIC stack is single-threaded. Is that a reasonable assumption?",
              "createdAt": "2023-07-05T01:12:30Z",
              "updatedAt": "2023-07-05T01:13:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aNyfS",
          "commit": {
            "abbreviatedOid": "7c667af"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T02:20:12Z",
          "updatedAt": "2023-07-05T02:20:12Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "How so? From the discussion on #152, it seemed fine to have events in the same logical trace that had different thread IDs?\r\n\r\nIf it seems I'm preventing that in this propsal, I'd like to fix it up so all suggestions welcome.",
              "createdAt": "2023-07-05T02:20:12Z",
              "updatedAt": "2023-07-05T02:20:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aRWQb",
          "commit": {
            "abbreviatedOid": "7c667af"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Minus the small nit. ",
          "createdAt": "2023-07-05T13:16:16Z",
          "updatedAt": "2023-07-05T13:18:23Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThe \"system_info\" field can be used to record system-specific details related to an\r\n```\r\n\r\nconsistency with line 571 above",
              "createdAt": "2023-07-05T13:16:16Z",
              "updatedAt": "2023-07-05T13:18:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aRX7r",
          "commit": {
            "abbreviatedOid": "7c667af"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T13:18:40Z",
          "updatedAt": "2023-07-05T13:18:40Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I agree with Lucas here, as also discussed on the original issue. ",
              "createdAt": "2023-07-05T13:18:40Z",
              "updatedAt": "2023-07-05T13:18:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aS-te",
          "commit": {
            "abbreviatedOid": "7c667af"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T16:34:03Z",
          "updatedAt": "2023-07-05T16:34:03Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "oops",
              "createdAt": "2023-07-05T16:34:03Z",
              "updatedAt": "2023-07-05T16:34:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 306,
      "id": "PR_kwDOCrLn6M5Up4FQ",
      "title": "Tidy up RecoveryPacketLost text",
      "url": "https://github.com/quicwg/qlog/pull/306",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-05T01:08:20Z",
      "updatedAt": "2023-07-05T13:16:50Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "87a926b0f60c3960184a2dd9ad8b535e3da50dc1",
      "headRepository": "quicwg/qlog",
      "headRefName": "tremendous",
      "headRefOid": "a7c7e7a70eed52d1c8706da0b073bcda175b9545",
      "closedAt": "2023-07-05T13:16:46Z",
      "mergedAt": "2023-07-05T13:16:46Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "0269610bc5d379a8bad039192058a891cf92a3f6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aNo8p",
          "commit": {
            "abbreviatedOid": "a7c7e7a"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-05T01:11:01Z",
          "updatedAt": "2023-07-05T01:11:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5aRRM_",
          "commit": {
            "abbreviatedOid": "a7c7e7a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-05T13:06:12Z",
          "updatedAt": "2023-07-05T13:06:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 307,
      "id": "PR_kwDOCrLn6M5Up8nW",
      "title": "Support packet multiplicity in frames_processed",
      "url": "https://github.com/quicwg/qlog/pull/307",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #168\n",
      "createdAt": "2023-07-05T01:46:06Z",
      "updatedAt": "2023-07-05T18:19:22Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "87a926b0f60c3960184a2dd9ad8b535e3da50dc1",
      "headRepository": "quicwg/qlog",
      "headRefName": "frames-processed-over-multiple-packets",
      "headRefOid": "a34f47787637223d1ccf401002210d8702cb9849",
      "closedAt": "2023-07-05T18:19:19Z",
      "mergedAt": "2023-07-05T18:19:19Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "54091f6f8c2ed85a8e7ca920d925c3b098079b05"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aRZqN",
          "commit": {
            "abbreviatedOid": "a14c1d9"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-07-05T13:20:35Z",
          "updatedAt": "2023-07-05T13:23:38Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n    ? packet_numbers: [* uint64]\r\n```\r\n\r\nFor consistency with existing events like `packets_acked` and partially the `datagram_*` events that talk about `datagram_ids` not `datagram_id`",
              "createdAt": "2023-07-05T13:20:35Z",
              "updatedAt": "2023-07-05T13:23:38Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nalso contains the packet_numbers field, which can be used to more explicitly\r\n```",
              "createdAt": "2023-07-05T13:20:50Z",
              "updatedAt": "2023-07-05T13:23:38Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nof entries in the \"frames\" and \"packet_numbers\" is used. If the optional \"packet_numbers\"\r\n```",
              "createdAt": "2023-07-05T13:21:28Z",
              "updatedAt": "2023-07-05T13:23:38Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\n\"packet_numbers\":[\r\n```",
              "createdAt": "2023-07-05T13:22:02Z",
              "updatedAt": "2023-07-05T13:23:38Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n  {\"frame_type\":\"stream\",\"stream_id\":0,\"offset\":0,\"length\":500},\r\n  {\"frame_type\":\"stream\",\"stream_id\":0,\"offset\":500,\"length\":200},\r\n  {\"frame_type\":\"stream\",\"stream_id\":1,\"offset\":0,\"length\":300},\r\n  {\"frame_type\":\"stream\",\"stream_id\":1,\"offset\":300,\"length\":50}\r\n```\r\nMaking the number more different between the two streams to more clearly differentiate them + make the example slightly more realistic.",
              "createdAt": "2023-07-05T13:23:33Z",
              "updatedAt": "2023-07-05T13:23:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aTlDG",
          "commit": {
            "abbreviatedOid": "a34f477"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "looks good to me",
          "createdAt": "2023-07-05T18:14:24Z",
          "updatedAt": "2023-07-05T18:14:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 308,
      "id": "PR_kwDOCrLn6M5Up9z9",
      "title": "Remove Configuration and Summary fields",
      "url": "https://github.com/quicwg/qlog/pull/308",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See #187 for explanation about the motivation. We could possibly be less\nlethal and add some colour commentary about how applications could\ncapture details in their own optional fields but I think that's pretty\nobvious from the extensible nature of the format.\n\nCloses #187\n",
      "createdAt": "2023-07-05T01:55:45Z",
      "updatedAt": "2023-07-05T18:31:19Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "87a926b0f60c3960184a2dd9ad8b535e3da50dc1",
      "headRepository": "quicwg/qlog",
      "headRefName": "byebye-configuration-and-summary",
      "headRefOid": "52996dda1002c29e1c3550a72fc9fd70d5feff35",
      "closedAt": "2023-07-05T18:30:35Z",
      "mergedAt": "2023-07-05T18:30:35Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "4b8d1f77989d708eb63359712af9671737b01380"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aRcy1",
          "commit": {
            "abbreviatedOid": "52996dd"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-05T13:25:10Z",
          "updatedAt": "2023-07-05T13:25:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5aTJba",
          "commit": {
            "abbreviatedOid": "52996dd"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-05T16:58:56Z",
          "updatedAt": "2023-07-05T16:58:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 310,
      "id": "PR_kwDOCrLn6M5UtWei",
      "title": "Add QUIC and HTTP/3 DATAGRAM frame definitions",
      "url": "https://github.com/quicwg/qlog/pull/310",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed at IETF 115 and 116, we will add support for most RFC-status QUIC and HTTP/3 extensions to the main documents.\r\n\r\nThis PR adds our intended support for RFCs 9221 and 9297. Note that this does NOT include full support for those entire documents. Specifically, we only add the QUIC and H3 DATAGRAM frames, not the full \"capsule protocol\", which was deemed out of scope for the core qlog documents. \r\n\r\nThese changes were originally part of a separate document at https://github.com/rmarx/draft-marx-quic-qlog-datagram, which is now deprecated. ",
      "createdAt": "2023-07-05T14:03:02Z",
      "updatedAt": "2023-07-06T14:54:37Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "43e552efafe7c0c962ecd38a26249b8adfc49bcb",
      "headRepository": "quicwg/qlog",
      "headRefName": "qlog-datagram-extension",
      "headRefOid": "92825c5980e84a21cd786466afc47469092ff554",
      "closedAt": "2023-07-06T14:54:36Z",
      "mergedAt": "2023-07-06T14:54:36Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "e55ba43a6ecbbfe2d8bd483241fbf9c183740501"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The QUIC frame is good. Howvever, in HTTP/3, there is not an actual datagram frame being exchanged. I think we need separate events such as \"H3DatagramCreated\" and \"H3DatagramParsed\"",
          "createdAt": "2023-07-05T14:34:13Z",
          "updatedAt": "2023-07-05T14:34:13Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Lets try and resolve https://github.com/quicwg/qlog/issues/178 in this PR",
          "createdAt": "2023-07-05T14:35:37Z",
          "updatedAt": "2023-07-05T14:35:37Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The QUIC frame is good. Howvever, in HTTP/3, there is not an actual datagram frame being exchanged. I think we need separate events such as \"H3DatagramCreated\" and \"H3DatagramParsed\"\r\n\r\nDiscussed on call: replace with something like this:\r\n\r\n```\r\nH3DatagramParsed = {\r\n    quarter_stream_id: uint64\r\n    \r\n    ? payload: $H3DatagramPayload\r\n    ? raw: RawInfo\r\n}\r\n\r\n$H3DatagramPayload = any\r\n```\r\n\r\n",
          "createdAt": "2023-07-05T18:19:25Z",
          "updatedAt": "2023-07-05T18:19:25Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Lets try and resolve #178 in this PR\r\n\r\nAs discussed in the call, we'll go for option 3 there:\r\n\r\n> Be more clear that data_moved is only for stream data.Then possibly:\r\n> a) rename the event to stream_data_moved\r\n> b) add a new datagram_data_moved event",
          "createdAt": "2023-07-05T18:27:16Z",
          "updatedAt": "2023-07-05T18:27:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aR_h9",
          "commit": {
            "abbreviatedOid": "54487b1"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T14:28:07Z",
          "updatedAt": "2023-07-05T14:28:07Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "stylistically, I'd put the datagram one directly after max push ID",
              "createdAt": "2023-07-05T14:28:07Z",
              "updatedAt": "2023-07-05T14:28:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aSBkE",
          "commit": {
            "abbreviatedOid": "54487b1"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T14:31:46Z",
          "updatedAt": "2023-07-05T14:31:47Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "actually see my other comment on the issue",
              "createdAt": "2023-07-05T14:31:46Z",
              "updatedAt": "2023-07-05T14:31:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aTFw2",
          "commit": {
            "abbreviatedOid": "54487b1"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T16:52:44Z",
          "updatedAt": "2023-07-05T16:52:45Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "NIT: Which other extensions are we planning to bake into the main document? \r\nShould this paragraph list them all or should it say \"and the H3 Datagram extension\"?",
              "createdAt": "2023-07-05T16:52:45Z",
              "updatedAt": "2023-07-05T16:52:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aTIl4",
          "commit": {
            "abbreviatedOid": "54487b1"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T16:57:24Z",
          "updatedAt": "2023-07-05T16:57:24Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "should this have its own type with max 2^60-1 ?\r\nI guess we don't do that for other fields e.g. the ones encoded with a QUIC Integer",
              "createdAt": "2023-07-05T16:57:24Z",
              "updatedAt": "2023-07-05T16:57:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aTm7H",
          "commit": {
            "abbreviatedOid": "54487b1"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T18:19:29Z",
          "updatedAt": "2023-07-05T18:19:30Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "actually thinking more about this, I think it's better to keep the full range. \r\nThis way it would be easier to spot if an implementation is not using the id correctly ",
              "createdAt": "2023-07-05T18:19:30Z",
              "updatedAt": "2023-07-05T18:19:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aToDQ",
          "commit": {
            "abbreviatedOid": "54487b1"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T18:22:31Z",
          "updatedAt": "2023-07-05T18:22:31Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "As discussed: will indeed list them all once individual PRs are merged (prevent merge conflicts).",
              "createdAt": "2023-07-05T18:22:31Z",
              "updatedAt": "2023-07-05T18:22:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aZzVi",
          "commit": {
            "abbreviatedOid": "7463d9d"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-07-06T14:40:58Z",
          "updatedAt": "2023-07-06T14:40:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 311,
      "id": "PR_kwDOCrLn6M5Utg_-",
      "title": "Add definitions for RFC9287 (QUIC GREASE Bit extension)",
      "url": "https://github.com/quicwg/qlog/pull/311",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adds support for [RFC 9287](https://www.rfc-editor.org/rfc/rfc9287.html).\r\n\r\nThere were two possible approaches to the design:\r\n1. what I have done now (add it as a field in the `PacketHeader`)\r\n2. add it in a separate event like `spin_bit_updated`\r\n\r\nWhile 2. might seem the more consistent option, I think 1. actually makes more sense here. For the Spin bit, you will usually have a long streak of packets/events with the spin bit set to a certain value, so an event only when it updates makes sense.\r\n\r\nFor the GREASE bit, you can/should have unpredictable values on a per-packet basis, so this could lead to very verbose update events.",
      "createdAt": "2023-07-05T14:26:51Z",
      "updatedAt": "2023-07-06T10:32:40Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "0269610bc5d379a8bad039192058a891cf92a3f6",
      "headRepository": "quicwg/qlog",
      "headRefName": "qlog-greasebit-extension",
      "headRefOid": "9d7a2c3bd88777221392dc0eae4543b313c23045",
      "closedAt": "2023-07-06T10:32:40Z",
      "mergedAt": "2023-07-06T10:32:40Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "0ff6c8ed961c9f6cb5082c303168e6b9b0609a65"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aSJLN",
          "commit": {
            "abbreviatedOid": "b6a0acb"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-05T14:44:54Z",
          "updatedAt": "2023-07-05T14:44:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5aSK1X",
          "commit": {
            "abbreviatedOid": "b6a0acb"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T14:47:53Z",
          "updatedAt": "2023-07-05T14:47:53Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I'd remove this comment because I find it confusing. The QUIC bit is part of the invariants, it's value is determined by QUIC version and/or extension. As RFC 9287 highlights, there could be other reasons that QUIC-using apps decide to set it to `0`",
              "createdAt": "2023-07-05T14:47:53Z",
              "updatedAt": "2023-07-05T14:47:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aTDq-",
          "commit": {
            "abbreviatedOid": "b6a0acb"
          },
          "author": "lnicco",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-05T16:47:41Z",
          "updatedAt": "2023-07-05T16:47:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5aTrbX",
          "commit": {
            "abbreviatedOid": "b6a0acb"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T18:31:19Z",
          "updatedAt": "2023-07-05T18:31:20Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Agreed on the call: remove this",
              "createdAt": "2023-07-05T18:31:19Z",
              "updatedAt": "2023-07-05T18:31:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 312,
      "id": "PR_kwDOCrLn6M5Ut3pl",
      "title": "Add definitions for RFC9218 (HTTP extensible prioritizations)",
      "url": "https://github.com/quicwg/qlog/pull/312",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This adds support for the HTTP/3 part of [RFC9218](https://www.rfc-editor.org/rfc/rfc9218.html). Note that it doesn't add explicit support for communicating the priority field, since that's covered by the existing `H3HeadersFrame` and `H3HTTPField` definitions.\r\n\r\nBesides the new `PRIORITY_UPDATE` frame, this also includes a separate event `H3PriorityUpdated`. This event is not *strictly* necessary (you could deduce the necessary information from the defaults in the drafts, HEADERS and PRIORITY_UPDATE frame contents as well), but to be in-line with the general qlog approach and because it's useful when debugging priorities to have this information \"in 1 place\", I decided to add the event.\r\n\r\nThe proposed design for PRIORITY_UPDATE is somewhat far removed from the raw wire image in RFC9218, but I feel this approach is clearer to understand and also easier to extend to an event like `H3PriorityUpdated`. An alternative which is closer to the RFC text could be the following, but that's more difficult and less qlog-esque imo:\r\n\r\n```\r\nH3PriorityUpdateFrame = {\r\n    frame_type: \"priority_update\"\r\n    stream_type: \"request\" / \"push\"\r\n    prioritized_element_id: uint64\r\n    \r\n    priority_field_value: text\r\n}\r\n```\r\n\r\n",
      "createdAt": "2023-07-05T15:20:50Z",
      "updatedAt": "2023-07-06T14:59:08Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "e55ba43a6ecbbfe2d8bd483241fbf9c183740501",
      "headRepository": "quicwg/qlog",
      "headRefName": "qlog-prioritization-extension",
      "headRefOid": "64e7c9e583430e6eface88d050815c0ffcbcce7f",
      "closedAt": "2023-07-06T14:59:08Z",
      "mergedAt": "2023-07-06T14:59:07Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "57e9af087f4e202e77b553c9f6c80a85a11426d7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aSory",
          "commit": {
            "abbreviatedOid": "5220757"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T15:44:10Z",
          "updatedAt": "2023-07-05T15:44:10Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "The text implies this is closely correlated to the signals, more so because it says `specifically` but actually I think its useful to also reflect internal decision making. For instance, a server that receives a client signal and selects a different priority due to local policy or behaviour.\r\n\r\nAlso I wonder if the intention is to have a client log two events, one when it sends a signal, and another one if a server responds with a different signal value.\r\n\r\n",
              "createdAt": "2023-07-05T15:44:10Z",
              "updatedAt": "2023-07-05T15:44:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aSpbw",
          "commit": {
            "abbreviatedOid": "5220757"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T15:45:53Z",
          "updatedAt": "2023-07-05T15:47:47Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```suggestion\r\n    ; if the prioritized element is a request stream\r\n```",
              "createdAt": "2023-07-05T15:45:53Z",
              "updatedAt": "2023-07-05T15:47:47Z"
            },
            {
              "originalPosition": 89,
              "body": "```suggestion\r\n    ; if the prioritized element is a push stream\r\n```",
              "createdAt": "2023-07-05T15:46:08Z",
              "updatedAt": "2023-07-05T15:47:47Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n    ; if the prioritized element is a request stream\r\n```",
              "createdAt": "2023-07-05T15:46:30Z",
              "updatedAt": "2023-07-05T15:47:47Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\n    ; if the prioritized element is a push stream\r\n```",
              "createdAt": "2023-07-05T15:46:43Z",
              "updatedAt": "2023-07-05T15:47:47Z"
            },
            {
              "originalPosition": 45,
              "body": "```suggestion\r\nEmitted when the priority of a request stream or push stream is initialized or updated\r\n```",
              "createdAt": "2023-07-05T15:47:40Z",
              "updatedAt": "2023-07-05T15:47:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aTtdA",
          "commit": {
            "abbreviatedOid": "5220757"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T18:37:37Z",
          "updatedAt": "2023-07-05T18:37:38Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Discussed during call: rename to `request stream` and `push stream` consistently",
              "createdAt": "2023-07-05T18:37:37Z",
              "updatedAt": "2023-07-05T18:37:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aTvDW",
          "commit": {
            "abbreviatedOid": "5220757"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-05T18:41:57Z",
          "updatedAt": "2023-07-05T18:41:57Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Discussed on call: mainly be less prescriptive about the options (not Specifically but For instance). \r\n\r\n> For example, set initial prio, or when prio gets updated after HEADERS or PRIORITY_UPDATE, which can happen both due to signals from/decisions taken by client and server.",
              "createdAt": "2023-07-05T18:41:57Z",
              "updatedAt": "2023-07-05T18:41:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aYJYd",
          "commit": {
            "abbreviatedOid": "5220757"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-06T10:54:11Z",
          "updatedAt": "2023-07-06T10:54:12Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "This was updated in the last commit. Please check again @LPardue  :) ",
              "createdAt": "2023-07-06T10:54:11Z",
              "updatedAt": "2023-07-06T10:54:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5aZ0bZ",
          "commit": {
            "abbreviatedOid": "9879648"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-07-06T14:42:54Z",
          "updatedAt": "2023-07-06T14:42:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 315,
      "id": "PR_kwDOCrLn6M5UwLWI",
      "title": "Remove .well-known retrieval mechanism",
      "url": "https://github.com/quicwg/qlog/pull/315",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #313",
      "createdAt": "2023-07-05T22:42:40Z",
      "updatedAt": "2023-07-24T22:54:12Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "4b8d1f77989d708eb63359712af9671737b01380",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-well-known",
      "headRefOid": "eec4ba3aa80af00eb3971ca270a38f2ee82c1930",
      "closedAt": "2023-07-24T22:54:07Z",
      "mergedAt": "2023-07-24T22:54:07Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "57a8c67bea1d35aa585fb7c2fadbd98faf3cfb39"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Gonna sit on this a little while we wait for the WG to consider it.",
          "createdAt": "2023-07-06T14:46:08Z",
          "updatedAt": "2023-07-06T14:46:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aZ1Eo",
          "commit": {
            "abbreviatedOid": "eec4ba3"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-06T14:44:08Z",
          "updatedAt": "2023-07-06T14:44:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5apS_o",
          "commit": {
            "abbreviatedOid": "eec4ba3"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-08T19:45:59Z",
          "updatedAt": "2023-07-08T19:45:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 316,
      "id": "PR_kwDOCrLn6M5UwROm",
      "title": "Remove todo in event design guidelines",
      "url": "https://github.com/quicwg/qlog/pull/316",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "There guidelines are up for change until WGLC and beyond, no need to\ncall this out explicitly.\n",
      "createdAt": "2023-07-05T23:05:25Z",
      "updatedAt": "2023-07-06T14:45:35Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "4b8d1f77989d708eb63359712af9671737b01380",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-guideline-todo",
      "headRefOid": "6918c1ce5de027caa93a7b9a28177972a498dbaf",
      "closedAt": "2023-07-06T14:45:31Z",
      "mergedAt": "2023-07-06T14:45:31Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "5f5b7d19ff7b50f309a81e54ce64e602a9aab16c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aZ1T3",
          "commit": {
            "abbreviatedOid": "6918c1c"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-06T14:44:36Z",
          "updatedAt": "2023-07-06T14:44:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 317,
      "id": "PR_kwDOCrLn6M5UwSgw",
      "title": "Remove QUIC migration-related events section temporarily",
      "url": "https://github.com/quicwg/qlog/pull/317",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This section was a TODO placeholder in the text. We should use an issue\nto track this instead.\n",
      "createdAt": "2023-07-05T23:09:22Z",
      "updatedAt": "2023-07-06T14:46:25Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "4b8d1f77989d708eb63359712af9671737b01380",
      "headRepository": "quicwg/qlog",
      "headRefName": "migration-events-todo",
      "headRefOid": "6cae102ad8d64a37f106b51a17c718b4f58dccb4",
      "closedAt": "2023-07-06T14:46:22Z",
      "mergedAt": "2023-07-06T14:46:22Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "43e552efafe7c0c962ecd38a26249b8adfc49bcb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aZ2GG",
          "commit": {
            "abbreviatedOid": "6cae102"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-06T14:45:55Z",
          "updatedAt": "2023-07-06T14:45:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 320,
      "id": "PR_kwDOCrLn6M5UwTlF",
      "title": "remove loss_timer_updated todos",
      "url": "https://github.com/quicwg/qlog/pull/320",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Tracked in #319 instead\n",
      "createdAt": "2023-07-05T23:15:25Z",
      "updatedAt": "2023-07-07T14:14:20Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "4b8d1f77989d708eb63359712af9671737b01380",
      "headRepository": "quicwg/qlog",
      "headRefName": "loss-timer-todo",
      "headRefOid": "8da1b709c3d6457a632c3b54f48de6390e96f272",
      "closedAt": "2023-07-07T14:14:17Z",
      "mergedAt": "2023-07-07T14:14:17Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "526c3fcf5afdb3b9cb26a237cf818dcc16b9fc18"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aYJl2",
          "commit": {
            "abbreviatedOid": "8da1b70"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-06T10:54:46Z",
          "updatedAt": "2023-07-06T10:54:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 321,
      "id": "PR_kwDOCrLn6M5Uwccc",
      "title": "Tidy up discussion about event names",
      "url": "https://github.com/quicwg/qlog/pull/321",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This section had some hangover text from when an event contained\nseparate category and type fields. That's confusing.\n\nLets be clearer and more explicity about how we expect the name field to\nbe used. We should probably add additional language about what to do if\na parser encouners a name field *is not* valid. But that can be done as\nfollowup.\n",
      "createdAt": "2023-07-05T23:57:54Z",
      "updatedAt": "2023-07-06T15:39:25Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "4b8d1f77989d708eb63359712af9671737b01380",
      "headRepository": "quicwg/qlog",
      "headRefName": "category-cleanup",
      "headRefOid": "bde0021d9d2d208d0d116dffeb1cbcdfb91287be",
      "closedAt": "2023-07-06T15:39:21Z",
      "mergedAt": "2023-07-06T15:39:21Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "a78628385e0d23ca1776448b3f0ed07e34bdc1e9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aZ2-5",
          "commit": {
            "abbreviatedOid": "fc64abc"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM minus two nits",
          "createdAt": "2023-07-06T14:47:40Z",
          "updatedAt": "2023-07-06T14:49:52Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nfollowed by a non-empty character sequence representing a type.\r\n```",
              "createdAt": "2023-07-06T14:47:41Z",
              "updatedAt": "2023-07-06T14:49:52Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n\"qpack\", and \"recovery\". Within these categories, the event type provides\r\n```",
              "createdAt": "2023-07-06T14:48:15Z",
              "updatedAt": "2023-07-06T14:49:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 322,
      "id": "PR_kwDOCrLn6M5Uwc7I",
      "title": "Address remaining early secdir review comments",
      "url": "https://github.com/quicwg/qlog/pull/322",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Most of the non-security points from the secdir review have already been addressed. Apart from #321, these two changes remain\r\n\r\n- Clarify vantage_point requirements and usage\r\n- State event field requirements more normatively\r\n",
      "createdAt": "2023-07-06T00:00:41Z",
      "updatedAt": "2023-07-06T15:29:15Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "4b8d1f77989d708eb63359712af9671737b01380",
      "headRepository": "quicwg/qlog",
      "headRefName": "secdir-review",
      "headRefOid": "a04cfeadae5ec9cd38074131bbd60e891d0bca0f",
      "closedAt": "2023-07-06T15:29:11Z",
      "mergedAt": "2023-07-06T15:29:11Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "58ea210f69f4013ecc4841c9fa0b4abd78edeffb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aZ_Gv",
          "commit": {
            "abbreviatedOid": "9bc84de"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-06T15:03:35Z",
          "updatedAt": "2023-07-06T15:03:46Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nbut their semantics depend on the context of the log usage.\r\n```\r\n\r\nThe ODCID field is no longer used in QUIC qlog :) ",
              "createdAt": "2023-07-06T15:03:35Z",
              "updatedAt": "2023-07-06T15:03:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 325,
      "id": "PR_kwDOCrLn6M5U0jUX",
      "title": "Add extended CONNECT support",
      "url": "https://github.com/quicwg/qlog/pull/325",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-06T15:06:49Z",
      "updatedAt": "2023-07-07T14:14:05Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "57e9af087f4e202e77b553c9f6c80a85a11426d7",
      "headRepository": "quicwg/qlog",
      "headRefName": "extended-connect",
      "headRefOid": "c3e7ec14d001450077572c9e777b56c17fc692c6",
      "closedAt": "2023-07-07T14:14:02Z",
      "mergedAt": "2023-07-07T14:14:01Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "3e7a19b4a25e68d5dba0d63e88747c4fcf471190"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aiiqc",
          "commit": {
            "abbreviatedOid": "c3e7ec1"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-07T14:08:56Z",
          "updatedAt": "2023-07-07T14:08:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 326,
      "id": "PR_kwDOCrLn6M5U67vB",
      "title": "Editorialize main schema intro",
      "url": "https://github.com/quicwg/qlog/pull/326",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-07T14:03:47Z",
      "updatedAt": "2023-07-10T09:43:07Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "a78628385e0d23ca1776448b3f0ed07e34bdc1e9",
      "headRepository": "quicwg/qlog",
      "headRefName": "editorialize-main-schema-intro",
      "headRefOid": "caba7a67c0d4e3e3a17d85b9e56202d9bb2dd210",
      "closedAt": "2023-07-10T09:43:06Z",
      "mergedAt": "2023-07-10T09:43:06Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "5444317076a3f58de7155603e1928624e120e03e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5ai2DF",
          "commit": {
            "abbreviatedOid": "c27698c"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-07-07T14:43:25Z",
          "updatedAt": "2023-07-07T14:46:58Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\nhave an encrypted wire image that restricts observers' ability to see what is\r\n```",
              "createdAt": "2023-07-07T14:43:25Z",
              "updatedAt": "2023-07-07T14:46:58Z"
            },
            {
              "originalPosition": 51,
              "body": "```suggestion\r\nstandardized. This has an effect on the tools and methods that are used to\r\n```",
              "createdAt": "2023-07-07T14:43:54Z",
              "updatedAt": "2023-07-07T14:46:58Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nprovides a shareable, aggregatable and structured logging format. This high-level schema is independent of protocol, with logging\r\n```\r\n\r\n\"more usable\" is vague... more usable than what? I propose just cutting this",
              "createdAt": "2023-07-07T14:45:39Z",
              "updatedAt": "2023-07-07T14:46:58Z"
            },
            {
              "originalPosition": 104,
              "body": "```suggestion\r\nwire. Some examples of possible formats are JSON, CBOR, CSV, protobuf,\r\nflatbuffers, etc.\r\n```\r\n\r\nConsistency with abstract",
              "createdAt": "2023-07-07T14:46:47Z",
              "updatedAt": "2023-07-07T14:46:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5ai7xe",
          "commit": {
            "abbreviatedOid": "c27698c"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T14:57:09Z",
          "updatedAt": "2023-07-07T14:57:09Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "me too!",
              "createdAt": "2023-07-07T14:57:09Z",
              "updatedAt": "2023-07-07T14:57:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5apS59",
          "commit": {
            "abbreviatedOid": "77867b5"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-08T19:40:47Z",
          "updatedAt": "2023-07-08T19:41:22Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nMany applications implement logging using a custom, non-standard logging format.\r\nThis has an effect on the tools and methods that are used to\r\nanalyze the logs, for example to perform root cause analysis of an\r\ninteroperability failure between distinct implementations. A lack of a common\r\nformat impedes the development of common tooling that can be used by all parties\r\nthat have access to logs.\r\n```",
              "createdAt": "2023-07-08T19:40:47Z",
              "updatedAt": "2023-07-10T09:38:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5asv76",
          "commit": {
            "abbreviatedOid": "caba7a6"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T09:40:11Z",
          "updatedAt": "2023-07-10T09:40:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 327,
      "id": "PR_kwDOCrLn6M5U7BM1",
      "title": "Consistently Move notes about github to own section",
      "url": "https://github.com/quicwg/qlog/pull/327",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "- Editorialize main schema intro\n- Move note about github to own section\n",
      "createdAt": "2023-07-07T14:19:51Z",
      "updatedAt": "2023-07-10T09:43:33Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "4960429f1b0d258c72439557f2089e660e74a454",
      "headRepository": "quicwg/qlog",
      "headRefName": "move-notes",
      "headRefOid": "2c868e99e2b5ea3326f3968c29d72d5ccba909f7",
      "closedAt": "2023-07-10T09:43:33Z",
      "mergedAt": "2023-07-10T09:43:32Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "4064d002cf64b9ee16094428bdf6f42b2cfe6ef7"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "oops, this was not supposed to include the editorial changes to main-schema, only quic and h3 docs. Removed the bad commit.",
          "createdAt": "2023-07-07T15:02:35Z",
          "updatedAt": "2023-07-07T15:02:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5ai4cn",
          "commit": {
            "abbreviatedOid": "8665fa4"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "The github-part here is fine, but the main schema intro editorializing could use some attention. Left notes on this text at https://github.com/quicwg/qlog/pull/326, so maybe best to close that PR, implement changes here? ",
          "createdAt": "2023-07-07T14:49:06Z",
          "updatedAt": "2023-07-07T14:49:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5apS2M",
          "commit": {
            "abbreviatedOid": "2c868e9"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-08T19:37:39Z",
          "updatedAt": "2023-07-08T19:37:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5asxA-",
          "commit": {
            "abbreviatedOid": "2c868e9"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T09:42:46Z",
          "updatedAt": "2023-07-10T09:42:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 328,
      "id": "PR_kwDOCrLn6M5U7CU0",
      "title": "s/CAN/MAY",
      "url": "https://github.com/quicwg/qlog/pull/328",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-07T14:23:19Z",
      "updatedAt": "2023-07-07T14:57:55Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "526c3fcf5afdb3b9cb26a237cf818dcc16b9fc18",
      "headRepository": "quicwg/qlog",
      "headRefName": "shitcan",
      "headRefOid": "2c29f65043af634fe83882b33338c5c0c0efb045",
      "closedAt": "2023-07-07T14:57:51Z",
      "mergedAt": "2023-07-07T14:57:51Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "4960429f1b0d258c72439557f2089e660e74a454"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5aiyvQ",
          "commit": {
            "abbreviatedOid": "2c29f65"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-07T14:35:25Z",
          "updatedAt": "2023-07-07T14:35:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 329,
      "id": "PR_kwDOCrLn6M5WT7Mp",
      "title": "additional_schema using URI/URN",
      "url": "https://github.com/quicwg/qlog/pull/329",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "alternative to https://github.com/quicwg/qlog/pull/284/files, based on the suggestion by @JonathanLennox to do something similar to https://www.rfc-editor.org/rfc/rfc8285.html#section-5 and https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-10\r\n\r\nCloses https://github.com/quicwg/qlog/issues/283",
      "createdAt": "2023-07-25T09:32:38Z",
      "updatedAt": "2024-03-19T03:36:09Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "57a8c67bea1d35aa585fb7c2fadbd98faf3cfb39",
      "headRepository": "quicwg/qlog",
      "headRefName": "versioning-schema-urn",
      "headRefOid": "fec683a9a4f0e7e90e0a5abcda340d8e7682e608",
      "closedAt": "2024-03-19T03:36:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I assume this is subsumed by #415 @LPardue? Should we close this already or wait for the other one to be merged? ",
          "createdAt": "2024-03-18T16:19:10Z",
          "updatedAt": "2024-03-18T16:19:10Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I forgot about this entirely :facepalm:, it doesn't make sense to keep open as I don't want to have to fix the bitrot.",
          "createdAt": "2024-03-19T03:36:09Z",
          "updatedAt": "2024-03-19T03:36:09Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 330,
      "id": "PR_kwDOCrLn6M5dILoD",
      "title": "change Marten's email address",
      "url": "https://github.com/quicwg/qlog/pull/330",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-18T11:13:03Z",
      "updatedAt": "2023-10-18T11:20:05Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "57a8c67bea1d35aa585fb7c2fadbd98faf3cfb39",
      "headRepository": "quicwg/qlog",
      "headRefName": "change-marten-email",
      "headRefOid": "dcc8d9856c17c724a6f0cc0351d695a2796a639e",
      "closedAt": "2023-10-18T11:20:05Z",
      "mergedAt": "2023-10-18T11:20:05Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "6a7a530aca515d97558eb3d688e7f8832dbc1d17"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5ka8Fu",
          "commit": {
            "abbreviatedOid": "dcc8d98"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-18T11:13:44Z",
          "updatedAt": "2023-10-18T11:13:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 331,
      "id": "PR_kwDOCrLn6M5dbbKh",
      "title": "Reflow of main schema document first half",
      "url": "https://github.com/quicwg/qlog/pull/331",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The organic growth of the document has made, in my opinion, the flow\nof the document a bit janky.\n\nThis is especially so for JSON-SEQ. After reading the whole document\nthat frames things as qlog - there's a text buried down in the\nserialization that requires the reader to discard a lot of internalized\ncontext. It shouldn't be like that because QLogFile and QLogFileSeq are\nseparate things that share a tonne of qlog types.\n\nThis change focuses on sections 3-5. We draw our the primary themes that\nunderpin qlog by picking out the terms that we actually use. Instead of\nschema -> traces -> Field name semantics in one section, we move to\nQLogFile schema and related traces and Tace, QlogFileSeq and related TraceSeq,\nVantagePoint, Events, Raw packet info, and Common Events. Finishing up with\nguidelines for people to define their own events.\n",
      "createdAt": "2023-10-21T00:30:44Z",
      "updatedAt": "2023-10-23T10:47:16Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6a7a530aca515d97558eb3d688e7f8832dbc1d17",
      "headRepository": "quicwg/qlog",
      "headRefName": "main-spec-reflow",
      "headRefOid": "83d4e76bfb5fb5102763a55bdfdac73915506e5f",
      "closedAt": "2023-10-23T10:47:16Z",
      "mergedAt": "2023-10-23T10:47:16Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "bd8ec6b9e768463206f896b34c6e2280bb8d9c61"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This is pretty hard to diff in git. See https://author-tools.ietf.org/api/iddiff?url_1=https://quicwg.github.io/qlog/draft-ietf-quic-qlog-main-schema.txt&url_2=https://quicwg.github.io/qlog/main-spec-reflow/draft-ietf-quic-qlog-main-schema.txt for soemthing easier",
          "createdAt": "2023-10-21T00:36:18Z",
          "updatedAt": "2023-10-21T00:36:18Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merging this with a few fixed nits. Sorry for not following proper review procedure, but it's draft cutoff day ;) ",
          "createdAt": "2023-10-23T10:46:45Z",
          "updatedAt": "2023-10-23T10:46:45Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 332,
      "id": "PR_kwDOCrLn6M5dc0FR",
      "title": "Move changelog to end",
      "url": "https://github.com/quicwg/qlog/pull/332",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This section will be removed, so putting it as the first appendix\nmeans that there's a potential for more churn later on.\n\nThis change updates the changelog section metadata and moves it to the end.\n",
      "createdAt": "2023-10-21T17:39:26Z",
      "updatedAt": "2023-10-23T09:15:47Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6a7a530aca515d97558eb3d688e7f8832dbc1d17",
      "headRepository": "quicwg/qlog",
      "headRefName": "move-changelogs",
      "headRefOid": "191182a36a11ca43007ad33a26b70f28047c88bc",
      "closedAt": "2023-10-23T09:15:46Z",
      "mergedAt": "2023-10-23T09:15:46Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "e13d60b495f76ef463abe03bd0a910fd557f625e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5k0DQC",
          "commit": {
            "abbreviatedOid": "191182a"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-22T03:47:46Z",
          "updatedAt": "2023-10-22T03:47:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 333,
      "id": "PR_kwDOCrLn6M5dc08j",
      "title": "Replace IANA TBD",
      "url": "https://github.com/quicwg/qlog/pull/333",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-21T17:46:31Z",
      "updatedAt": "2023-10-22T12:57:31Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6a7a530aca515d97558eb3d688e7f8832dbc1d17",
      "headRepository": "quicwg/qlog",
      "headRefName": "iana-tbd-nono",
      "headRefOid": "fbd10b84988ee474e05b85a411d7d983e3141422",
      "closedAt": "2023-10-22T12:57:27Z",
      "mergedAt": "2023-10-22T12:57:27Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "592a340dd0c8c461d21bef897c8373194872eec5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5k0DFR",
          "commit": {
            "abbreviatedOid": "fbd10b8"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-22T03:36:57Z",
          "updatedAt": "2023-10-22T03:36:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 334,
      "id": "PR_kwDOCrLn6M5dd0K_",
      "title": "fix build warnings",
      "url": "https://github.com/quicwg/qlog/pull/334",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "1) Reference to HTTP/3\r\n2) Artwork too long",
      "createdAt": "2023-10-22T14:39:35Z",
      "updatedAt": "2023-10-22T16:22:57Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "592a340dd0c8c461d21bef897c8373194872eec5",
      "headRepository": "quicwg/qlog",
      "headRefName": "fixup-warnings",
      "headRefOid": "2dfcffc3d9605c56b7542d989630f4d0c8219356",
      "closedAt": "2023-10-22T16:22:54Z",
      "mergedAt": "2023-10-22T16:22:54Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "c081c826f2671ba155e7bcb6b9d1c79e3c56f497"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5k0YSb",
          "commit": {
            "abbreviatedOid": "2dfcffc"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-22T15:31:22Z",
          "updatedAt": "2023-10-22T15:31:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 335,
      "id": "PR_kwDOCrLn6M5dhSfT",
      "title": "proposal: remove QPACK events",
      "url": "https://github.com/quicwg/qlog/pull/335",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We've heard some feedback that the QPACK events are too low-level to be useful\nand that higher-level QPACK events would be preferred. However, in the absence of\na proposal for higher-level QPACK events we are stuck with what is currently\ndefined ... and nobody seems to be using these.\n\nProposal: remove low-level QPACK events from the spec so that consensus and\nimplementation experience of the remaining HTTP/3 events can be completed.\n",
      "createdAt": "2023-10-23T11:42:52Z",
      "updatedAt": "2023-11-29T22:51:13Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "bd8ec6b9e768463206f896b34c6e2280bb8d9c61",
      "headRepository": "quicwg/qlog",
      "headRefName": "pack-in-qpack",
      "headRefOid": "f117bdac1b5cc17fe6cee36a05fe0a455a290188",
      "closedAt": "2023-11-29T22:50:31Z",
      "mergedAt": "2023-11-29T22:50:31Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "e959596ca3944f0fd63d951ca17a080abab482c6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5nBC7O",
          "commit": {
            "abbreviatedOid": "f117bda"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-13T21:36:49Z",
          "updatedAt": "2023-11-13T21:36:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 336,
      "id": "PR_kwDOCrLn6M5e6Nh5",
      "title": "Add path_id and Connection Migration events",
      "url": "https://github.com/quicwg/qlog/pull/336",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds basic support for associating paths (defined by IP + port + Connection ID) with individual qlog events. This is done through a textual per-event `path_id` which can be associated with the necessary metadata using the `path_assigned` event (to prevent the `path_id` itself having to contain encoded information/becoming too long).\r\n\r\nWhile using the new path association possibilities in combination with logged PATH_CHALLENGE/PATH_RESPONSE frames (and other info like preferred_address) is enough to implicitly track connection migration attempts, it can be useful to explicitly log migration progression as well. For this, the `migration_state_updated` event was also added.",
      "createdAt": "2023-11-08T10:28:05Z",
      "updatedAt": "2024-03-04T19:42:21Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "2d6f293b8408c5554a2698e10bee8a26a3ea732b",
      "headRepository": "quicwg/qlog",
      "headRefName": "path-stuff",
      "headRefOid": "361dbec7cb73db0bba444dab5a970a06175d4eb1",
      "closedAt": "2024-03-04T19:42:20Z",
      "mergedAt": "2024-03-04T19:42:20Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "bea0df8152194632e626e4c04182442aa0834d09"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "We have a few issues related to migration, which ones does this PR address? Asking because it would be good to close things we think will be fixed.",
          "createdAt": "2023-11-17T21:12:22Z",
          "updatedAt": "2023-11-17T21:12:22Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, I'm looking to merge this by Monday (draft cutoff for IETF 119).\r\n\r\nI see that @qdeconinck and @mpiraux have been doing some implementation work on this in quiche; has that led to additional insights (especially on how \"ready for multipath\" this design is)? Any major changes needed? \r\n\r\nAdditionally, I could use some help to make sense of @mirjak's comments at the last meeting (not because they're not good comments, I just don't understand enough of the intricacies of paths/multipath probably).\r\n\r\nHere is the specific part: https://youtu.be/qbAm_HfLv_c?feature=shared&t=4841 where she talks about needing not just the `path_id` when receiving an ACK because you also need to have a CID to identify a multipath packet number. I follow that, BUT I thought that was just always taken care of by the `ACK_MP` frame (which includes the CID? https://quicwg.org/multipath/draft-ietf-quic-multipath.html#name-ack_mp-frame) so this I'm confused... \r\n\r\nI also feel you could have path_ids like \"pathx:CID1\" and \"pathx:CID2\" (so kind of hierarchical path_ids that link to the same conceptual \"path\" but differentiate based on the CID being used). If that kind of scheme is canonified by a later \"qlog for multipath\" it would ensure consistency across implementations (if the issue is that the hierarcharical approach is too loosy-goosy for now ;)). \r\n\r\nIn short: I'm planning to merge this by Monday unless we have major blockers here (that of course doesn't mean this can't change later, but I don't want to keep this as a floating PR too much longer). Thanks! ",
          "createdAt": "2024-02-27T16:13:00Z",
          "updatedAt": "2024-02-27T16:13:00Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "The current multipath draft doesn't have an explicit path ID. You say in the text a path is identified by the 4-tuple. This is not strictly aways true as due to migration the 4 tuple can change while the path is effectively the same. In the current draft we omit this problem by not defining an explicit path ID but _only_ use the CID as identifier.\r\n\r\nHowever having this said we are still discussing that problem and there is a PR that does introduce an explicit path ID. If that's the thing that ends up being standardised in the end, your text is mostly fine. \r\n\r\nIf that is not the solution we go for in the multipath draft, I recommend to not introduce a potentially ambiguous path ID and only use the CID as identifier. \r\n\r\nSorry for not being more helpful at this point.\r\n",
          "createdAt": "2024-02-27T16:30:15Z",
          "updatedAt": "2024-02-27T16:30:15Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the info @mirjak \r\n\r\nSo, I understand there's no direct path ID in multipath, which is why I also de-couple the `pathID` in qlog to be any string, and implementations/specs are free to fill that in as they like. If there is a \"proper\" `pathID` introduced in multipath later, that can just be used. \r\n\r\nIf not, the real question here is if implementations can (somewhat) easily derive a textual pathID to uniquely identify a path by coupling it to the info in `path_assigned`. As you say, a path is not always just the 4-tuple, so we also have an array of ConnectionIDs in `PathEndpointInfo`, which IIUC SHOULD be enough to cover that. Similarly, this allows keeping the same `pathID` even if the 4 tuple changes after migration (just use a new `path_assigned` event with the same `pathID` but changing the other parameters). \r\n\r\n> If that is not the solution we go for in the multipath draft, I recommend to not introduce a potentially ambiguous path ID and only use the CID as identifier.\r\n\r\nThere, I would say that you can use assign the CID to `pathID` and use `path_assigned` to give additional information on the path. Would that seem reasonable? \r\n\r\n\r\nThe real question here is if we have enough to be usable, no matter what the multipath draft ends up doing (as having actual/full multipath support with everything properly worked out is a non-goal at this point). ",
          "createdAt": "2024-02-28T10:30:17Z",
          "updatedAt": "2024-02-28T10:30:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5mxdD9",
          "commit": {
            "abbreviatedOid": "6b20a19"
          },
          "author": "qdeconinck",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "I think such PathId introduction, as well as the related events, seem like a good way to log multipath events, regardless on how the final design will evolve (we could be more specific about the content of PathID later if required).",
          "createdAt": "2023-11-10T08:15:25Z",
          "updatedAt": "2023-11-10T08:22:26Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I would either suggest quoting \"network path\" or remove the network word.\r\n```suggestion\r\nA qlog event can be associated with a single \"network path\" (usually, but not\r\n```",
              "createdAt": "2023-11-10T08:15:25Z",
              "updatedAt": "2023-11-10T08:22:26Z"
            },
            {
              "originalPosition": 22,
              "body": "Nit :-)\r\n```suggestion\r\nusing Multipath features, it is useful to be able to split events across\r\n```",
              "createdAt": "2023-11-10T08:16:27Z",
              "updatedAt": "2023-11-10T08:22:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5nlugm",
          "commit": {
            "abbreviatedOid": "6b20a19"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": ":shipit: \r\n",
          "createdAt": "2023-11-17T21:14:17Z",
          "updatedAt": "2023-11-17T21:14:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 337,
      "id": "PR_kwDOCrLn6M5fHec9",
      "title": "Add raw_ack_delay field to AckFrame",
      "url": "https://github.com/quicwg/qlog/pull/337",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As requested by Damien Neil on the QUIC wg mailing list on November 9, this adds an option to log the raw ack_delay value seen in the AckFrame, as opposed to the scaled value (for which external \"global\" state is needed, that is not always present in all code paths).",
      "createdAt": "2023-11-10T08:39:35Z",
      "updatedAt": "2024-06-27T18:40:20Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "f058c608b3853f382cbe9fd809db96ff57386ac2",
      "headRepository": "quicwg/qlog",
      "headRefName": "ack-delay-variant",
      "headRefOid": "6b04c6acfe46c13e189bcdb521f4df52f30fb03a",
      "closedAt": "2024-06-27T18:40:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@marten-seemann  thank you for the feedback.\r\nMy reply to the list is pending moderation (no clue why), just so you know I also had some explanation in there, so we'll see what others say. I don't feel strongly this HAS to be in there, but I do understand the ask here. ",
          "createdAt": "2023-11-10T08:55:17Z",
          "updatedAt": "2023-11-10T08:55:17Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> for which external \"global\" state is needed, that is not always present in all code paths\r\n\r\nI don't think this is a reasonable ask. We discussed this a few months ago on the list, and the next QUIC RFC might need to add some clarifying text that ACK delay isn't used in the Initial and Handshake PN space. This is completely independent of qlog, and conflating those two would be bad design.\r\n\r\nIn the end, a QUIC stack will need to decode the value at some point, there's nothing it can do with an unscaled ACK delay. The _only_ advantage to introducing the unscaled_ack_delay is that a QUIC stack can apply the scaling after qlogging the frame. I don't think this strikes the right balance (as I've argued on list). Among all the qlog implementations around today, no other QUIC stack ran into this problem, so this seems like we're adding logging in order to work around an architectural problem in one particular single stack here. ",
          "createdAt": "2023-11-10T09:12:06Z",
          "updatedAt": "2023-11-10T09:12:06Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "FWIW Its easier to track feature requests as issues rather than PRs (I'm guilty of this too).\r\n\r\nPropose closing this with no action.",
          "createdAt": "2023-11-17T21:05:27Z",
          "updatedAt": "2023-11-17T21:05:27Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreeing with @marten-seemann here. Also have seen no pushback on the list since, so closing without action. If still needed, please open an issue. ",
          "createdAt": "2024-06-27T18:40:20Z",
          "updatedAt": "2024-06-27T18:40:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5mxqYo",
          "commit": {
            "abbreviatedOid": "6b04c6a"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "As I wrote to the list, I don't think we should do this. Strongly opposed to this change.",
          "createdAt": "2023-11-10T08:48:18Z",
          "updatedAt": "2023-11-10T08:48:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 343,
      "id": "PR_kwDOCrLn6M5ft2rP",
      "title": "add a packet_dropped trigger for duplicate packets",
      "url": "https://github.com/quicwg/qlog/pull/343",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See section 12.3 of RFC 9000:\r\n\r\n> A receiver MUST discard a newly unprotected packet unless it is certain that it has not processed another packet with the same packet number from the same packet number space. Duplicate suppression MUST happen after removing packet protection for the reasons described in Section 9.5 of [QUIC-TLS].",
      "createdAt": "2023-11-17T07:47:11Z",
      "updatedAt": "2023-11-18T05:27:48Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "f058c608b3853f382cbe9fd809db96ff57386ac2",
      "headRepository": "quicwg/qlog",
      "headRefName": "packet_dropped_duplicate",
      "headRefOid": "9288d1d94b1f0847704d65d6a9e0e41b37663cd7",
      "closedAt": "2023-11-18T05:27:48Z",
      "mergedAt": "2023-11-18T05:27:48Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "df8bf3573c0dea1765a4beea0f09ae61cbd67608"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5nkPi4",
          "commit": {
            "abbreviatedOid": "9288d1d"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-11-17T17:36:57Z",
          "updatedAt": "2023-11-17T17:36:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 344,
      "id": "PR_kwDOCrLn6M5fzJfc",
      "title": "Update references to old drafts to point to RFCs",
      "url": "https://github.com/quicwg/qlog/pull/344",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Relates to https://github.com/quicwg/qlog/issues/174.\r\n\r\nNone of these seem controversal",
      "createdAt": "2023-11-17T22:35:17Z",
      "updatedAt": "2023-11-29T22:52:00Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "f058c608b3853f382cbe9fd809db96ff57386ac2",
      "headRepository": "quicwg/qlog",
      "headRefName": "update-old-draft-links",
      "headRefOid": "6974c7a2cae0c3ba3ffb46fc05293ba058d01e9c",
      "closedAt": "2023-11-29T22:51:55Z",
      "mergedAt": "2023-11-29T22:51:55Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "4d16e003123853580a0df7abffff2af46597ab6a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5nmzw3",
          "commit": {
            "abbreviatedOid": "6974c7a"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, but I haven't checked that all the chapter numbers are correct.",
          "createdAt": "2023-11-18T05:02:15Z",
          "updatedAt": "2023-11-18T05:02:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 345,
      "id": "PR_kwDOCrLn6M5fzSkR",
      "title": "h3: Replace \"this event\" with specific event names",
      "url": "https://github.com/quicwg/qlog/pull/345",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I've skipped changing QPACK events since we'll be deleting those anyway.\n",
      "createdAt": "2023-11-17T23:24:14Z",
      "updatedAt": "2023-11-29T23:04:15Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "f058c608b3853f382cbe9fd809db96ff57386ac2",
      "headRepository": "quicwg/qlog",
      "headRefName": "h3-less-this-event",
      "headRefOid": "bb10e155ed8e52af24f1b49aa6418976a2fd121a",
      "closedAt": "2023-11-29T23:04:12Z",
      "mergedAt": "2023-11-29T23:04:12Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "73f0090b8ba291a958e8443c5983a1d40b6a738b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5nms76",
          "commit": {
            "abbreviatedOid": "bb10e15"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-18T04:04:27Z",
          "updatedAt": "2023-11-18T04:04:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 347,
      "id": "PR_kwDOCrLn6M5fzcXJ",
      "title": "quic: replace \"this event\" for more specific names",
      "url": "https://github.com/quicwg/qlog/pull/347",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Also add backticks around special nouns so they'll pop in the HTML.\n",
      "createdAt": "2023-11-18T00:38:27Z",
      "updatedAt": "2023-11-29T23:15:05Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "73f0090b8ba291a958e8443c5983a1d40b6a738b",
      "headRepository": "quicwg/qlog",
      "headRefName": "quic-less-this-event",
      "headRefOid": "229c285b7cf71456d7d5e7976e72bdd8b9ec546e",
      "closedAt": "2023-11-29T23:15:01Z",
      "mergedAt": "2023-11-29T23:15:01Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "6f2d7220edc0ce316c7f1b0afdf3ae058ffcbaa2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5nm09W",
          "commit": {
            "abbreviatedOid": "33e4294"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Lots of changes here, thank you @LPardue! Please merge quickly to avoid merge conflicts.",
          "createdAt": "2023-11-18T05:19:22Z",
          "updatedAt": "2023-11-18T05:26:39Z",
          "comments": [
            {
              "originalPosition": 718,
              "body": "Sounds better?\r\n```suggestion\r\nThe `marked_for_retransmit` event indicates which data was marked for retransmission\r\n```",
              "createdAt": "2023-11-18T05:19:22Z",
              "updatedAt": "2023-11-18T05:26:19Z"
            },
            {
              "originalPosition": 719,
              "body": "Maybe better?\r\n```suggestion\r\nupon detection of packet loss (see `packet_lost`).\r\n```",
              "createdAt": "2023-11-18T05:19:48Z",
              "updatedAt": "2023-11-18T05:26:19Z"
            },
            {
              "originalPosition": 152,
              "body": "```suggestion\r\n: `connection_state_changed` with a new state of `attempted` is the same\r\n```",
              "createdAt": "2023-11-18T05:24:29Z",
              "updatedAt": "2023-11-18T05:26:19Z"
            },
            {
              "originalPosition": 155,
              "body": "```suggestion\r\n`connection_closed` event.\r\n```",
              "createdAt": "2023-11-18T05:24:44Z",
              "updatedAt": "2023-11-18T05:26:19Z"
            },
            {
              "originalPosition": 138,
              "body": "```suggestion\r\nstate transition. As such, users should not expect to see all these states\r\n```",
              "createdAt": "2023-11-18T05:25:29Z",
              "updatedAt": "2023-11-18T05:26:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 350,
      "id": "PR_kwDOCrLn6M5guhhf",
      "title": "State that importance is a level and integrate into prose",
      "url": "https://github.com/quicwg/qlog/pull/350",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This is an editorial change that tweaks importance from being an indicator\ninto a level, which makes it a bit easier to talk about in the prose.\nEach event definition is then updated to refer to level intro text.\n\nCloses #348\n",
      "createdAt": "2023-11-30T00:36:46Z",
      "updatedAt": "2023-12-08T15:21:20Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6f2d7220edc0ce316c7f1b0afdf3ae058ffcbaa2",
      "headRepository": "quicwg/qlog",
      "headRefName": "move-importance",
      "headRefOid": "26780d72e64d5eb06336449f57a1cf583a0f21f1",
      "closedAt": "2023-12-08T15:21:16Z",
      "mergedAt": "2023-12-08T15:21:15Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "c64198fd428bc41fad45ed03a781b4a8a1ff2d0b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5pp8l2",
          "commit": {
            "abbreviatedOid": "9fdba28"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-08T15:16:27Z",
          "updatedAt": "2023-12-08T15:16:27Z",
          "comments": [
            {
              "originalPosition": 370,
              "body": "```suggestion\r\nThe `key_updated` event has Base importance level; see {{Section 9.2 of QLOG-MAIN}}.\r\n```",
              "createdAt": "2023-12-08T15:16:27Z",
              "updatedAt": "2023-12-08T15:16:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 351,
      "id": "PR_kwDOCrLn6M5gui4p",
      "title": "Remove redundant definition:",
      "url": "https://github.com/quicwg/qlog/pull/351",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #349\n",
      "createdAt": "2023-11-30T00:44:46Z",
      "updatedAt": "2023-12-08T15:13:52Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6f2d7220edc0ce316c7f1b0afdf3ae058ffcbaa2",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-redundant-definition-prefix",
      "headRefOid": "63893a6844bff65efdbebec39aa6d5a7c7c5cbda",
      "closedAt": "2023-12-08T15:13:48Z",
      "mergedAt": "2023-12-08T15:13:48Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "557566bc34712f8fa18ed38cbb2c633ae42b4eb4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 352,
      "id": "PR_kwDOCrLn6M5gulrf",
      "title": "Align terminology across $ProtocolEvent extension point",
      "url": "https://github.com/quicwg/qlog/pull/352",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As discussed on #131, there's a slight mismatch of terminology\nbetween the main $ProtocolEventBody and the extensions QUICEvents\nand H3Events.\n\nThis change implements the proposal to align the terms.\n\nClose #131\n",
      "createdAt": "2023-11-30T01:01:52Z",
      "updatedAt": "2023-12-19T01:57:01Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6f2d7220edc0ce316c7f1b0afdf3ae058ffcbaa2",
      "headRepository": "quicwg/qlog",
      "headRefName": "event-eventdata-terminology",
      "headRefOid": "a2898932259570d4f2907997797f1e3eb876ae33",
      "closedAt": "2023-12-19T01:56:58Z",
      "mergedAt": "2023-12-19T01:56:58Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "cd828a39385712d10ed179a2c979da7ae94df27b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5pqEjF",
          "commit": {
            "abbreviatedOid": "a289893"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-08T15:30:25Z",
          "updatedAt": "2023-12-08T15:30:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 353,
      "id": "PR_kwDOCrLn6M5gu7_s",
      "title": "Restructure and reflow security section",
      "url": "https://github.com/quicwg/qlog/pull/353",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is an attempt to implement some of Martin Thomson's proposed changes.\r\n\r\nIt promotes some of the discussion into a general brief intro. Then\r\nspeaks concretely about the data the qlog can put at risk. Then it\r\npresents access control considerations, followed by data minimization.\r\n\r\nPer Martin's suggestion, data minimization for addressing risks is\r\nplayed down a little. I ended up changing this text the most but tried\r\nto shift, incorporate, or dedupe as much as I could and avoid deletion.\r\n\r\nCloses #259\r\n",
      "createdAt": "2023-11-30T03:05:56Z",
      "updatedAt": "2023-12-09T20:58:41Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "9713e68e43e7eaba785c5c3f321be278bdc18f1d",
      "headRepository": "quicwg/qlog",
      "headRefName": "sec-n-priv-mt",
      "headRefOid": "b55c82457945d27f87eacebfc0701408c2842e7c",
      "closedAt": "2023-12-09T20:58:34Z",
      "mergedAt": "2023-12-09T20:58:34Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "bd070df2475d916f1b507a9eee1982e9749fb1c3"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The text diff might make this easier to review - https://author-tools.ietf.org/api/iddiff?url_1=https://quicwg.github.io/qlog/draft-ietf-quic-qlog-main-schema.txt&url_2=https://quicwg.github.io/qlog/sec-n-priv-mt/draft-ietf-quic-qlog-main-schema.txt\r\n\r\n@martinthomson if you could find some time to review this it would be appreciated but we won't block on that.",
          "createdAt": "2023-11-30T03:08:36Z",
          "updatedAt": "2023-11-30T03:08:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Oh, I forgot to add one more point.  I've said this before, but I will again.\r\n\r\nThis is very long.  I would encourage you to find ways to have this section include fewer words, not more.",
          "createdAt": "2023-11-30T05:18:16Z",
          "updatedAt": "2023-11-30T05:18:16Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "In the interest of momentum, I'll punting the cutting down of text to https://github.com/quicwg/qlog/issues/358",
          "createdAt": "2023-12-09T20:58:03Z",
          "updatedAt": "2023-12-09T20:58:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5otCgx",
          "commit": {
            "abbreviatedOid": "9a54c71"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Very happy to see that you don't recommend k-anonymity as a measure here.  Though maybe that is what you imply with the call out to anonymization.  There are some useful results from differential privacy in that regard, but that comes with some odd consequences for usability.",
          "createdAt": "2023-11-30T05:04:11Z",
          "updatedAt": "2023-11-30T05:17:25Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nthe wire image that would ordinarily be protected. This tension equally applies\r\n```",
              "createdAt": "2023-11-30T05:04:11Z",
              "updatedAt": "2023-11-30T05:17:25Z"
            },
            {
              "originalPosition": 13,
              "body": "This first sentence is not precise about whether it refers to the logging use case or the use case of the logged exchange.",
              "createdAt": "2023-11-30T05:05:08Z",
              "updatedAt": "2023-11-30T05:17:25Z"
            },
            {
              "originalPosition": 66,
              "body": "This doesn't appear to be a complete and well-formed sentence.",
              "createdAt": "2023-11-30T05:05:45Z",
              "updatedAt": "2023-11-30T05:17:25Z"
            },
            {
              "originalPosition": 71,
              "body": "Would it be reasonable to suggest that any authorization for logging access be considered equivalent to plaintext access to communications.  I realize that some people might feel uncomfortable about that, because they enable logging where they would not enable plaintext access, but I think that considering them equivalent -- absent strong justification to the contrary -- better reflects the true nature of most communications.",
              "createdAt": "2023-11-30T05:07:51Z",
              "updatedAt": "2023-11-30T05:17:25Z"
            },
            {
              "originalPosition": 78,
              "body": "This statement is a bit obtuse.  I would instead say:\r\n\r\n```suggestion\r\nAn end-user that might enable logging without understanding the implications of\r\nthat choice on their privacy and security. Implementations should\r\n```",
              "createdAt": "2023-11-30T05:09:32Z",
              "updatedAt": "2023-11-30T05:17:25Z"
            },
            {
              "originalPosition": 80,
              "body": "... or social engineering?",
              "createdAt": "2023-11-30T05:09:42Z",
              "updatedAt": "2023-11-30T05:17:25Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\ncapture and isolation or sandboxing of capture from other activities in the\r\n```",
              "createdAt": "2023-11-30T05:09:59Z",
              "updatedAt": "2023-11-30T05:17:25Z"
            },
            {
              "originalPosition": 93,
              "body": "```suggestion\r\noperators are advised that removing or anonymizing data without sufficient care might\r\nnot improve privacy or securrity.\r\n```",
              "createdAt": "2023-11-30T05:12:04Z",
              "updatedAt": "2023-11-30T05:17:25Z"
            },
            {
              "originalPosition": 95,
              "body": "```suggestion\r\nMinimization or anonymization might greatly reduce the usefulness\r\nof qlog data.\r\n```\r\n\r\nIt is rare that the effect will be equal.  (You probably meant \"at the same time\" or \"in the same way\")",
              "createdAt": "2023-11-30T05:12:55Z",
              "updatedAt": "2023-11-30T05:17:25Z"
            },
            {
              "originalPosition": 97,
              "body": "```suggestion\r\nOperator and implementers need to balance the value of logged data against the potential\r\n```",
              "createdAt": "2023-11-30T05:13:54Z",
              "updatedAt": "2023-11-30T05:17:25Z"
            },
            {
              "originalPosition": 100,
              "body": "It seems like the difference in these examples is WHO has access to the data and the level to which the different entities might be trusted, so maybe this isn't so much about use cases.",
              "createdAt": "2023-11-30T05:14:52Z",
              "updatedAt": "2023-11-30T05:17:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5pqB1o",
          "commit": {
            "abbreviatedOid": "9a54c71"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-08T15:25:41Z",
          "updatedAt": "2023-12-08T15:29:50Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Yes, I'll update the text to reflect that.",
              "createdAt": "2023-12-08T15:25:41Z",
              "updatedAt": "2023-12-08T15:29:50Z"
            },
            {
              "originalPosition": 80,
              "body": "yep that was my implication but I'll add that",
              "createdAt": "2023-12-08T15:26:51Z",
              "updatedAt": "2023-12-08T15:29:50Z"
            },
            {
              "originalPosition": 13,
              "body": "I agree. I'm going to track this in a separate ticket (along with your other mention of use-cases). See #355 ",
              "createdAt": "2023-12-08T15:29:37Z",
              "updatedAt": "2023-12-08T15:33:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5pqFVu",
          "commit": {
            "abbreviatedOid": "e9d31ce"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-08T15:32:09Z",
          "updatedAt": "2023-12-08T15:32:10Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "I'm lumping this under #355 ",
              "createdAt": "2023-12-08T15:32:09Z",
              "updatedAt": "2023-12-08T15:32:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 354,
      "id": "PR_kwDOCrLn6M5hiNpn",
      "title": "fix(quic-events): replace typo \"is can be\" with \"can be\"",
      "url": "https://github.com/quicwg/qlog/pull/354",
      "state": "MERGED",
      "author": "mxinden",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-12-08T15:24:23Z",
      "updatedAt": "2023-12-08T15:38:22Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "c64198fd428bc41fad45ed03a781b4a8a1ff2d0b",
      "headRepository": "mxinden/qlog",
      "headRefName": "patch-1",
      "headRefOid": "a80ea2cf7ffcb808f12f51ed479017c9fa5d1bfb",
      "closedAt": "2023-12-08T15:38:22Z",
      "mergedAt": "2023-12-08T15:38:22Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "a375f821019c1c0e37ab50ecf6b3189ca59d74c8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5pqB8D",
          "commit": {
            "abbreviatedOid": "a80ea2c"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-08T15:25:56Z",
          "updatedAt": "2023-12-08T15:25:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5pqJJH",
          "commit": {
            "abbreviatedOid": "a80ea2c"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-08T15:38:10Z",
          "updatedAt": "2023-12-08T15:38:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 356,
      "id": "PR_kwDOCrLn6M5hlX2O",
      "title": "fix(quic-events): typo version_negotiation on *un*-supported version",
      "url": "https://github.com/quicwg/qlog/pull/356",
      "state": "MERGED",
      "author": "mxinden",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The server sends a version_negotiation packet when it does *not* support the client version.\r\n\r\nAlso remove duplicate \"of\".",
      "createdAt": "2023-12-09T10:34:17Z",
      "updatedAt": "2023-12-09T10:52:12Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "a375f821019c1c0e37ab50ecf6b3189ca59d74c8",
      "headRepository": "mxinden/qlog",
      "headRefName": "version-not",
      "headRefOid": "234d3ebd239c95a3e73b807619f2a73fd3ba42b4",
      "closedAt": "2023-12-09T10:52:12Z",
      "mergedAt": "2023-12-09T10:52:12Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "67552f1d7022556a75abd545adf1c26004e0ed21"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5puAlx",
          "commit": {
            "abbreviatedOid": "6ff33ed"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you!",
          "createdAt": "2023-12-09T10:40:51Z",
          "updatedAt": "2023-12-09T10:40:58Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Not introduced in this PR, but taking the opportunity to fix another nit: The packet is called Version Negotiation packet, according to RFC 8999.\r\n\r\n```suggestion\r\nnot support that version, it replies with a Version Negotiation packet, which\r\ncontains its supported versions. From this, the client selects a version. The\r\n```",
              "createdAt": "2023-12-09T10:40:51Z",
              "updatedAt": "2023-12-09T10:40:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5puAqU",
          "commit": {
            "abbreviatedOid": "6ff33ed"
          },
          "author": "mxinden",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-09T10:43:29Z",
          "updatedAt": "2023-12-09T10:43:29Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Thanks. Today I learned that RFC 9000 is not the first QUIC related RFC.",
              "createdAt": "2023-12-09T10:43:29Z",
              "updatedAt": "2023-12-09T10:43:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5puBHk",
          "commit": {
            "abbreviatedOid": "234d3eb"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-09T10:52:02Z",
          "updatedAt": "2023-12-09T10:52:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 359,
      "id": "PR_kwDOCrLn6M5hmXsY",
      "title": "Define uint64 duality once",
      "url": "https://github.com/quicwg/qlog/pull/359",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #229\n",
      "createdAt": "2023-12-09T22:00:39Z",
      "updatedAt": "2024-02-28T14:37:24Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "bd070df2475d916f1b507a9eee1982e9749fb1c3",
      "headRepository": "quicwg/qlog",
      "headRefName": "uint64-can-be-string",
      "headRefOid": "cf78fde3b16665af07ff8043b8956a18a8544a15",
      "closedAt": "2024-02-28T14:37:23Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "That's fair. But that's effectively what we've already been saying all along - it was just buried in a section about I-JSON. We have an interop issue if people miss this section. E.g. with no way to signal I-JSON, if I pass you a JSON qlog file with a large GREASE value encoded with a string and you try to parse it as a uint64 ... \ud83d\udca5. A quiet fail is also bad, being unable to represent data values (or to parse them) is a way to hide data within a connection that might be expected to be observable.\r\n\r\nThings are leaky. CDDL explains that in https://www.rfc-editor.org/rfc/rfc8610#appendix-E. Maybe there's some other way to explain that in the docs and I'm open to it but I don't have much inspiration.",
          "createdAt": "2023-12-10T04:25:37Z",
          "updatedAt": "2023-12-10T04:25:37Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during editors meeting. \r\nLucas will update this with new opinion about how we should handle uint64 in combo with CDDL. ",
          "createdAt": "2024-02-05T10:00:43Z",
          "updatedAt": "2024-02-05T10:00:43Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "overtaken by #388 ",
          "createdAt": "2024-02-28T14:37:23Z",
          "updatedAt": "2024-02-28T14:37:23Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5pvIkr",
          "commit": {
            "abbreviatedOid": "cf78fde"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I don\u2019t like this change. The CDDL is supposed to be an independent representation of the data, and now the quirks of one serialization are bleeding into this.",
          "createdAt": "2023-12-10T04:02:14Z",
          "updatedAt": "2023-12-10T04:02:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 360,
      "id": "PR_kwDOCrLn6M5hmerZ",
      "title": "Reframe JSON interop concerns seperately of I-JSON",
      "url": "https://github.com/quicwg/qlog/pull/360",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Since we added JSON-SEQ, it's been hard to square the circle about\nwhere I-JSON fits in the document structure. I think that's because\nactually the discussion should be framed in the context of interop\nissues related to JSON messages. Our 64-bit values pose a problem\nand the way CDDL suggest to solve that doesn't work - so we lay it\nall out here.\n\nThere is obvious overlap here with PR #359. Whichever lands first\n(if they even do) will cause some conflict that is easy to fixup.\n\nCloses #339\n",
      "createdAt": "2023-12-09T22:52:40Z",
      "updatedAt": "2024-02-05T11:47:25Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "bd070df2475d916f1b507a9eee1982e9749fb1c3",
      "headRepository": "quicwg/qlog",
      "headRefName": "reframe-ijson",
      "headRefOid": "bd7b77ac02d590780ea10192575bc05d2149d145",
      "closedAt": "2024-02-05T11:47:22Z",
      "mergedAt": "2024-02-05T11:47:22Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "724f324d9cf756d06a742d00611b995929085096"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This change looks big but its mostly just promoting the `I-JSON` section from 10.1.1 to a broader `JSON Interoperabiltiy` section 10.3",
          "createdAt": "2024-02-05T11:10:48Z",
          "updatedAt": "2024-02-05T11:10:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5vA2UE",
          "commit": {
            "abbreviatedOid": "bd7b77a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-05T11:34:13Z",
          "updatedAt": "2024-02-05T11:34:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 361,
      "id": "PR_kwDOCrLn6M5hme84",
      "title": "Remove text about optimization/filename chaining",
      "url": "https://github.com/quicwg/qlog/pull/361",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #341\n",
      "createdAt": "2023-12-09T22:58:46Z",
      "updatedAt": "2023-12-19T01:55:54Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "bd070df2475d916f1b507a9eee1982e9749fb1c3",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-chaining",
      "headRefOid": "c6bd2832233a2a877cd07917aa7321f417fe7bf8",
      "closedAt": "2023-12-19T01:55:51Z",
      "mergedAt": "2023-12-19T01:55:51Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "cdba8c09537b6dbcc5fa599f08e51eedbf04b466"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5pvIh4",
          "commit": {
            "abbreviatedOid": "c6bd283"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-10T03:59:25Z",
          "updatedAt": "2023-12-10T03:59:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 362,
      "id": "PR_kwDOCrLn6M5hmfPo",
      "title": "Rephrase qlog field serialization rules",
      "url": "https://github.com/quicwg/qlog/pull/362",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This avoids any ambiguity about what we are talking about, avoiding\nthe need to import JSON terms.\n\nCloses #340\n",
      "createdAt": "2023-12-09T23:05:15Z",
      "updatedAt": "2023-12-19T01:56:25Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "bd070df2475d916f1b507a9eee1982e9749fb1c3",
      "headRepository": "quicwg/qlog",
      "headRefName": "be-clear-about-field-names",
      "headRefOid": "2e5186b8b6d6b300ce7a5a532b4636a193096450",
      "closedAt": "2023-12-19T01:56:21Z",
      "mergedAt": "2023-12-19T01:56:21Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "3398abe69e6bed658a34be836849142f260bd320"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5pvIgy",
          "commit": {
            "abbreviatedOid": "2e5186b"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-10T03:58:24Z",
          "updatedAt": "2023-12-10T03:58:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 363,
      "id": "PR_kwDOCrLn6M5hmgJx",
      "title": "Move commentary on HTTP/3 frame and QUIC packetization",
      "url": "https://github.com/quicwg/qlog/pull/363",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #280\n",
      "createdAt": "2023-12-09T23:27:51Z",
      "updatedAt": "2024-06-25T09:44:43Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "98d720cd6519002775c224e94e03a2d0c9fbb431",
      "headRepository": "quicwg/qlog",
      "headRefName": "h3-frames-r-big",
      "headRefOid": "2bbbd9145a22f867e20b38c5e051bad82dca8381",
      "closedAt": "2024-06-25T09:44:40Z",
      "mergedAt": "2024-06-25T09:44:40Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "bac3d8e4527e415d955bc9fdd918b0aafef029a4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5pvIfD",
          "commit": {
            "abbreviatedOid": "2bbbd91"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-10T03:56:33Z",
          "updatedAt": "2023-12-10T03:57:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Do we need to specify that this only applies to DATA frames?",
              "createdAt": "2023-12-10T03:56:33Z",
              "updatedAt": "2023-12-10T03:57:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5pvIuV",
          "commit": {
            "abbreviatedOid": "2bbbd91"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-10T04:10:01Z",
          "updatedAt": "2023-12-10T04:10:01Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Ah I see the disjoint in my previous understanding of why the text was the way it was. In theory extension frames could do something similar but nothing concrete is in scope, only DATA benefits from that usage.\r\n\r\nFrames can span packets and there might be some value is explaining that here. Let me try to tweak the text a bit more.",
              "createdAt": "2023-12-10T04:10:01Z",
              "updatedAt": "2023-12-10T04:10:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5yG_ch",
          "commit": {
            "abbreviatedOid": "2bbbd91"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-04T14:17:56Z",
          "updatedAt": "2024-03-04T14:17:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I actually think the text might be fine as-is? There's also the case where you have the H3 frame headers in Packet N and the actual payload in Packet N+1 (say you have multiple streams being packed into the same packet for some reason), so not tying this down to `DATA` only seems fine.\r\n\r\nIf you really want, you could change it to `Additionally, some implementations might send a single large frame,\r\nrather than a sequence of smaller frames...`, so it's a bit clearer that the \"single large frame\" is a common occurrence of this issue but not the sole reason :) ",
              "createdAt": "2024-03-04T14:17:56Z",
              "updatedAt": "2024-03-04T14:17:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5yG_lw",
          "commit": {
            "abbreviatedOid": "2bbbd91"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-04T14:18:12Z",
          "updatedAt": "2024-03-04T14:18:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 364,
      "id": "PR_kwDOCrLn6M5iUsrA",
      "title": "Edit down the security section",
      "url": "https://github.com/quicwg/qlog/pull/364",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Focuses on cutting down words and deduplicating things. Maybe not as far as MT\r\nwould take things but I think this avoids any major cuts.\r\n\r\nFixes #358\r\n",
      "createdAt": "2023-12-19T01:54:44Z",
      "updatedAt": "2024-02-28T13:54:22Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "a6c9a3f0c49a16921e862c00332476b83de6db42",
      "headRepository": "quicwg/qlog",
      "headRefName": "make-sec-more-concise",
      "headRefOid": "1455e02811fa833540dcfb58a5108d6df7d8c1a4",
      "closedAt": "2024-02-28T13:54:13Z",
      "mergedAt": "2024-02-28T13:54:13Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "1803174140b198b76cc4258773878ad76afe50ff"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "@rmarx I've addressed your final two comments, PTAL",
          "createdAt": "2024-02-20T17:30:38Z",
          "updatedAt": "2024-02-20T17:30:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5qkzLL",
          "commit": {
            "abbreviatedOid": "bf2c940"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Copy edits.  Still too long, but it's totally correct, so I'm good.",
          "createdAt": "2023-12-19T03:18:07Z",
          "updatedAt": "2023-12-19T03:28:28Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nrisking the privacy of all participants. Entities that expect protocol\r\n```",
              "createdAt": "2023-12-19T03:18:07Z",
              "updatedAt": "2023-12-19T03:28:28Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nhandling qlog data, including logging, storage, usage, and more. Data can be\r\n```",
              "createdAt": "2023-12-19T03:18:30Z",
              "updatedAt": "2023-12-19T03:28:28Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nhandling qlog data, including logging, storage, usage, and more.  The\r\n```\r\nOptionally.  The classification thing doesn't add to the narrative.",
              "createdAt": "2023-12-19T03:19:12Z",
              "updatedAt": "2023-12-19T03:28:28Z"
            },
            {
              "originalPosition": 69,
              "body": "```suggestion\r\n* Stored State e.g., QUIC address validation and retry tokens, TLS session\r\n```",
              "createdAt": "2023-12-19T03:19:31Z",
              "updatedAt": "2023-12-19T03:28:28Z"
            },
            {
              "originalPosition": 76,
              "body": "```suggestion\r\n* TLS decryption keys, passwords, and HTTP-level API access or authorization tokens.\r\n```",
              "createdAt": "2023-12-19T03:19:53Z",
              "updatedAt": "2023-12-19T03:28:28Z"
            },
            {
              "originalPosition": 87,
              "body": "I was going to suggest something, but I don't know how to parse this.",
              "createdAt": "2023-12-19T03:24:47Z",
              "updatedAt": "2023-12-19T03:28:28Z"
            },
            {
              "originalPosition": 100,
              "body": "```suggestion\r\nOperational considerations should focus on authorizing capture and access to logs. Logging of\r\n```",
              "createdAt": "2023-12-19T03:25:19Z",
              "updatedAt": "2023-12-19T03:28:28Z"
            },
            {
              "originalPosition": 177,
              "body": "```suggestion\r\nwithout sufficient care might not enhance privacy or security and\r\n```",
              "createdAt": "2023-12-19T03:26:00Z",
              "updatedAt": "2023-12-19T03:28:28Z"
            },
            {
              "originalPosition": 192,
              "body": "```suggestion\r\ncautious because many anonymization methods have been shown to be insufficient to safeguard\r\n```",
              "createdAt": "2023-12-19T03:26:54Z",
              "updatedAt": "2023-12-19T03:28:28Z"
            },
            {
              "originalPosition": 101,
              "body": "```suggestion\r\nInternet protocols using qlog can be equivalent the ability to store or read plaintext\r\n```",
              "createdAt": "2023-12-19T03:27:45Z",
              "updatedAt": "2023-12-19T03:28:28Z"
            },
            {
              "originalPosition": 102,
              "body": "```suggestion\r\ncommunications. Without a more detailed analysis, all of the security considerations of plaintext access apply.\r\n```",
              "createdAt": "2023-12-19T03:28:03Z",
              "updatedAt": "2023-12-19T03:28:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5qk2ZW",
          "commit": {
            "abbreviatedOid": "bf2c940"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-19T03:37:47Z",
          "updatedAt": "2023-12-19T03:37:47Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "@rmarx any strong feelings here since it is your text?",
              "createdAt": "2023-12-19T03:37:47Z",
              "updatedAt": "2023-12-19T03:37:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5qk3-y",
          "commit": {
            "abbreviatedOid": "0bad8ab"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-19T03:43:20Z",
          "updatedAt": "2023-12-19T03:43:20Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "```suggestion\r\n* Full or partial raw packet and frame payloads that are encrypted.\r\n```\r\n\r\n@rmarx is something like this the intent?",
              "createdAt": "2023-12-19T03:43:20Z",
              "updatedAt": "2023-12-19T03:43:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5qk4HO",
          "commit": {
            "abbreviatedOid": "0bad8ab"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-19T03:44:15Z",
          "updatedAt": "2023-12-19T03:44:15Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "consistency with above (if we go that way)\r\n\r\n```suggestion\r\n* Full or partial raw packet and frame payloads that are plaintext e.g., HTTP Field\r\n  values, HTTP response data, or TLS SNI field values.\r\n```",
              "createdAt": "2023-12-19T03:44:15Z",
              "updatedAt": "2023-12-19T03:44:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5qk4J6",
          "commit": {
            "abbreviatedOid": "0bad8ab"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-19T03:44:33Z",
          "updatedAt": "2023-12-19T03:44:34Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "```suggestion\r\n```",
              "createdAt": "2023-12-19T03:44:34Z",
              "updatedAt": "2023-12-19T03:44:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5wivtv",
          "commit": {
            "abbreviatedOid": "98433ff"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-02-19T11:07:15Z",
          "updatedAt": "2024-02-19T11:31:37Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\nThe following is a non-exhaustive list of example data types that could contain\r\n```",
              "createdAt": "2024-02-19T11:07:15Z",
              "updatedAt": "2024-02-19T11:31:37Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nsensitive information that might allow identification or correlation of\r\n```",
              "createdAt": "2024-02-19T11:07:35Z",
              "updatedAt": "2024-02-19T11:31:37Z"
            },
            {
              "originalPosition": 87,
              "body": "In combination with the consistency changes below for plaintext, this indeed seems ok",
              "createdAt": "2024-02-19T11:12:34Z",
              "updatedAt": "2024-02-19T11:31:37Z"
            },
            {
              "originalPosition": 101,
              "body": "```suggestion\r\nInternet protocols using qlog can be equivalent to the ability to store or read plaintext\r\n```",
              "createdAt": "2024-02-19T11:20:18Z",
              "updatedAt": "2024-02-19T11:31:37Z"
            },
            {
              "originalPosition": 110,
              "body": "`extending to granularity over the level of information that is allowed to be\r\ncaptured` \r\n\r\nthis is a very weird sentence to me that I'm having issues parsing the meaning of... could do with a re-formulation (the e.g., helps, but still :))",
              "createdAt": "2024-02-19T11:22:14Z",
              "updatedAt": "2024-02-19T11:31:37Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nand their environments might limit access control techniques. Implementations should\r\n```",
              "createdAt": "2024-02-19T11:23:49Z",
              "updatedAt": "2024-02-19T11:31:37Z"
            },
            {
              "originalPosition": 124,
              "body": "```suggestion\r\nmake enabling qlog conspicuous (e.g., requiring clear and explicit actions to\r\n```",
              "createdAt": "2024-02-19T11:24:12Z",
              "updatedAt": "2024-02-19T11:31:37Z"
            },
            {
              "originalPosition": 184,
              "body": "```suggestion\r\nThe most extreme form of minimization or anonymization is deleting a field,\r\n```",
              "createdAt": "2024-02-19T11:29:02Z",
              "updatedAt": "2024-02-19T11:31:37Z"
            },
            {
              "originalPosition": 201,
              "body": "```suggestion\r\n(see {{raw-info}}). Therefore, qlog users should exercise caution and limit the\r\n```",
              "createdAt": "2024-02-19T11:31:12Z",
              "updatedAt": "2024-02-19T11:31:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5wi6hT",
          "commit": {
            "abbreviatedOid": "bf2c940"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-19T11:32:33Z",
          "updatedAt": "2024-02-19T11:32:33Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "It's fine for me to remove this, but then there's another sentence just a little bit further that also mentions \"potentially-sensitive and sensitive\" that probably should be cut as well. ",
              "createdAt": "2024-02-19T11:32:33Z",
              "updatedAt": "2024-02-19T11:32:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5xeAqx",
          "commit": {
            "abbreviatedOid": "1455e02"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-27T14:36:19Z",
          "updatedAt": "2024-02-27T14:36:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 365,
      "id": "PR_kwDOCrLn6M5jZ7De",
      "title": "Update Lucas' email",
      "url": "https://github.com/quicwg/qlog/pull/365",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-01-07T13:02:22Z",
      "updatedAt": "2024-01-07T14:05:16Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6d286cfe96ed628499da1f9df9fb17167dc0e741",
      "headRepository": "quicwg/qlog",
      "headRefName": "lucas-email",
      "headRefOid": "57c69f8c3ce0dacdd02910e55d6b344cd8ad5b40",
      "closedAt": "2024-01-07T14:05:08Z",
      "mergedAt": "2024-01-07T14:05:08Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "930fec249bdd5632851158e3bb33837789a50177"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5rwPuO",
          "commit": {
            "abbreviatedOid": "57c69f8"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-07T13:41:49Z",
          "updatedAt": "2024-01-07T13:41:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 380,
      "id": "PR_kwDOCrLn6M5k6CTq",
      "title": "update Marten's org",
      "url": "https://github.com/quicwg/qlog/pull/380",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-01-24T04:32:39Z",
      "updatedAt": "2024-01-24T04:39:41Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "21a3de1ec3dbcef1c636d91d841fa597f683c8f9",
      "headRepository": "quicwg/qlog",
      "headRefName": "update-martens-org",
      "headRefOid": "3177e4535af65a537d82852d0dfe600938d2aa05",
      "closedAt": "2024-01-24T04:39:41Z",
      "mergedAt": "2024-01-24T04:39:41Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "080c3c5b0e308b746a33e644c3db45f90183d216"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5tslEb",
          "commit": {
            "abbreviatedOid": "3177e45"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-24T04:37:34Z",
          "updatedAt": "2024-01-24T04:37:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 381,
      "id": "PR_kwDOCrLn6M5k6EVJ",
      "title": "add a packet_dropped trigger for unavailable decryption keys",
      "url": "https://github.com/quicwg/qlog/pull/381",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #371.",
      "createdAt": "2024-01-24T04:44:44Z",
      "updatedAt": "2024-01-27T02:41:09Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "080c3c5b0e308b746a33e644c3db45f90183d216",
      "headRepository": "quicwg/qlog",
      "headRefName": "packet-drop-key-unavailable",
      "headRefOid": "e33d8656ec62a082da3ab44c479968ab8743df82",
      "closedAt": "2024-01-27T02:41:09Z",
      "mergedAt": "2024-01-27T02:41:09Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "391958c3917b29147b303457cee9a9e6c1cafeae"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5uE55W",
          "commit": {
            "abbreviatedOid": "e33d865"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-27T01:44:52Z",
          "updatedAt": "2024-01-27T01:44:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 383,
      "id": "PR_kwDOCrLn6M5lQz_9",
      "title": "Convert H3 setting param types to a real type",
      "url": "https://github.com/quicwg/qlog/pull/383",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #382\r\n",
      "createdAt": "2024-01-28T18:51:26Z",
      "updatedAt": "2024-06-27T20:14:46Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "bac3d8e4527e415d955bc9fdd918b0aafef029a4",
      "headRepository": "quicwg/qlog",
      "headRefName": "h3-settings",
      "headRefOid": "911647d8fdbaa1dc4f8c6c54369986c7b94dcec2",
      "closedAt": "2024-06-27T20:14:42Z",
      "mergedAt": "2024-06-27T20:14:42Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "b734d43439a29e7ae42702bb715c5391895828f5"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Instead of a separate raw_type field, we'll just allow the nae to be a union of enum and uint64.",
          "createdAt": "2024-02-19T09:22:33Z",
          "updatedAt": "2024-02-19T09:22:33Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Heads up that I changed some of this in #417, by adding the `name_bytes` field (to be consistent with other places where we allow logging raw values), so that would replace the `raw_type` field proposed here. ",
          "createdAt": "2024-06-24T13:48:15Z",
          "updatedAt": "2024-06-24T13:48:15Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "> Heads up that I changed some of this in #417, by adding the `name_bytes` field (to be consistent with other places where we allow logging raw values), so that would replace the `raw_type` field proposed here.\r\n\r\nSo I've rebased and resolved the conflict. However, ISTM on a previous editor call we wanted to make this a union instead, so something like\r\n\r\n```\r\nH3Setting = {\r\n    name: H3SettingsName / uint64\r\n\r\n    value: uint64\r\n}\r\n```\r\n\r\nand obviously a text update to describe how to pick which one. \r\n\r\nDo we still want to do that?",
          "createdAt": "2024-06-26T18:32:08Z",
          "updatedAt": "2024-06-26T18:32:42Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, we've gradually moved away from that pattern IIRC (e.g., packet_number is now always a uint64 instead of uint64 / string to deal with IJSON). \r\n\r\nLooking through the other events, there are a few events that use this pattern (ResetStreamFrame, StopSendingFrame, ConnectionClosed, IPAddress), e.g., connectionclosed:\r\n\r\n```\r\n    ? connection_code: $TransportError /\r\n                       CryptoError /\r\n                       uint32\r\n    ? application_code: $ApplicationError /\r\n                        uint32\r\n```\r\n\r\nBut most events that need something like this, use the \r\n\r\n```\r\nfield: string\r\nfield_bytes: hexstring\r\n```\r\n\r\nOR\r\n\r\n```\r\nfield: string\r\nfield_bytes: uint64\r\n```\r\n\r\nIt seems like ideally we'd just have a single way of dealing with these. I'm leaning more towards the explicit extra `field_bytes` pattern, to make things explicit that this is (likely) an \"unexpected\" value that's likely to cause problems + to prevent tools from having to special case types for fields (at least most of the time). \r\n\r\nIf you agree, then we should merge this PR as-is (or with my proposed changes in the upcoming review ;)) and then I can make a new PR adding new `XYZ_bytes` fields to the non-conformant events. \r\n\r\n",
          "createdAt": "2024-06-27T12:10:07Z",
          "updatedAt": "2024-06-27T12:10:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I'm more than happy to go with this direction right now. Suggestions merged so I think GTG",
          "createdAt": "2024-06-27T16:32:38Z",
          "updatedAt": "2024-06-27T16:32:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5uKtoc",
          "commit": {
            "abbreviatedOid": "e372a1a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-29T10:11:55Z",
          "updatedAt": "2024-01-29T10:12:01Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Nit: Not sure I like `type_` here... it isn't called that in 9114 (there it's more `identifier`) and to align with `name` above and other similar fields, I'd go with `name_value` maybe? ",
              "createdAt": "2024-01-29T10:11:55Z",
              "updatedAt": "2024-01-29T10:12:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5uL-dC",
          "commit": {
            "abbreviatedOid": "e372a1a"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-29T13:06:31Z",
          "updatedAt": "2024-01-29T13:06:32Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "`name` or `identifier` seems fine to me. I was checking the IANA table which uses slightly different terms and it threw me off",
              "createdAt": "2024-01-29T13:06:32Z",
              "updatedAt": "2024-01-29T13:06:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5xeDMQ",
          "commit": {
            "abbreviatedOid": "bb64ace"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Make sure that the setting names can also be extended by future docs (before this was just `text` so was implicit, but now with the enum, we need to be explicit with a CDDL type socket)",
          "createdAt": "2024-02-27T14:39:05Z",
          "updatedAt": "2024-06-27T12:12:21Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nregistered) in the \"HTTP/3 Settings\" registry maintained at\r\n```",
              "createdAt": "2024-02-27T14:39:05Z",
              "updatedAt": "2024-06-27T12:12:21Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n    ? name: $H3SettingsName\r\n```",
              "createdAt": "2024-06-27T12:11:06Z",
              "updatedAt": "2024-06-27T12:12:21Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n$H3SettingsName /= \"settings_qpack_max_table_capacity\" /\r\n```",
              "createdAt": "2024-06-27T12:11:32Z",
              "updatedAt": "2024-06-27T12:12:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_7NiV",
          "commit": {
            "abbreviatedOid": "911647d"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good indeed. Feel free to merge, I'll open another issue to change the others and then later a PR to actually do so as well :) ",
          "createdAt": "2024-06-27T18:34:48Z",
          "updatedAt": "2024-06-27T18:34:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 384,
      "id": "PR_kwDOCrLn6M5lQ135",
      "title": "Tweak trigger_frame_type field and add it to connection_closed",
      "url": "https://github.com/quicwg/qlog/pull/384",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Tweaks the language related to the ConnectionCloseFrame trigger_frame_type\r\nand adds it to connection_closed event.\r\n\r\nCloses #366",
      "createdAt": "2024-01-28T19:17:39Z",
      "updatedAt": "2024-02-28T13:56:17Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "28a34e234e0414aba447a106a1558d2cbce4c666",
      "headRepository": "quicwg/qlog",
      "headRefName": "connection_closed-frame-trigger",
      "headRefOid": "67e91a8b8d6424b65a8cc3723e44eb290da32960",
      "closedAt": "2024-02-28T13:56:17Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While I like the general prose editorial work, I'm personally not too convinced that we need the `trigger_frame_type` on the `connectivity` event. As stated elsewhere, you rarely get all combined information from a single qlog event, and you often need to look at surrounding events for more low-level info (in this case: a field specifically on the CONNECTION_CLOSE frame). \r\n\r\nWhile I'm not terribly opposed to it, I'd still like to not add to the `connectivity` event, but do keep the editorial work with the CONNECTION_CLOSE frame (and maybe just reference that for the `connectivity` event?)",
          "createdAt": "2024-01-29T09:58:58Z",
          "updatedAt": "2024-01-29T09:58:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "> While I'm not terribly opposed to it, I'd still like to not add to the `connectivity` event, but do keep the editorial work with the CONNECTION_CLOSE frame (and maybe just reference that for the `connectivity` event?)\r\n\r\nMakes sense, I spun it off to its own PR https://github.com/quicwg/qlog/pull/386. \r\n\r\nIf we want to do a cross reference from connection_closed, then lets do that separate",
          "createdAt": "2024-01-29T15:30:45Z",
          "updatedAt": "2024-01-29T15:32:19Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As explained above, I think we should close this without action (i.e., don't add `trigger_frame_type` to `connection_closed`)",
          "createdAt": "2024-02-19T09:27:32Z",
          "updatedAt": "2024-02-19T09:27:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 385,
      "id": "PR_kwDOCrLn6M5lQ4We",
      "title": "Create ALPNIdentifier type to allow bytes or string presentation",
      "url": "https://github.com/quicwg/qlog/pull/385",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "ALPN IDs aren't guaranteed to be safe text, so allow logging the byte\r\nsequence. However, don't force endpoint to do that if their willing\r\nto do some safety checking or safe encoding.\r\n\r\nCloses #368\r\n",
      "createdAt": "2024-01-28T19:53:23Z",
      "updatedAt": "2024-02-05T09:53:35Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "391958c3917b29147b303457cee9a9e6c1cafeae",
      "headRepository": "quicwg/qlog",
      "headRefName": "alpn-hex",
      "headRefOid": "1d4bb45e8fece62d6ff24a85d112fb9564edae65",
      "closedAt": "2024-02-05T09:53:32Z",
      "mergedAt": "2024-02-05T09:53:32Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "78652accdd424309e8c7d180f0c5b585b6a7de00"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5uKuxp",
          "commit": {
            "abbreviatedOid": "c22705e"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-01-29T10:13:57Z",
          "updatedAt": "2024-01-29T10:18:12Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nThe `ALPNIdentifier`` type supports either format.\r\n```",
              "createdAt": "2024-01-29T10:13:57Z",
              "updatedAt": "2024-01-29T10:18:12Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\n  ? byte_value: hexstring\r\n  ? string_value: text\r\n```\r\n\r\nNot the biggest fan of having \"string\" or \"bytes\" directly, as these are sometimes reserved keywords in programming languages.",
              "createdAt": "2024-01-29T10:16:28Z",
              "updatedAt": "2024-01-29T10:18:12Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nThe `ALPNIDentifier`` type supports either format. Implementations SHOULD log at least one format, but MAY log both or none.\r\n```",
              "createdAt": "2024-01-29T10:17:22Z",
              "updatedAt": "2024-01-29T10:18:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5uMa_3",
          "commit": {
            "abbreviatedOid": "1d4bb45"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-29T14:02:25Z",
          "updatedAt": "2024-01-29T14:02:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5vAFUL",
          "commit": {
            "abbreviatedOid": "1d4bb45"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-05T09:50:19Z",
          "updatedAt": "2024-02-05T09:50:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 386,
      "id": "PR_kwDOCrLn6M5lVxRF",
      "title": "Improve text in ConnectionCloseFrame",
      "url": "https://github.com/quicwg/qlog/pull/386",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Spun off from https://github.com/quicwg/qlog/pull/384",
      "createdAt": "2024-01-29T15:29:56Z",
      "updatedAt": "2024-01-29T15:53:22Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "391958c3917b29147b303457cee9a9e6c1cafeae",
      "headRepository": "quicwg/qlog",
      "headRefName": "connection_closed-editorial",
      "headRefOid": "7654ae11e7d26b588d5820cb5a0b62e6305805ab",
      "closedAt": "2024-01-29T15:52:33Z",
      "mergedAt": "2024-01-29T15:52:33Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "28a34e234e0414aba447a106a1558d2cbce4c666"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5uNQpC",
          "commit": {
            "abbreviatedOid": "7654ae1"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-29T15:32:31Z",
          "updatedAt": "2024-01-29T15:34:14Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "if?",
              "createdAt": "2024-01-29T15:32:31Z",
              "updatedAt": "2024-01-29T15:34:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5uNUjN",
          "commit": {
            "abbreviatedOid": "7654ae1"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-29T15:39:18Z",
          "updatedAt": "2024-01-29T15:39:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5uNdav",
          "commit": {
            "abbreviatedOid": "7654ae1"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-29T15:53:22Z",
          "updatedAt": "2024-01-29T15:53:22Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Oh I missed this, sorry. \r\n\r\nWe seem to use of mix of \"if\" and \"when\" throught the docs. We should do a consistency pass as followup.",
              "createdAt": "2024-01-29T15:53:22Z",
              "updatedAt": "2024-01-29T15:53:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 388,
      "id": "PR_kwDOCrLn6M5mBMRY",
      "title": "Explain 64-bit I-JSON issues but don't embed that in CDDL",
      "url": "https://github.com/quicwg/qlog/pull/388",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Alternative to #359.\r\n\r\nI-JSON can mess with big numbers and we can't constrain the range.\r\nWe don't want to mandate bigint support on anyone. We don't want\r\nto make non-JSON serializers/parsers have to worry about stringified\r\nnumbers - so modifying the CDDL directly seems off.\r\n\r\nThere's lots of ways that implementations can internally handle values,\r\nwe don't care much about that here. For interop, settle on allow JSON parsers\r\nto write uint64 as strings if they want to. Make it clear that parsers\r\nshould expect that, unless they have some non-standard way of knowing.\r\n\r\nFixes #229\r\n",
      "createdAt": "2024-02-05T12:44:51Z",
      "updatedAt": "2024-02-19T09:25:02Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "724f324d9cf756d06a742d00611b995929085096",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-uint64-cddl-duality",
      "headRefOid": "c252137a0c1b48488fda8f89a8c54afe0dafce46",
      "closedAt": "2024-02-19T09:24:59Z",
      "mergedAt": "2024-02-19T09:24:59Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "a6c9a3f0c49a16921e862c00332476b83de6db42"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "those suggestions make it better, thanks",
          "createdAt": "2024-02-06T15:30:10Z",
          "updatedAt": "2024-02-06T15:30:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5vCvck",
          "commit": {
            "abbreviatedOid": "57f8ac0"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I can live with the high-level approach here, but think the prose needs a bit of work to be clearer about the intent (see suggestions). ",
          "createdAt": "2024-02-05T14:46:10Z",
          "updatedAt": "2024-02-05T14:49:25Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nuint64 values using JSON strings. qlog parsers, therefore, SHOULD support\r\n```\r\n\r\nNot entirely sure that covers the entire load, but `JSON parsers` is also not quite correct I'd say :) ",
              "createdAt": "2024-02-05T14:46:10Z",
              "updatedAt": "2024-02-05T14:49:41Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\ninformation indicating that neither the serializer nor parser are constrained by\r\n```",
              "createdAt": "2024-02-05T14:47:56Z",
              "updatedAt": "2024-02-05T14:49:25Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nparsing of uint64 values from JSON strings or JSON numbers unless there is out-of-band\r\n```",
              "createdAt": "2024-02-05T14:48:40Z",
              "updatedAt": "2024-02-05T14:49:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5whrxW",
          "commit": {
            "abbreviatedOid": "c252137"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-19T08:58:11Z",
          "updatedAt": "2024-02-19T08:58:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 389,
      "id": "PR_kwDOCrLn6M5mOBkJ",
      "title": "remove token from packet_{sent, received}, use field on PacketHeader",
      "url": "https://github.com/quicwg/qlog/pull/389",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #122. Closes #123.",
      "createdAt": "2024-02-07T05:25:57Z",
      "updatedAt": "2024-02-07T10:27:20Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "724f324d9cf756d06a742d00611b995929085096",
      "headRepository": "quicwg/qlog",
      "headRefName": "token-in-header",
      "headRefOid": "500a165ffca8702c282b78c452d27cba3e1f5654",
      "closedAt": "2024-02-07T10:27:20Z",
      "mergedAt": "2024-02-07T10:27:20Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "19d0867ac95b5460340e4817f913a85c9783ab7a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5vTtgo",
          "commit": {
            "abbreviatedOid": "500a165"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-07T10:20:22Z",
          "updatedAt": "2024-02-07T10:20:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 390,
      "id": "PR_kwDOCrLn6M5mODcR",
      "title": "key_updated / key_discarded: rename generation to key_phase",
      "url": "https://github.com/quicwg/qlog/pull/390",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #376. Also changing the type to uint64, since I don't see why the number of key updates would be limited to MaxUint32.",
      "createdAt": "2024-02-07T05:34:26Z",
      "updatedAt": "2024-02-08T02:03:58Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "724f324d9cf756d06a742d00611b995929085096",
      "headRepository": "quicwg/qlog",
      "headRefName": "key-phases",
      "headRefOid": "e421812eaae9ab48c6452a8653896039e1797e61",
      "closedAt": "2024-02-08T02:03:57Z",
      "mergedAt": "2024-02-08T02:03:57Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "dd8882eb422692b671cff724fae1a7711579a548"
      },
      "comments": [
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": "Looks good to me.\r\n\r\nMy understanding of how these events will be used is something like (for a client):\r\n\r\n```\r\nt=0: Initial EL provisioned; key_updated(client_initial_secret, new=...)\r\nt=0: Initial EL provisioned; key_updated(server_initial_secret, new=...)\r\n\r\n...\r\n\r\nt=a: Handshake EL provisioned; key_updated(client_handshake_secret, new=...)\r\nt=a; Handshake EL provisioned; key_updated(server_handshake_secret, new=...)\r\n\r\n...\r\n\r\nt=b; Initial EL dropped; key_discarded(client_initial_secret)\r\nt=b; Initial EL dropped; key_discarded(server_initial_secret)\r\n\r\n...\r\n\r\nt=c; 1-RTT EL provisioned, key_updated(client_1rtt_secret, generation=0, new=...)\r\nt=c; 1-RTT EL provisioned; key_updated(server_1rtt_secret, generation=0, new=...)\r\n\r\n...\r\n\r\nt=d; Handshake EL dropped; key_discarded(client_handshake_secret)\r\nt=d; Handshake EL dropped; key_discarded(server_handshake_secret)\r\n\r\n...\r\nKey update:\r\n\r\nt=m; Key update; key_updated(client_1rtt_secret, generation=1, old=..., new=...)\r\nt=m; Key update; key_updated(server_1rtt_secret, generation=1, old=..., new=...)\r\n(previous keys are kept around for a while to handle in-flight packets)\r\n\r\nt=n; Key update completed; key_discarded(client_1rtt_secret, generation=0)\r\nt=n; Key update completed; key_discarded(server_1rtt_secret, generation=0)\r\n```\r\n\r\nThis works and gives good understanding to a qlog consumer of when a set of keys is available and handles time periods where multiple keys are available well. LGTM.",
          "createdAt": "2024-02-07T10:38:06Z",
          "updatedAt": "2024-02-07T10:38:06Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "The important part here is that the key phase keeps increasing:\r\n```\r\nKey update:\r\n\r\nt=m; Key update; key_updated(client_1rtt_secret, key_phase=1, old=..., new=...)\r\nt=m; Key update; key_updated(server_1rtt_secret, key_phase=1, old=..., new=...)\r\n\r\nt=m; Key update; key_updated(client_1rtt_secret, key_phase=2, old=..., new=...)\r\nt=m; Key update; key_updated(server_1rtt_secret, key_phase=2, old=..., new=...)\r\n\r\nt=m; Key update; key_updated(client_1rtt_secret, key_phase=3, old=..., new=...)\r\nt=m; Key update; key_updated(server_1rtt_secret, key_phase=3, old=..., new=...)",
          "createdAt": "2024-02-08T02:03:08Z",
          "updatedAt": "2024-02-08T02:03:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5vTqzh",
          "commit": {
            "abbreviatedOid": "e421812"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, but I'd like to have approval from @hlandau on this as well to confirm it solves his original issue (somehow can't assign him as a reviewer though...) ",
          "createdAt": "2024-02-07T10:14:38Z",
          "updatedAt": "2024-02-07T10:15:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 392,
      "id": "PR_kwDOCrLn6M5nPOpx",
      "title": "CONNECTION_CLOSE frame tidyup",
      "url": "https://github.com/quicwg/qlog/pull/392",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "* Import CryptoError into allowed values\r\n* Remove `error_code_value` field as its redundant\r\n\r\nFixes #391\r\n",
      "createdAt": "2024-02-19T03:35:45Z",
      "updatedAt": "2024-02-19T09:21:48Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "dd8882eb422692b671cff724fae1a7711579a548",
      "headRepository": "quicwg/qlog",
      "headRefName": "connection-close-frame",
      "headRefOid": "24b5ceb15d4b22892badc25b247840e1e9e80763",
      "closedAt": "2024-02-19T09:21:42Z",
      "mergedAt": "2024-02-19T09:21:42Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "23ff60205e4f2a46285a87102b3c119af75afcd1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5whkZJ",
          "commit": {
            "abbreviatedOid": "24b5ceb"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-19T08:43:44Z",
          "updatedAt": "2024-02-19T08:43:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 393,
      "id": "PR_kwDOCrLn6M5nPPzU",
      "title": "fix QUIC-TLS refs",
      "url": "https://github.com/quicwg/qlog/pull/393",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Builds are reporting a conflict",
      "createdAt": "2024-02-19T03:41:53Z",
      "updatedAt": "2024-02-19T09:17:48Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "dd8882eb422692b671cff724fae1a7711579a548",
      "headRepository": "quicwg/qlog",
      "headRefName": "fix-build-error",
      "headRefOid": "996f34cc651d0a0149b0dc752d0d89f1a2b22c13",
      "closedAt": "2024-02-19T09:17:44Z",
      "mergedAt": "2024-02-19T09:17:44Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "0b9a6eb196c45cde26b6feddbcacb1876d770540"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5whkzs",
          "commit": {
            "abbreviatedOid": "996f34c"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-19T08:44:35Z",
          "updatedAt": "2024-02-19T08:44:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 394,
      "id": "PR_kwDOCrLn6M5nPVpk",
      "title": "s/PacketNumberSpace.application_data/application_data",
      "url": "https://github.com/quicwg/qlog/pull/394",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #372\n",
      "createdAt": "2024-02-19T04:12:29Z",
      "updatedAt": "2024-02-19T09:18:30Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "dd8882eb422692b671cff724fae1a7711579a548",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-cddl-indirection",
      "headRefOid": "5605b9e0e1bb0319359ba1e454c21ddb45c5fa6c",
      "closedAt": "2024-02-19T09:18:09Z",
      "mergedAt": "2024-02-19T09:18:09Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "56856eceb3bcca220fc756de2d1a359c0f954279"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5whj_D",
          "commit": {
            "abbreviatedOid": "5605b9e"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-19T08:42:50Z",
          "updatedAt": "2024-02-19T08:42:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 395,
      "id": "PR_kwDOCrLn6M5nPZJO",
      "title": "State clearly what lengths mean for stream and datagram data moved",
      "url": "https://github.com/quicwg/qlog/pull/395",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Addresses part of #375",
      "createdAt": "2024-02-19T04:29:20Z",
      "updatedAt": "2024-10-18T13:53:29Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "65c9758f20ef1cf485990cd2db39941820071e21",
      "headRepository": "quicwg/qlog",
      "headRefName": "stream-datagram-data-lengths",
      "headRefOid": "832bf3beefa85c1b04bef11679d8b2b752d9144e",
      "closedAt": "2024-10-18T13:53:25Z",
      "mergedAt": "2024-10-18T13:53:24Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "47c49c346f0c15864f8154c570e0139a3dfd8a49"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed during editorial meeting:\r\nI'm not the biggest fan of current text since it isn't clear for all the possible uses (e.g., `transport` to `application` strips QUIC level stuff but keeps H3 frame headers, while `application` to `user` also strips those out etc.). Maybe best to word it in terms of \"only the payload is moved to the higher layer\" or something like that? ",
          "createdAt": "2024-02-19T09:44:19Z",
          "updatedAt": "2024-02-19T09:44:19Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "> I'm not the biggest fan of current text since it isn't clear for all the possible uses (e.g., transport to application strips QUIC level stuff but keeps H3 frame headers, while application to user also strips those out etc.).\r\n\r\nThis is the QUIC document, so the intent of the proposed text\r\n\r\n> There are no packet or frame headers and length values in the `length` or `raw` fields MUST reflect that.\r\n\r\nis that it is solely in the scope of QUIC packets.\r\n\r\nNow you mention it, I don't actually think the `user` location is suitable for the `$DataLocation` type. QUIC streams and datagrams don't mean anything without an application protocol. And how an application protocol uses them is specific to its definition. To use HTTP/3 as an example, I'm never going to pass QUIC stream or datagram data directly to a user. I'm going to pass them:\r\n\r\n* HTTP request or response messages\r\n* HTTP datagrams\r\n* GOAWAY\r\n\r\nThere are HTTP/3 qlog events for each of these. \r\n\r\nEven an extension like WebTransport is going to pass WebTransport stream data, not raw QUIC. In which case, qlog for that extension should probably definine its own event type too.\r\n",
          "createdAt": "2024-07-03T13:34:51Z",
          "updatedAt": "2024-07-03T13:34:51Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This is the QUIC document, so the intent of the proposed text is that it is solely in the scope of QUIC packets.\r\n\r\nThat's conceptually true, but doesn't really help us here? it's still unclear what this means when you pass data from `application` to `user`, so it doesn't solve the original issue in #375 .\r\n\r\n--- \r\n\r\nThen, IIUC, your solution to that specifically is to remove the `user` option in the `from` and `to` and only keep it to `network, transport, application` since there it's clear what should/shouldn't be included. \r\n\r\nYou argue that `application` to `user` doesn't make much sense for `quic:stream_data_moved` in the first place, since you're not passing QUIC stuff up to user, but application stuff. That is of course true.\r\n\r\nThe problem there is that we don't have something like `h3:data_moved` at this point in the HTTP/3 doc. We only have `h3:frame_parsed`, which doesn't necessarily indicate when the data is upstreamed to `user`. \r\n\r\nThe original design of `transport:data_moved` was to be re-usable across all of this (so it really wasn't intended to be `quic:stream_data_moved` but instead more like `generic:data_moved`). \r\n\r\n---\r\n\r\nWith all that said, I can see 4 options:\r\n\r\n1. Keep the current *_data_moved events in `quic` but make clear they can be used for app-level data as well but that they only pass the PAYLOAD of lower layers, not all packet/frame/whatever headers (my original proposal above)\r\n2. Remove `user` as an option here and create an equivalent `h3:data_moved` event that has 3 targets: `user`, `application`, and `transport`. Not sure if we need an `h3:datagram_data_moved` and `h3:stream_data_moved` split here...\r\n3. Remove `user` as an option here and just leave it at that (so have no explicit way of indicating when data was passed from H3 to the user application). If needed, that can be added in a later extension. \r\n4. Move the *_data_moved events to the generic category in the main document so they're re-usable across protocols. This is more akin to the original design intent, but gets annoying because you'd remove the `stream_id` field for example and lose the distinction between `stream_data_moved` and `datagram_data_moved`.\r\n\r\nI currently lean towards either 1 or 3. \r\n",
          "createdAt": "2024-10-12T19:19:35Z",
          "updatedAt": "2024-10-12T19:19:35Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I went for option 3\r\n\r\n> Remove user as an option here and just leave it at that (so have no explicit way of indicating when data was passed from H3 to the user application). If needed, that can be added in a later extension.\r\n\r\nand pushed a commit. I think this is the simplest way to resolve the matter,",
          "createdAt": "2024-10-18T13:17:52Z",
          "updatedAt": "2024-10-18T13:17:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5_7Pzd",
          "commit": {
            "abbreviatedOid": "64255e9"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "See my latest comment in the thread (which I forgot to submit as an actual review, apparently)",
          "createdAt": "2024-06-27T18:37:19Z",
          "updatedAt": "2024-06-27T18:37:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M6NvyA-",
          "commit": {
            "abbreviatedOid": "832bf3b"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-18T13:41:44Z",
          "updatedAt": "2024-10-18T13:41:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 396,
      "id": "PR_kwDOCrLn6M5nPjy8",
      "title": "Add fin and reset_stream fields",
      "url": "https://github.com/quicwg/qlog/pull/396",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #375.\r\n\r\nPer the discussion, it can be useful to know when an application triggers a\r\nstream close, or when it receives one, without having to do offset/length maths.\r\n\r\nI omitted stop_sending in this commit because it seems a little bit of a stretch,\r\nmainly because it's wire image has no offset or final size. Also, STOP_SENDING\r\nrelates to asking the peer to do something, which further complicates the\r\n(potential) use of offset and length fields.\r\n\r\nAn alternative would be to keep `fin` here but define new events for reset and\r\nstop. Those could both contain from, to and error fields but only the reset\r\nwould have offset and length.\r\n",
      "createdAt": "2024-02-19T05:15:49Z",
      "updatedAt": "2024-07-03T13:20:53Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "b734d43439a29e7ae42702bb715c5391895828f5",
      "headRepository": "quicwg/qlog",
      "headRefName": "stream-data-moved-flags",
      "headRefOid": "d96aa973243c8bd963c6a6de057aed457d3aec42",
      "closedAt": "2024-07-03T13:20:50Z",
      "mergedAt": "2024-07-03T13:20:50Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "5f73ff0b06d0f98ead177e5177de1ddb2be300c7"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during editorial meeting:\r\nKeep `fin` here, move `reset_stream` and `stop_sending` to separate event(s) (possibly having 2 because reset_stream is so different from stop_sending).\r\n\r\n@marten-seemann it would help to have a quick mockup of what `reset_stream_at` might look like (not because we want to add it to main qlog yet, but if the current design would be compatible with that, it would be nice :) ",
          "createdAt": "2024-02-19T09:33:11Z",
          "updatedAt": "2024-02-19T09:33:11Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually discussed further during meeting, opinions changed :) \r\n\r\nI'm now in favor of something quite general, say:\r\n\r\n```\r\n? additional_info: [+ text]\r\n\r\n; possible values for QUIC/H3 currently are \"fin_set\", \"stream_reset\", \"stream_reset_at\", \"stop_sending\"\r\n```\r\n\r\nWith the idea that other events can be used to determine what exactly happened (e.g., look at the actual STREAM_RESET frame) and keep this event what it was originally intended for: showing when which type of data (and now info) is communicated between the layers (as this doesn't always coincide with packet sent/received)",
          "createdAt": "2024-02-28T10:53:12Z",
          "updatedAt": "2024-02-28T10:53:12Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "> See latest comment (which I, again, didn't submit as an actual review apparently)\r\n\r\nDo you mean this one https://github.com/quicwg/qlog/pull/396#issuecomment-1968725064, or something else?",
          "createdAt": "2024-06-28T13:15:07Z",
          "updatedAt": "2024-06-28T13:15:07Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "that one indeed :) sorry for the confusion",
          "createdAt": "2024-06-28T13:17:44Z",
          "updatedAt": "2024-06-28T13:17:44Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Reading between the lines, I think we don't want a `text` type but extendable socket-mabobs. Lemme give that a crack.",
          "createdAt": "2024-06-28T13:24:19Z",
          "updatedAt": "2024-06-28T13:24:19Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5_7RrU",
          "commit": {
            "abbreviatedOid": "2c2322a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "See latest comment (which I, again, didn't submit as an actual review apparently)",
          "createdAt": "2024-06-27T18:41:02Z",
          "updatedAt": "2024-06-27T18:41:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M6Ah9Sj",
          "commit": {
            "abbreviatedOid": "d96aa97"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-03T12:59:55Z",
          "updatedAt": "2024-07-03T12:59:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 400,
      "id": "PR_kwDOCrLn6M5oTvLX",
      "title": "Make Parameters events extensible",
      "url": "https://github.com/quicwg/qlog/pull/400",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #176.\r\n\r\nThis uses CDDL's \"group socket\" (https://datatracker.ietf.org/doc/html/rfc8610#section-3.9) to allow others to later specify additional parameters that can be logged to the event in a typed/explicit way. \r\n\r\nExample in a later document (say for reliable stream resets):\r\n\r\n```\r\n$$quic-parametersset-extension //= (\r\n  reliable_stream_reset: text\r\n)\r\n```\r\n\r\nOne conceptual \"downside\" is that by definition all fields in the extension will be optional, even if not preceded by a `?` (as in the example above). This is because the extension isn't yet known when processing the current definition, so it has to be either `?` (optional) or `*` (0 or more, which is used here as it's recommended by RFC8610). I don't see this as a major issue, but something to be aware of. \r\n\r\n",
      "createdAt": "2024-02-29T15:26:25Z",
      "updatedAt": "2024-03-04T11:42:34Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "1803174140b198b76cc4258773878ad76afe50ff",
      "headRepository": "quicwg/qlog",
      "headRefName": "tp-extension",
      "headRefOid": "3f4d668923aba4a4e66bd82163ae324f7b969cd8",
      "closedAt": "2024-03-04T11:42:31Z",
      "mergedAt": "2024-03-04T11:42:31Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "2d6f293b8408c5554a2698e10bee8a26a3ea732b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5x_0m2",
          "commit": {
            "abbreviatedOid": "3f4d668"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM but I didn't really check the scripts that closely",
          "createdAt": "2024-03-02T02:46:07Z",
          "updatedAt": "2024-03-04T11:39:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 401,
      "id": "PR_kwDOCrLn6M5oUCxD",
      "title": "Enforce stricter extensibility for ProtocolEventData",
      "url": "https://github.com/quicwg/qlog/pull/401",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #192.\r\n\r\nCurrently, `$ProtocolEventData` accepts just about anything, which makes it extensible but very useless for any real validation.\r\n\r\nBy not explicitly assigning the `* text => any` to the type in the main doc, we keep the extensibility, but improve validation capabilities.\r\n\r\nThis also properly adds the Generic and Simulation events to the `$ProtocolEventData`, which they really should have been from the start ;) ",
      "createdAt": "2024-02-29T16:10:07Z",
      "updatedAt": "2024-06-27T18:45:23Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "1803174140b198b76cc4258773878ad76afe50ff",
      "headRepository": "quicwg/qlog",
      "headRefName": "strict-eventbody",
      "headRefOid": "0febd1d851b1bac5d01dd2196a6100139e61dce3",
      "closedAt": "2024-06-27T18:45:23Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Was subsumed by #417 (in a very similar fashion), closing without action. ",
          "createdAt": "2024-06-27T18:44:58Z",
          "updatedAt": "2024-06-27T18:44:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5x_2hl",
          "commit": {
            "abbreviatedOid": "0febd1d"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-02T03:03:14Z",
          "updatedAt": "2024-03-02T03:03:14Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I recall we had some previous discussion about this. I'd never acknowledged this trigger field (from a serializer or parser perspective). Are we aware of anyone using it?",
              "createdAt": "2024-03-02T03:03:14Z",
              "updatedAt": "2024-03-02T03:03:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5yEpje",
          "commit": {
            "abbreviatedOid": "0febd1d"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-04T09:27:28Z",
          "updatedAt": "2024-03-04T09:27:28Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "To clarify, up till now every instance of a `$ProtocolEventData`, such as parsing a H3 frame https://quicwg.org/qlog/draft-ietf-quic-qlog-h3-events.html#section-4.6, had an optional `trigger` field. This is not something I ever implemented for quiche. For serialization, that's no problem because the field can be omitted in logs. But for parsing, it is a problem, because I would not deal well with a qlog file that included such triggers.\r\n\r\nThat's my faul for omitting it from the quiche implementation in the first place. I support this change removing `trigger`, it means my implementation will be correct. However, anyone that is currently making use of `trigger` in event bodies may be surprised by this change. Hence the ask, is anyone using it?\r\n\r\nIf they are, it would be good to know if its inside a few events, or many. We can always add an explicit trigger to events where it makes sense. I don't think it makes sense for there to be a blanket trigger.",
              "createdAt": "2024-03-04T09:27:28Z",
              "updatedAt": "2024-03-04T09:27:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5yE1H8",
          "commit": {
            "abbreviatedOid": "0febd1d"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-04T09:48:27Z",
          "updatedAt": "2024-03-04T09:48:27Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Discussed during editors meeting: \r\n@LPardue will send an email to the mailing list detailing this change and asking for feedback before merging. ",
              "createdAt": "2024-03-04T09:48:27Z",
              "updatedAt": "2024-03-04T09:48:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M59mfAB",
          "commit": {
            "abbreviatedOid": "0febd1d"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-10T09:23:21Z",
          "updatedAt": "2024-06-10T09:23:21Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Email was sent May 13th (https://mailarchive.ietf.org/arch/msg/quic/e4CnmK2_NUrNAHOlo9Q-fV1JW6g/) without comments from the WG. So it seems this should be a go.",
              "createdAt": "2024-06-10T09:23:21Z",
              "updatedAt": "2024-06-10T09:23:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M59miDN",
          "commit": {
            "abbreviatedOid": "0febd1d"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-10T09:27:27Z",
          "updatedAt": "2024-06-10T09:27:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 402,
      "id": "PR_kwDOCrLn6M5obGzg",
      "title": "Clarify serialization expectations across documents",
      "url": "https://github.com/quicwg/qlog/pull/402",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #357.\r\n\r\nI'm not particularly fond of the prose in the main schema, but I think it covers the load for what I'd prefer to say (instead of linking to the current subdocuments directly). \r\n\r\nCC @LPardue ",
      "createdAt": "2024-03-01T15:42:41Z",
      "updatedAt": "2024-03-04T11:26:57Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "1803174140b198b76cc4258773878ad76afe50ff",
      "headRepository": "quicwg/qlog",
      "headRefName": "serialization-recommendations",
      "headRefOid": "97e7926fdeebe4db63e1eb51c9934200c4cb787c",
      "closedAt": "2024-03-04T11:26:53Z",
      "mergedAt": "2024-03-04T11:26:53Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "3b9f5afad8c28556f271526217312b72f9185c49"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5x_2qU",
          "commit": {
            "abbreviatedOid": "f66a59c"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2024-03-02T03:07:43Z",
          "updatedAt": "2024-03-02T03:07:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 403,
      "id": "PR_kwDOCrLn6M5obO8U",
      "title": "Add clarification on is_coalesced and add it to more events",
      "url": "https://github.com/quicwg/qlog/pull/403",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #370. \r\n\r\nThis better explains the intent behind `is_coalesced` and also adds it to other events that *probably* should have it as well. \r\n\r\nI'm not sure anymore that this is the best design however, since there's a lot of duplication for a feature that isn't THAT important to track...\r\n\r\nI wonder if we can get away with something like \"If implementations don't want to track individual datagram IDs, but still want to indicate a packet was/could be coalesced, they can use datagram_id = -1 to indicate this\" (and then of course we remove `is_coalesced` and make `datagram_id` an `int32` instead of `uint32`).\r\n\r\nThat would be a bit dirty... but reduce the confusion and duplication considerably? ",
      "createdAt": "2024-03-01T16:02:36Z",
      "updatedAt": "2024-07-08T19:12:47Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "ae561a7deb68edc145bdbd03a01afb06b132fc68",
      "headRepository": "quicwg/qlog",
      "headRefName": "coalesce-clarification",
      "headRefOid": "e29c9bf491a50fc4fcae798570e1daa5ea423836",
      "closedAt": "2024-07-08T19:12:47Z",
      "mergedAt": "2024-07-08T19:12:47Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "fed5cc1154c2c8b42756bab923212174364714fc"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another option is to ditch the whole concept of `datagram_id` and only keep `is_coalesced` (`datagram_id` is only used to properly track coalescing anyway)",
          "createdAt": "2024-03-04T09:12:35Z",
          "updatedAt": "2024-03-04T09:12:35Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I think the new text that clarifies how the datagram_id is used is good. I don't think we benefit from the `is_coalesced` field, since it's a subset of a subset i.e. if an implementation cares enough about logging coalescing, then it can do the work to add datagram_id support.",
          "createdAt": "2024-03-04T09:16:13Z",
          "updatedAt": "2024-03-04T09:16:13Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the comments on #370 @HLandau and @LPardue.\r\n\r\nI agree and have removed `is_coalesced` in my latests commit. I've also moved all the text related to this to the `datagramssent` event so it's less spread-out. \r\n\r\nPTAL and see if the explanation there around `datagram_id` is clear enough. Thanks :) ",
          "createdAt": "2024-03-06T10:26:05Z",
          "updatedAt": "2024-03-06T10:26:05Z"
        },
        {
          "author": "hlandau",
          "authorAssociation": "NONE",
          "body": "Looks good. Might want to rename this issue.",
          "createdAt": "2024-03-06T20:56:21Z",
          "updatedAt": "2024-03-06T20:56:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5ycg0d",
          "commit": {
            "abbreviatedOid": "1d98de2"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-06T15:28:35Z",
          "updatedAt": "2024-03-06T15:28:36Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "This second SHOULD kudt seems to be repeating the requirement above?",
              "createdAt": "2024-03-06T15:28:35Z",
              "updatedAt": "2024-03-06T15:28:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5ydFQJ",
          "commit": {
            "abbreviatedOid": "1d98de2"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-06T16:20:53Z",
          "updatedAt": "2024-03-06T16:20:53Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "It is; I wasn't aware that's a problem. Would you prefer to change the first `SHOULD` to a `should` or the second one here? ",
              "createdAt": "2024-03-06T16:20:53Z",
              "updatedAt": "2024-03-06T16:20:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5ydcRY",
          "commit": {
            "abbreviatedOid": "1d98de2"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-06T16:54:58Z",
          "updatedAt": "2024-03-06T16:54:59Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "So I might be misreading what you intend but with current text but I could even go further with something like\r\n\r\n```suggestion\r\nqlog defines it's own mechanism for tracking coalescing across packet-level and\r\ndatagram-level qlog events, a \"datagram identifier\" carried in `datagram_id` fields.\r\nqlog implementations that want to track coalescing can use this mechanism, the \r\nselectiion of specific and locally-unique `datagram_id` values is an implementation\r\nchoice.\r\n```",
              "createdAt": "2024-03-06T16:54:59Z",
              "updatedAt": "2024-03-06T16:54:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5ydcbb",
          "commit": {
            "abbreviatedOid": "1d98de2"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-06T16:55:16Z",
          "updatedAt": "2024-03-06T16:55:16Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "I made a suggestion PTAL",
              "createdAt": "2024-03-06T16:55:16Z",
              "updatedAt": "2024-03-06T16:55:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5ylG0X",
          "commit": {
            "abbreviatedOid": "1d98de2"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-07T12:39:10Z",
          "updatedAt": "2024-03-07T12:39:10Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "I feel that loses a (potentially obvious, but still good to call out) aspect in how to use the `datagram_id` though... so maybe something like this then:\r\n\r\n```suggestion\r\nqlog defines its own mechanism for tracking coalescing across packet-level and\r\ndatagram-level qlog events, a \"datagram identifier\" carried in `datagram_id`\r\nfields. qlog implementations that want to track coalescing can use this\r\nmechanism, where multiple packet-level events sharing the same `datagram_id`\r\nindicate they were coalesced in the same UDP datagram. The selection of specific\r\nand locally-unique `datagram_id` values is an implementation choice. \r\n```",
              "createdAt": "2024-03-07T12:39:10Z",
              "updatedAt": "2024-03-07T12:39:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5yltfK",
          "commit": {
            "abbreviatedOid": "1d98de2"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-07T13:49:17Z",
          "updatedAt": "2024-03-07T13:49:18Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Looks good",
              "createdAt": "2024-03-07T13:49:17Z",
              "updatedAt": "2024-03-07T13:49:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 404,
      "id": "PR_kwDOCrLn6M5obRRL",
      "title": "Fix legacy connection_id_updated text",
      "url": "https://github.com/quicwg/qlog/pull/404",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #346.\r\n\r\n@LPardue PTAL if this is clear :) ",
      "createdAt": "2024-03-01T16:08:38Z",
      "updatedAt": "2024-03-04T11:24:58Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "1803174140b198b76cc4258773878ad76afe50ff",
      "headRepository": "quicwg/qlog",
      "headRefName": "connidupdated-fix",
      "headRefOid": "b949dc971126cf1d6039d4cd39e77a808001d1cf",
      "closedAt": "2024-03-04T11:24:47Z",
      "mergedAt": "2024-03-04T11:24:47Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "799129d24335b450c7b89a35850c7ad61138cbe2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5yAawR",
          "commit": {
            "abbreviatedOid": "b949dc9"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2024-03-02T19:36:03Z",
          "updatedAt": "2024-03-02T19:36:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5yAlqa",
          "commit": {
            "abbreviatedOid": "b949dc9"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-02T22:42:30Z",
          "updatedAt": "2024-03-02T22:42:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 406,
      "id": "PR_kwDOCrLn6M5omOtr",
      "title": "Clarify RawInfo calculation for QUIC packets",
      "url": "https://github.com/quicwg/qlog/pull/406",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #273.\r\n\r\nPTAL @marten-seemann ",
      "createdAt": "2024-03-04T14:26:14Z",
      "updatedAt": "2024-03-08T22:41:31Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "2d6f293b8408c5554a2698e10bee8a26a3ea732b",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-calcnotes",
      "headRefOid": "1fb94a3ea9457a457f470f67be3e8385b5993642",
      "closedAt": "2024-03-08T15:28:19Z",
      "mergedAt": "2024-03-08T15:28:19Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "57b679678b44d80234a0e10a08e53fe5ef9e7532"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5yJ9xi",
          "commit": {
            "abbreviatedOid": "928bcd9"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-04T19:50:06Z",
          "updatedAt": "2024-03-04T19:50:06Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nFor the purposes of calculating the lengths in fields of type RawInfo (as\r\n```",
              "createdAt": "2024-03-04T19:50:06Z",
              "updatedAt": "2024-03-04T19:50:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5yJ-LP",
          "commit": {
            "abbreviatedOid": "928bcd9"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-04T19:51:00Z",
          "updatedAt": "2024-03-04T19:51:00Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Should we join this sentence with the preceding para?",
              "createdAt": "2024-03-04T19:51:00Z",
              "updatedAt": "2024-03-04T19:51:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5yuMPT",
          "commit": {
            "abbreviatedOid": "1fb94a3"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-08T11:46:30Z",
          "updatedAt": "2024-03-08T11:46:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5yzADR",
          "commit": {
            "abbreviatedOid": "1fb94a3"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you @rmarx!",
          "createdAt": "2024-03-08T22:41:31Z",
          "updatedAt": "2024-03-08T22:41:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 407,
      "id": "PR_kwDOCrLn6M5omVo1",
      "title": "Clarify UDP datagram namespace",
      "url": "https://github.com/quicwg/qlog/pull/407",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #323.\r\n\r\nI decided not to use the full `udp:` namespace since we might need to properly define that later (if qlog for UDP is ever done proper). So I now just added the prefix `udp_` to the necessary events to make clear these are UDP datagrams, not QUIC datagram frames. ",
      "createdAt": "2024-03-04T14:40:35Z",
      "updatedAt": "2024-03-06T10:34:06Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "2d6f293b8408c5554a2698e10bee8a26a3ea732b",
      "headRepository": "quicwg/qlog",
      "headRefName": "udp-namespace",
      "headRefOid": "fe27479e04006919dc7cba999ed76658d0dba4a1",
      "closedAt": "2024-03-06T10:34:03Z",
      "mergedAt": "2024-03-06T10:34:03Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "f24ca16d26ff317defde9c5920d68d4c81c81f88"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5yJ9mR",
          "commit": {
            "abbreviatedOid": "fe27479"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I think whatever we pick is an odd compromise but in the interest of getting things done, this rename is the shortest option that makes things clear without generating a lot of effort. :shipit: ",
          "createdAt": "2024-03-04T19:49:38Z",
          "updatedAt": "2024-03-04T19:49:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 408,
      "id": "PR_kwDOCrLn6M5om0_T",
      "title": "Clarify congestion_state_updated usage",
      "url": "https://github.com/quicwg/qlog/pull/408",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #246.",
      "createdAt": "2024-03-04T15:43:41Z",
      "updatedAt": "2024-03-06T10:32:22Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "2d6f293b8408c5554a2698e10bee8a26a3ea732b",
      "headRepository": "quicwg/qlog",
      "headRefName": "cc-state-guidance",
      "headRefOid": "551dee843462111b031f0c80c849f51f1e9bab3c",
      "closedAt": "2024-03-06T10:32:18Z",
      "mergedAt": "2024-03-06T10:32:18Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "c697710ef953dac7fb5c2bb12a913d65f19494f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5yJ8vf",
          "commit": {
            "abbreviatedOid": "551dee8"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2024-03-04T19:47:28Z",
          "updatedAt": "2024-03-04T19:47:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 409,
      "id": "PR_kwDOCrLn6M5o0RJD",
      "title": "Clarify paramers_set merging of parameter values",
      "url": "https://github.com/quicwg/qlog/pull/409",
      "state": "OPEN",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #398.\r\n\r\nPTAL @hlandau. \r\n\r\nThe suggestion of using `null` as a JSON value in #398 makes conceptual sense, but not really since we're working with CDDL to define the events and their fields, as it doesn't easily allow to make a type \"nullable\" for something like this. \r\n\r\nAs such, I changed the recommendation to explicitly setting the default value if needed; I hope that's acceptable. \r\n\r\nFor the rest, I mostly just used your text with minor editorial changes. ",
      "createdAt": "2024-03-06T09:49:24Z",
      "updatedAt": "2024-06-10T09:29:11Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "67a777edcf575ce9f163b4382ec1e4afed57d6bb",
      "headRepository": "quicwg/qlog",
      "headRefName": "clarify-paramsmerge",
      "headRefOid": "6256a65b46d37392fb79016bcf1285e3d52eabb6",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5yaovB",
          "commit": {
            "abbreviatedOid": "6256a65"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-03-06T12:17:51Z",
          "updatedAt": "2024-03-06T12:17:54Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I find this very confusing. Why do we need to log anything at all? There are not many parameters that are negotiated (idle timeout. anything else?).\r\n\r\nIf we really want to log this, let's create a separate owner value for that.",
              "createdAt": "2024-03-06T12:17:51Z",
              "updatedAt": "2024-03-06T12:17:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5yapGK",
          "commit": {
            "abbreviatedOid": "6256a65"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-06T12:18:36Z",
          "updatedAt": "2024-03-06T12:18:36Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "This doesn't work for 0-RTT, does it?",
              "createdAt": "2024-03-06T12:18:36Z",
              "updatedAt": "2024-03-06T12:18:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5ybLNz",
          "commit": {
            "abbreviatedOid": "6256a65"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-06T13:10:33Z",
          "updatedAt": "2024-03-06T13:10:34Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "0-RTT is special cased in the paragraph below this one and should use `parameters_restored`. (That's not to say that that is 100% watertight, I might have missed something in that flow, but it's indeed not the intent to use only `parameters_set` for 0-RTT and this new text is not intended for 0-RTT indeed).",
              "createdAt": "2024-03-06T13:10:34Z",
              "updatedAt": "2024-03-06T13:10:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5yfR8r",
          "commit": {
            "abbreviatedOid": "6256a65"
          },
          "author": "hlandau",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-06T20:57:24Z",
          "updatedAt": "2024-03-06T20:57:24Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "No objection to a separate owner value",
              "createdAt": "2024-03-06T20:57:24Z",
              "updatedAt": "2024-03-06T20:57:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5yfSsX",
          "commit": {
            "abbreviatedOid": "6256a65"
          },
          "author": "hlandau",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "LGTM, though one comment",
          "createdAt": "2024-03-06T20:59:27Z",
          "updatedAt": "2024-03-06T20:59:38Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "If we don't support `null` I guess that means some default values (i.e., absence of a TP) might be unrepresentable in qlog.",
              "createdAt": "2024-03-06T20:59:27Z",
              "updatedAt": "2024-03-06T20:59:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5yf2-B",
          "commit": {
            "abbreviatedOid": "6256a65"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-06T22:26:03Z",
          "updatedAt": "2024-03-06T22:26:03Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I don't think this event should be logged more than once per connection. Transport parameters are only exchanged once, after all. If we have a separate owner value as suggested above, this property would also hold in qlog.",
              "createdAt": "2024-03-06T22:26:03Z",
              "updatedAt": "2024-03-06T22:26:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5yf3Ku",
          "commit": {
            "abbreviatedOid": "6256a65"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-06T22:26:40Z",
          "updatedAt": "2024-03-06T22:26:40Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "`negotiated`? I don't think this is super valuable to log, since it can easily be derived from the two `parameters_set` events anyway.",
              "createdAt": "2024-03-06T22:26:40Z",
              "updatedAt": "2024-03-06T22:26:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5ylIsl",
          "commit": {
            "abbreviatedOid": "6256a65"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-07T12:43:18Z",
          "updatedAt": "2024-03-07T12:43:19Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "This event will be logged at least twice per connection by definition, since there are two sets of TPs: one for the local entity and one for the peer. This event also tracks more state than just transport parameters (e.g., TLS level params like resumption or early data) that are probably set in a different codepath/at a different time and benefit from having multiple `parameters_set`.\r\n\r\nI agree with the subset of your statement that the event probably shouldn't be logged more than once per connection for specific fields with the same owner though. \r\n\r\nStill, for me personally the most important part here is `If a parameter does not appear in a given parameters_set event, its value is unchanged from the previous event which set that parameter.` to help make clear that subsequent `parameters_set` do not invalidate earlier values, which I agree with @hlandau is not 100% clear right now. \r\n\r\n\r\n ",
              "createdAt": "2024-03-07T12:43:18Z",
              "updatedAt": "2024-03-07T12:43:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5ylKK9",
          "commit": {
            "abbreviatedOid": "6256a65"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-07T12:46:25Z",
          "updatedAt": "2024-03-07T12:46:25Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "So, I'm still not 100% sure what we're proposing here...\r\n\r\nOption A:\r\n- log `parameters_set` with owner=local for local value\r\n- log `parameters_set` with owner=remote for peer's value\r\n- log `parameters_set` with owner=negotiated for final value\r\n\r\nor Option B:\r\n- log `parameters_set` with owner=negotiated for local value\r\n- log `parameters_set` with owner=negotiated for peer's value\r\n- log `parameters_set` with owner=negotiated for final value\r\n\r\nor Option C:\r\n- log `parameters_set` with owner=negotiated final value\r\n\r\nI'm not sure I like C (lose quite some information there... don't know which values the peers proposed originally?).\r\nI'm also not sure how either A or B improves upon the proposed text though... you're still logging 3 events? ",
              "createdAt": "2024-03-07T12:46:25Z",
              "updatedAt": "2024-03-07T12:46:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5ylLIj",
          "commit": {
            "abbreviatedOid": "6256a65"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-07T12:48:32Z",
          "updatedAt": "2024-03-07T12:48:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I'm not sure I understand? Absence of a TP is simply that: absence of a TP in the `parameters_set`. \r\n\r\nWhether this means the TP was actually absent on the wire or whether the implementation didn't/couldn't log it is indeed unclear, but the qlogger can do what they want (e.g., also simply couldn't log `null`), so that's never fixable imo. \r\n\r\nIf you mean to say that the default value of a TP is `null`, then I'd say that derives from the RFC that defines the TP, and absence implies that value?",
              "createdAt": "2024-03-07T12:48:32Z",
              "updatedAt": "2024-03-07T12:52:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zsSZO",
          "commit": {
            "abbreviatedOid": "6256a65"
          },
          "author": "hlandau",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-16T07:30:54Z",
          "updatedAt": "2024-03-16T07:30:54Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I guess this is not so much a problem for TPs as they are only exchanged once. But it seems like this event is intended to be more general.\r\n\r\nFor other kinds of parameters which might be renegotiable I could see a problem if it is possible for a feature to transition from negotiated to the default/non-negotiated state.\r\n\r\nMaybe it is not a problem in practice? I'm just envisaging this event type being expanded to other things besides TPs in future.",
              "createdAt": "2024-03-16T07:30:54Z",
              "updatedAt": "2024-03-16T07:30:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M59mi_D",
          "commit": {
            "abbreviatedOid": "6256a65"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-10T09:29:11Z",
          "updatedAt": "2024-06-10T09:29:11Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "@marten-seemann : as discussed in the editor's meeting, PTAL and let me know which changes, if any, you'd like here. ",
              "createdAt": "2024-06-10T09:29:11Z",
              "updatedAt": "2024-06-10T09:29:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 412,
      "id": "PR_kwDOCrLn6M5p0H6D",
      "title": "Add raw bytes field support to CONNECTION_CLOSE.",
      "url": "https://github.com/quicwg/qlog/pull/412",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #411\r\n\r\nSame approach as the one we look for ALPNInformation. Allows endpoints to log either, because sometimes it is more useful to print and consume a string like \"It's borked\" than it's hex encoded equivalent.",
      "createdAt": "2024-03-16T04:25:27Z",
      "updatedAt": "2024-06-10T09:51:49Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "f0897c957124eede9dee76ab798b1bba99d53558",
      "headRepository": "quicwg/qlog",
      "headRefName": "utf-aint",
      "headRefOid": "e261f985058ca2cc1f17ade53b845ea56a5eeeb9",
      "closedAt": "2024-06-10T09:51:46Z",
      "mergedAt": "2024-06-10T09:51:46Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "13304c4dcdfff8e669a773e0e403f06a70665267"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not the biggest fan of this not using the same pattern as we did for ALPNInformation... which would be more like this:\r\n\r\n```\r\n...\r\n? reason: CloseReason\r\n...\r\n\r\nCloseReason = {\r\n    ? byte_value: hexstring\r\n    ? string_value: text\r\n}\r\n```\r\n\r\nIs there a particular reason to change from that established precedent? \r\n",
          "createdAt": "2024-03-16T11:03:22Z",
          "updatedAt": "2024-03-16T11:03:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The main reason (pun intended) is that the `QUICALPNInformation` event contains 3 instances of ALPNInformation, which would make a flatter structure really hard to describe. Here, there is only one instance of the reason, so it seems of less value to create another structure type to hold it. \r\n\r\nI won't defend that choice with much vigor if others prefer a Structured approach. ",
          "createdAt": "2024-03-16T11:33:50Z",
          "updatedAt": "2024-03-16T11:33:50Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't have a super-strong opinion on this, as this approach also makes sense. Especially seeing another need for this in https://github.com/quicwg/qlog/pull/414, we could reason this approach is the default, and ALPNInformation deviates from that for good reasons\u2122",
          "createdAt": "2024-03-18T10:19:14Z",
          "updatedAt": "2024-03-18T10:19:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5zsSRt",
          "commit": {
            "abbreviatedOid": "d6241e6"
          },
          "author": "hlandau",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-16T07:26:14Z",
          "updatedAt": "2024-03-16T07:26:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5zsSXz",
          "commit": {
            "abbreviatedOid": "d6241e6"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-03-16T07:29:50Z",
          "updatedAt": "2024-03-16T07:30:38Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I'd prefer to not rename this field.",
              "createdAt": "2024-03-16T07:29:50Z",
              "updatedAt": "2024-03-16T07:30:38Z"
            },
            {
              "originalPosition": 5,
              "body": "That's not how I read RFC 9000. The field SHOULD be UTF-8, so the expectation is that it actually is. We're just creating an escape hatch here in case this assumption doesn't hold.",
              "createdAt": "2024-03-16T07:30:35Z",
              "updatedAt": "2024-03-16T07:30:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zsSjo",
          "commit": {
            "abbreviatedOid": "d6241e6"
          },
          "author": "hlandau",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-16T07:31:56Z",
          "updatedAt": "2024-03-16T07:31:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Agreed - need better wording alignment",
              "createdAt": "2024-03-16T07:31:56Z",
              "updatedAt": "2024-03-16T07:31:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zsTk7",
          "commit": {
            "abbreviatedOid": "d6241e6"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-16T08:06:31Z",
          "updatedAt": "2024-03-16T08:06:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "If you're logging a reason sent by a peer you don't have any relationship with, there is no guarantee it is following the SHOULD. Therefore, it is only a possibility that the reason is presentable as UTF-8. I can't think of a more succint way to describe this possibility than the current text. If you have concrete suggestions for alternative text, please propose them :D",
              "createdAt": "2024-03-16T08:06:31Z",
              "updatedAt": "2024-03-16T08:06:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zsTnp",
          "commit": {
            "abbreviatedOid": "d6241e6"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-16T08:08:09Z",
          "updatedAt": "2024-03-16T08:08:10Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I can live with that",
              "createdAt": "2024-03-16T08:08:10Z",
              "updatedAt": "2024-03-16T08:08:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zsUID",
          "commit": {
            "abbreviatedOid": "d6241e6"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-16T08:26:52Z",
          "updatedAt": "2024-03-16T08:26:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Spoke offline with Marten and came up with a slight variant",
              "createdAt": "2024-03-16T08:26:52Z",
              "updatedAt": "2024-03-16T08:26:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zsVCk",
          "commit": {
            "abbreviatedOid": "33bf2bf"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-16T09:01:50Z",
          "updatedAt": "2024-03-16T09:01:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M59mTT6",
          "commit": {
            "abbreviatedOid": "33bf2bf"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "small nits",
          "createdAt": "2024-06-10T09:12:29Z",
          "updatedAt": "2024-06-10T09:12:51Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nfield. The `reason_bytes` field supports logging the raw bytes, which can be useful\r\n```",
              "createdAt": "2024-06-10T09:12:29Z",
              "updatedAt": "2024-06-10T09:12:51Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nwhen the value is not UTF-8 or when an endpoint does not want to decode it.\r\n```",
              "createdAt": "2024-06-10T09:12:39Z",
              "updatedAt": "2024-06-10T09:12:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M59mz_p",
          "commit": {
            "abbreviatedOid": "e261f98"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-10T09:51:31Z",
          "updatedAt": "2024-06-10T09:51:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 414,
      "id": "PR_kwDOCrLn6M5p2X21",
      "title": "Allow logging of header name and value bytes",
      "url": "https://github.com/quicwg/qlog/pull/414",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #413",
      "createdAt": "2024-03-17T02:05:57Z",
      "updatedAt": "2024-07-03T13:21:45Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "b734d43439a29e7ae42702bb715c5391895828f5",
      "headRepository": "quicwg/qlog",
      "headRefName": "http-fields-aint-strings",
      "headRefOid": "7ea43279bac07afc0f3a5db6013bbe34ff7abac2",
      "closedAt": "2024-07-03T13:21:42Z",
      "mergedAt": "2024-07-03T13:21:42Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "ae561a7deb68edc145bdbd03a01afb06b132fc68"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems like we've firmly settled on this pattern for this type of thing:\r\n\r\n```\r\nfield: string\r\nfield_bytes: hexstring\r\n```\r\n\r\nSo I think all that's needed here is indeed changing `name_text` and `value_text` to `name` and `value` + my and Marten's nits (transport > encode, and \"define valid\" and should be good to go :) ",
          "createdAt": "2024-06-27T18:48:57Z",
          "updatedAt": "2024-06-27T18:48:57Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I changed the text to make this all clearer (hopefully)",
          "createdAt": "2024-06-27T22:26:06Z",
          "updatedAt": "2024-06-27T22:26:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5zuJ8y",
          "commit": {
            "abbreviatedOid": "edd9600"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-17T13:25:30Z",
          "updatedAt": "2024-03-17T13:26:12Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nHTTP/3 can encode field names or values that are not valid; see {{Section 4.2\r\n```",
              "createdAt": "2024-03-17T13:25:30Z",
              "updatedAt": "2024-03-17T13:26:12Z"
            },
            {
              "originalPosition": 19,
              "body": "Can we avoid renaming the existing fields?",
              "createdAt": "2024-03-17T13:26:10Z",
              "updatedAt": "2024-03-17T13:26:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zyJn2",
          "commit": {
            "abbreviatedOid": "edd9600"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-03-18T10:15:57Z",
          "updatedAt": "2024-03-18T10:17:59Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Not valid what? Valid UTF-8? Valid semantically? valid in terms of range of bytes that are represented? etc.",
              "createdAt": "2024-03-18T10:15:57Z",
              "updatedAt": "2024-03-18T10:17:59Z"
            },
            {
              "originalPosition": 19,
              "body": "If we decide on using the same approach here as in https://github.com/quicwg/qlog/pull/412, and there we call it `reason + reason_bytes` instead of `reason_text + reason_bytes`, then yeah, we should be consistent here as well and keep `name + name_bytes + value + value_bytes`",
              "createdAt": "2024-03-18T10:17:45Z",
              "updatedAt": "2024-03-18T10:17:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M59m1We",
          "commit": {
            "abbreviatedOid": "edd9600"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-10T09:53:02Z",
          "updatedAt": "2024-06-10T09:53:03Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I'll change to use the old names",
              "createdAt": "2024-06-10T09:53:03Z",
              "updatedAt": "2024-06-10T09:53:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6AC9-h",
          "commit": {
            "abbreviatedOid": "6a6b240"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Mostly nits, so I'll go ahead and approve the general approach :) ",
          "createdAt": "2024-06-28T15:00:34Z",
          "updatedAt": "2024-06-28T15:05:52Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\n:path: /index.html\r\n```\r\n\r\nfor consistency with the example below (maybe even better to go for something like /my-resource ?",
              "createdAt": "2024-06-28T15:00:34Z",
              "updatedAt": "2024-07-03T12:57:15Z"
            },
            {
              "originalPosition": 83,
              "body": "```suggestion\r\nCharacters in the\r\n```\r\n\r\nThis didn't flow well with the rest of the paragraph, so trying to group a bit more logically. ",
              "createdAt": "2024-06-28T15:02:03Z",
              "updatedAt": "2024-06-28T15:05:52Z"
            },
            {
              "originalPosition": 82,
              "body": "```suggestion\r\nrange are invalid and result in the message being treated as malformed. It can however be useful to also log these invalid HTTP fields.\r\n```",
              "createdAt": "2024-06-28T15:03:58Z",
              "updatedAt": "2024-06-28T15:05:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 415,
      "id": "PR_kwDOCrLn6M5p4Ast",
      "title": "Define extension schema policy and registry",
      "url": "https://github.com/quicwg/qlog/pull/415",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Alternative to #284.\r\n\r\nThis follows Lennox's suggestion to take influence from RFC 8285 and reference\r\nextension schema according to a URI. IETF documents can use URNs under a formal\r\nnamespace, and as such we register a new `qlog` URN Sub-namespace for\r\nRegistered Protocol Parameter Identifiers.\r\n\r\nFixes #283",
      "createdAt": "2024-03-17T23:59:57Z",
      "updatedAt": "2024-07-08T20:16:34Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "f0897c957124eede9dee76ab798b1bba99d53558",
      "headRepository": "quicwg/qlog",
      "headRefName": "extension-schema",
      "headRefOid": "788f0c9dae18eb5911d0caeceadae8d4fd795355",
      "closedAt": "2024-07-08T20:16:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "@JonathanLennox I tried to borrow a lot from RFC 8285 but not take it fully verbatim. Would welcome your thoughts.",
          "createdAt": "2024-03-18T00:09:13Z",
          "updatedAt": "2024-03-18T00:09:13Z"
        },
        {
          "author": "JonathanLennox",
          "authorAssociation": "NONE",
          "body": "This matches my suggestion, looks good to me!",
          "createdAt": "2024-03-18T07:38:06Z",
          "updatedAt": "2024-03-18T07:38:06Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I pushed some changes to update the text in h3, if we like that approach I will carry it over to the quic doc.",
          "createdAt": "2024-03-19T05:42:42Z",
          "updatedAt": "2024-03-19T05:42:42Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "On thinking some more, I think allowing extension of categories with new events is a complication we can avoid. Specifically, allowing different documents to extend a category risks non-unique event names if the document author is not careful with type names. For example. if `ext-schema-a` and `ext-schema-b` both extend `h3` with a `my-ev-type` event (concating to the name `h3:my-ev-type`, then they'll be fine until someone tries to use both. It's going to be very hard to police event type names, especially for private extensions.\r\n\r\nInstead, we can enforce that new schema need to define new globally-unique categories. For example, if we wanted to add new quic events in the future as part of a rollup extension schema, we could define `quic-2030`, `recovery-2030` etc. Adding this to the guidance pushes private extensions to avoid the problem, and requires standard extensions to do it.\r\n\r\nI pushed an update that attempts to explain all this.\r\n\r\n",
          "createdAt": "2024-04-01T11:36:02Z",
          "updatedAt": "2024-04-01T11:36:02Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "> As you'll see, a few remarks, most tiny, but a few that imo should be tackled.\r\n> \r\n> I'm personally not a big fan of disallowing extensions to extend existing protocol/category namespaces... I get the rationale, but I think this will cause unnecessary churn and overhead for implementers (listing all extension docs in `additional_event_schema`, requesting addition to IANA, tools having to decide how to validate etc.). That said... I don't really have a better solution atm to the issues this solves :(\r\n\r\nI don't think it's that much extra work really. An IANA registration request is as simple as an email that will be forwarded to the designated experts (probably you, me and anyone else that wants to volunteer). Lazy implementations can omit the additional schema field at the cost of risk that tools will break. \r\n\r\nIf we allowed extension to categories while only recommending that `additional_event_schema` is provided, we risk tools having to deal with ambiguous types, which sucks. \r\n\r\n> \r\n> If we do keep this, imo we do need to add some guidance on naming of new extensions for existing qlog definitions.\r\n> \r\n> For example, https://www.ietf.org/archive/id/draft-ietf-tsvwg-careful-resume-07.html#name-cr_phase-event, is really a good fit for \"quic:recovery\", but wouldn't be able to just use that... so what should it do?\r\n> \r\n> It can't just do `quic-ext:recovery` because that would pollute `quic-ext` for all other extensions... it can't do `quic-rfcXYZA:recovery` because juck. It might do `quic-careful-resume:recovery` but this should probably be recommended by the main spec to prevent a weird growth of these things going forward (UNLESS you expect all this to be caught in the IANA registration process, where expert reviews can catch `quic-ext` and require it be renamed to something like `quic-careful-resume`? even then though... a bit of prose with an example could be nice here).\r\n\r\nThe careful resume event is a good example but I disagree about your analysis. The definition of the event leaves it completely ambiguous about what category it belongs to, so it is unclear what it's serialized name would be. You seem to assume the event is for QUIC, but careful resume is a transport-independent.  So, assuming we get this PR hammered out, the careful resume document would have clearer guidance to follow about defining an extension schema. My recommendation would for it to define a new URI like `urn:ietf:params:qlog:careful-resume` and category identifier `cr`, then the event type could be `phase_updated` and it's serialized name would be `cr:phase_updated`. \r\n\r\n",
          "createdAt": "2024-04-02T10:46:28Z",
          "updatedAt": "2024-04-02T10:46:28Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If we allowed extension to categories while only recommending that additional_event_schema is provided, we risk tools having to deal with ambiguous types, which sucks.\r\n\r\nI agree, and that's why I said I also don't see a better solution (sadly) :) \r\n\r\n> The careful resume event is a good example but I disagree about your analysis\r\n\r\nSo ok, maybe careful-resume can get away with its own identifier outside of quic :) but then let's assume a loss-bits extension that is specific to QUIC's header and defines the `loss_bits_updated` event. Then it's still a bit unclear if they should have `urn:ietf:params:qlog:loss-bits` or `urn:ietf:params:qlog:quic-loss-bits` or `urn:ietf:params:qlog:quic-ext-loss-bits` or... (or if this even matters as much ;)) and thus if we should have a bit of guidance for that (i.e., extensions of existing protocols/categories)\r\n\r\n",
          "createdAt": "2024-04-02T12:38:40Z",
          "updatedAt": "2024-04-02T12:38:51Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I don't think the schema identifier is that important, it's just a unique thing. \r\n\r\nGuidance for category identifiers would be useful but I'm not sure we have enough experience to be that helpful. It should reflect the expert guidance, the the category name should be specific and unique, and also keep in mind that it can't be extended in future. So if there's a loss bit extension schema that wanted to have different categories if could have urn:ietf:params:qlog:loss-bits#quic-loss-bits and urn:ietf:params:qlog:loss-bits#sctp-loss-bits.\r\n\r\nThat does raise the question whether we should allow adding new categories to existing schema. That seems something that is OK. ",
          "createdAt": "2024-04-02T14:13:05Z",
          "updatedAt": "2024-04-02T14:13:05Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As mentioned above, I remain on the edge on what exactly we would allow to be extended by new documents and why...\r\n\r\n\r\nRecent comments from Lucas say things to the effect of\r\n\r\n> That does raise the question whether we should allow adding new categories to existing schema. That seems something that is OK.\r\n    \r\nbut [earlier he said](https://github.com/quicwg/qlog/pull/415/#issuecomment-2029624210) it's not ok to add new events to existing categories, because you get ambiguous event names (category + type)\r\n    \r\n > Specifically, allowing different documents to extend a category risks non-unique event names if the document author is not careful with type names\r\n\r\nSo there's an important nuance here: **extending an existing _category_ in an existing schema with new event types is NOT the same as extending an existing _schema_ with a new category and new events types**\r\n        \r\n For example:\r\n\r\n        urn:ietf:params:qlog:http is the DOC/schema\r\n        urn:ietf:params:qlog:http#h3 is the category\r\n        urn:ietf:params:qlog:http#h3:frame-created is the type\r\n        \r\nIf you allow new docs to re-use the h3 category:\r\n        \r\n        Document L defines:\r\n        urn:ietf:params:qlog:http#h3:new-event-Z\r\n\r\n        Document K also defines:\r\n        urn:ietf:params:qlog:http#h3:new-event-Z\r\n        \r\nThen you indeed get collisions / ambiguities (because both would use the URI urn:ietf:params:qlog:http#h3 in `additional_event_schemas`). So far, so good, and I agree that's a problem.\r\n\r\nHOWEVER, I don't really see how only re-using the schema itself would (completely) prevent that problem, _except for IANA enforcing uniqueness._ \r\n\r\nIf you allow new docs to only re-use the http schema and not the h3 category:\r\n\r\n        Document A defines:\r\n        urn:ietf:params:qlog:http#h4:new-event-X\r\n        urn:ietf:params:qlog:http#h4:new-event-Z\r\n\r\n        Document B also defines:\r\n        urn:ietf:params:qlog:http#h4:new-event-Y \r\n        urn:ietf:params:qlog:http#h4:new-event-Z         \r\n\r\nAs long as both docs only define unique event types (new-event-X and -Y here), then indeed, no problem. But there's nothing stopping two independent docs from ending up with `h4:new-event-Z` independently. \r\n\r\nAt that point, you fall back to \"whoever is first to register the h4 category identifier with IANA\". If that's the intent, then I can understand that and (probably) live with it. But that isn't entirely clear from the current text imo (at least the part that it's allowed to extend an existing schema. So I'd add an example to say that another new document could register `urn:ietf:params:qlog:john#cleese` event though `urn:ietf:params:qlog:john` already existed. And ideally also the opposite, explicitly saying that a new document is NOT allowed to just add a new event type `new-event-S` to `urn:ietf:params:qlog:john#goodman`, even if there isn't such an event in currently \"known\" documents that use :john\r\n\r\nI mainly want to confirm the intent here and make sure we make this as clear as possible, since even I am having a bit of a hard time fully nailing it down :) \r\n    ",
          "createdAt": "2024-06-26T15:03:06Z",
          "updatedAt": "2024-06-26T15:09:18Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Putting aside the actual text I wrote for a moment, the logical structure I have in mind is\r\n\r\n```\r\nschema namespace\r\n  category identifier\r\n    event type\r\n```\r\n \r\nThen, the `additional_event_schemas` lists URIs that must include the schema namespace and category identifier but not the event type.\r\n \r\nIETF documents intended to be RFC, should use a URI of format `urn:ietf:params:qlog:<schema namespace>#<category identifier`. \r\n\r\nAny other legal URI is also allowed for private extensions. There is still a requirement that the URI includes both the `<schema namespace>` `#<category identifier>`. \r\n\r\nFor IETF documents, the need to register schema namespace and category identifier (the URI is a byproduct of this, not the definition IMO, and that is what is causing some friction IMO). If a namespace already exists, it should IMO be allowed to add categories to it. IANA can deal with that. \r\n\r\nIf somehow the IETF has adopted work items are are, in parallel, defining conflicting things (schema namespaces, category identiers, or event types) that is something I believe can be resolved through the regular standards process. Its likely a simple change that benefits both parties. I expect this to happen well in advance of the formal IANA action (i.e. during WG review, or LC).\r\n\r\nOne way to present this a bit more clearly is an IANA table that focuses more on the components and less on the URI e.g.\r\n\r\n| Schema Namespace | Category ID | Description | Link |\r\n|------------------|-----------------|---------------------|-------|\r\n| quic | recover | For events related to QUIC recovery | RFC link |\r\n| rick | pickle |  For events related to pickled Richards | RFC link |\r\n\r\nIn other words, it won't matter if a schema namespace exists or not for practical purposes. Experts will still need to check if the addition of a category to an existing namespace makes sense for logical purposes though.\r\n\r\n",
          "createdAt": "2024-06-26T17:26:06Z",
          "updatedAt": "2024-06-26T17:26:26Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reading your last reply, I think I correctly understand your intent, and I think it's the right way forward indeed :) So now we just need to clarify the text to make the intent clearer to new readers. As I said up-top somewhere as well, explaining things like you do above with `urn:ietf:params:qlog:<schema namespace>#<category identifier>` would already help a lot.\r\n\r\n---\r\n\r\nAnother thing I think we should do, is have the main schema also define its own schema namespace (\"main\") with two categories (\"generic\" and \"simulation\"). Currently, these are kind of just \"there\" and implied... We can then use those as examples without having to go out-document, and it's more consistent/cleaner. \r\n\r\nIt also makes it possible to indicate in `additional_event_schemas` whether or not you're actually using \"generic\" and \"simulation\" events (probably not). That DOES mean we should re-bikeshed the `additional` part of the name (and the idea of only having \"extension\" schemas) maybe :)\r\n",
          "createdAt": "2024-06-27T09:26:01Z",
          "updatedAt": "2024-06-27T09:26:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Yeah this all makes sense to me, #rollsupsleaves",
          "createdAt": "2024-06-27T12:29:13Z",
          "updatedAt": "2024-06-27T12:29:13Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "closing in favor of #424, which took the same premise but ironed out the issues raised here. ",
          "createdAt": "2024-07-08T20:16:33Z",
          "updatedAt": "2024-07-08T20:16:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5zxuVp",
          "commit": {
            "abbreviatedOid": "42d9348"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Couple of things here that could use clarification, but in general I of course think this is a good approach :) ",
          "createdAt": "2024-03-18T09:36:38Z",
          "updatedAt": "2024-03-18T10:06:11Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "at the risk of being a pedantic bikeshedder here: schemas? schemata? Or is schema canonically seen as both singular and plural in proper English? ",
              "createdAt": "2024-03-18T09:36:38Z",
              "updatedAt": "2024-03-18T10:06:11Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nNew event documents SHOULD be defined using an extension schema, using the annotations\r\n```\r\n\r\nNot clear it's not the individual events that are affected, but rather groups of events?",
              "createdAt": "2024-03-18T09:38:29Z",
              "updatedAt": "2024-03-18T10:06:11Z"
            },
            {
              "originalPosition": 60,
              "body": "unclear what \"element\" is referring to specifically here...",
              "createdAt": "2024-03-18T10:00:03Z",
              "updatedAt": "2024-03-18T10:06:11Z"
            },
            {
              "originalPosition": 63,
              "body": "this could do with an example maybe? not sure what that would look like if you're for example using quic events... would you need to list #connectivity and #transport as separate subentries in `additional_event_schema` or not? Where do you draw the line? ",
              "createdAt": "2024-03-18T10:01:31Z",
              "updatedAt": "2024-03-18T10:06:11Z"
            },
            {
              "originalPosition": 74,
              "body": "```suggestion\r\n`urn:ietf:params:qlog:` followed by a registered, descriptive name.\r\n```\r\n\r\nPrefix should end with `:` no?",
              "createdAt": "2024-03-18T10:02:03Z",
              "updatedAt": "2024-03-18T10:06:11Z"
            },
            {
              "originalPosition": 89,
              "body": "This could do with an extension of the example to also show at least one domainname-based extension (i.e., things that are not defined in RFCs), with the mmyyyy date in the URI",
              "createdAt": "2024-03-18T10:04:20Z",
              "updatedAt": "2024-03-18T10:06:11Z"
            },
            {
              "originalPosition": 154,
              "body": "```suggestion\r\nYamamoto, Christian Huitema, Hugo Landau, and Jonathan Lennox for their feedback\r\n```",
              "createdAt": "2024-03-18T10:05:34Z",
              "updatedAt": "2024-03-18T10:06:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zzrtO",
          "commit": {
            "abbreviatedOid": "3b822f0"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T13:13:42Z",
          "updatedAt": "2024-03-18T13:13:42Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Thought a bit more on this. What I think we want is for logical groups of qlog events to be defined under a single schema. There should not be a restriction that a single IETF document defines only a single schema - for example, we might want to have a single document that defines events for a bunch of QUIC extensions and split them out by extension-specific schemas.\r\n\r\nI don't think the current text, or the proposal, articulate this well. Will try to come up with a some different text.",
              "createdAt": "2024-03-18T13:13:42Z",
              "updatedAt": "2024-03-18T13:13:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zzsR4",
          "commit": {
            "abbreviatedOid": "3b822f0"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T13:14:36Z",
          "updatedAt": "2024-03-18T13:14:36Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "nor me, I copy-pasted it from RFC 8285. Will change.",
              "createdAt": "2024-03-18T13:14:36Z",
              "updatedAt": "2024-03-18T13:14:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zzvKi",
          "commit": {
            "abbreviatedOid": "3b822f0"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T13:19:40Z",
          "updatedAt": "2024-03-18T13:19:40Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Good point, this was another copy-paste. I could argue either way. On one hand, it seems annoying to have to expand out all the categories in e.g. our QUIC events specification. On the other hand, the capability to state what events a logging endpoint _could_ have used has come up in other discussions, and this fragment identifier seems like a solution. It isn't clear to me though if the fragments need to be registered explicitly, so I'll follow up with the RTP folks.\r\n\r\nI agree an example would be useful if we want to keep this feature.",
              "createdAt": "2024-03-18T13:19:40Z",
              "updatedAt": "2024-03-18T13:19:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zzwX9",
          "commit": {
            "abbreviatedOid": "3b822f0"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T13:21:20Z",
          "updatedAt": "2024-03-18T13:21:20Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "`schemas` seems most correct, will fix.\r\n\r\nWhile we are here, I wonder if CDDL has a URI type?",
              "createdAt": "2024-03-18T13:21:20Z",
              "updatedAt": "2024-03-18T13:21:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zz0-e",
          "commit": {
            "abbreviatedOid": "3b822f0"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T13:28:55Z",
          "updatedAt": "2024-03-18T13:29:00Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Is there an option to say: if you don't define # or ?, then you mean EVERYTHING included in the URI. If you want to select only specific parts, use # or ? to specify that? \r\n\r\ne.g., urn:ietf:params:qlog:quic means ALL QUIC events, while urn:ietf:params:qlog:quic#recovery means ONLY the recovery events and nothing else? How does RFC 8285 manage such things?",
              "createdAt": "2024-03-18T13:28:55Z",
              "updatedAt": "2024-03-18T13:29:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zz2TW",
          "commit": {
            "abbreviatedOid": "42d9348"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T13:30:46Z",
          "updatedAt": "2024-03-18T13:30:47Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "What precisely do you mean by \"type\" here? ",
              "createdAt": "2024-03-18T13:30:46Z",
              "updatedAt": "2024-03-18T13:30:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5zz5fM",
          "commit": {
            "abbreviatedOid": "42d9348"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T13:32:45Z",
          "updatedAt": "2024-03-18T13:32:46Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Instead of `text` is there a `uri` or somthinh",
              "createdAt": "2024-03-18T13:32:45Z",
              "updatedAt": "2024-03-18T13:32:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5z0Db7",
          "commit": {
            "abbreviatedOid": "42d9348"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T13:38:06Z",
          "updatedAt": "2024-03-18T13:38:06Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Ah, lol :) Yes, there is one in the \"standard prelude\" here: https://www.rfc-editor.org/rfc/rfc8610.html#appendix-D\r\n\r\nDefined as `uri = #6.32(tstr)`. The #6.32 is a CBOR registration number/tag for the type, so it's basically saying `uri = tstr` (and above that, tstr = text), so `uri = text` :) ",
              "createdAt": "2024-03-18T13:38:06Z",
              "updatedAt": "2024-03-18T13:38:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5z7_4Q",
          "commit": {
            "abbreviatedOid": "3b822f0"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T03:37:53Z",
          "updatedAt": "2024-03-19T03:37:53Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Thanks for the clarification",
              "createdAt": "2024-03-19T03:37:53Z",
              "updatedAt": "2024-03-19T03:37:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5z8DXr",
          "commit": {
            "abbreviatedOid": "e8ae653"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T03:54:27Z",
          "updatedAt": "2024-03-19T03:54:27Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "This is an open question we should ask in the meeting",
              "createdAt": "2024-03-19T03:54:27Z",
              "updatedAt": "2024-03-19T03:54:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5z-1D_",
          "commit": {
            "abbreviatedOid": "36396a1"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T10:58:23Z",
          "updatedAt": "2024-03-19T10:58:23Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nof its extensions (see {{!EXTENDED-CONNECT=RFC9220}},\r\n```",
              "createdAt": "2024-03-19T10:58:23Z",
              "updatedAt": "2024-03-19T10:58:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M51exp7",
          "commit": {
            "abbreviatedOid": "42d9348"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-01T09:51:22Z",
          "updatedAt": "2024-04-01T09:51:22Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "I spoke with some people in the hallways. There's a reason that RFC 8285 does it that way, due to how RTP stuff works. However, everyone seemed to agree that requiring the full expansions wasn't that onerous and was more clear. Allowing the url without those seems like a microoptimization.\r\n\r\nThere's another reason the full expansion is nice. If any documents in the future extend a namespace, then its not clear what extensions are used or not. That makes the implicit include quite insipid.",
              "createdAt": "2024-04-01T09:51:22Z",
              "updatedAt": "2024-04-01T09:51:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M51m63H",
          "commit": {
            "abbreviatedOid": "889d6d4"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "As you'll see, a few remarks, most tiny, but a few that imo should be tackled.\r\n\r\nI'm personally not a big fan of disallowing extensions to extend existing protocol/category namespaces... I get the rationale, but I think this will cause unnecessary churn and overhead for implementers (listing all extension docs in `additional_event_schema`, requesting addition to IANA, tools having to decide how to validate etc.). That said... I don't really have a better solution atm to the issues this solves :( \r\n\r\nIf we do keep this, imo we do need to add some guidance on naming of new extensions for existing qlog definitions.\r\n\r\nFor example, https://www.ietf.org/archive/id/draft-ietf-tsvwg-careful-resume-07.html#name-cr_phase-event, is really a good fit for \"quic:recovery\", but wouldn't be able to just use that... so what should it do? \r\n\r\nIt can't just do `quic-ext:recovery` because that would pollute `quic-ext` for all other extensions... it can't do `quic-rfcXYZA:recovery` because juck. It might do `quic-careful-resume:recovery` but this should probably be recommended by the main spec to prevent a weird growth of these things going forward (UNLESS you expect all this to be caught in the IANA registration process, where expert reviews can catch `quic-ext` and require it be renamed to something like `quic-careful-resume`? even then though... a bit of prose with an example could be nice here). ",
          "createdAt": "2024-04-02T09:16:11Z",
          "updatedAt": "2024-04-02T09:44:16Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Not sure if this is actually an issue, but IIUC, this would mean that listing the H3 events in `additional_event_schemas` will lead to a URI like this:\r\n\r\n`urn:ietf:params:qlog:h3#h3` \r\n\r\nConceptually fine, but the duplication of h3 is a bit weird. Makes me wonder if in general we should go for the \"full acronym\" in the extension URI (i.e., http3 instead of h3, analogous to quic instead of q1)? ",
              "createdAt": "2024-04-02T09:16:11Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            },
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nAn extension schema defines one or more qlog event categories that can contain multiple\r\n```",
              "createdAt": "2024-04-02T09:17:57Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            },
            {
              "originalPosition": 66,
              "body": "```suggestion\r\nIt is not possible to extend an existing category, defined in a different document, with new events. Instead, extension\r\n```",
              "createdAt": "2024-04-02T09:18:32Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            },
            {
              "originalPosition": 67,
              "body": "```suggestion\r\nschemas MUST define new categories with globally unique identifiers. Per\r\n```",
              "createdAt": "2024-04-02T09:18:51Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            },
            {
              "originalPosition": 73,
              "body": "Not exactly sure what the intention is of including \"format\" here... might be confused with \"serialization format\", which is certainly not the intent. Replace with a different word or remove? ",
              "createdAt": "2024-04-02T09:21:29Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            },
            {
              "originalPosition": 77,
              "body": "```suggestion\r\nnames change ownership.) If the extension schema contains several event\r\n```",
              "createdAt": "2024-04-02T09:22:15Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            },
            {
              "originalPosition": 79,
              "body": "I wonder why we'd use an \"e.g.,\" here... are there other accepted options? if not, remove the e.g.,. If yes, I'd like to see at least one in the example :) ",
              "createdAt": "2024-04-02T09:24:00Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            },
            {
              "originalPosition": 84,
              "body": "```suggestion\r\nA log file that uses events from extension schemas SHOULD list all extension schema\r\n```",
              "createdAt": "2024-04-02T09:24:35Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            },
            {
              "originalPosition": 85,
              "body": "```suggestion\r\nidentifiers (potentially multiple per extension schema in the case multiple categories are used) in the `additional_event_schemas` field; see {{qlog-file-schema}}\r\n```\r\n\r\nI feel that at this point, there's lots of ambiguity between a \"schema identifier\" and a specification of it for a specific category and what should actually be listed in the `additional_event_schemas`. The example below makes it a bit clearer, but I think we need more in this prose as well. I think the above is the minimum we could get away with, but potentially more text is needed (and maybe a new term like \"category identifier\"?)",
              "createdAt": "2024-04-02T09:26:45Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            },
            {
              "originalPosition": 88,
              "body": "```suggestion\r\nIn the following example, a qlog file contains events defined in two hypothetical standardized\r\n```",
              "createdAt": "2024-04-02T09:27:13Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            },
            {
              "originalPosition": 106,
              "body": "```suggestion\r\n\"additional_event_schemas\": [\r\n                            \"urn:ietf:params:qlog:rick#roll\",\r\n                            \"urn:ietf:params:qlog:rick#astley\",\r\n                            \"urn:ietf:params:qlog:rick#moranis\",\r\n                            \"urn:ietf:params:qlog:john#doe\",\r\n                            \"urn:ietf:params:qlog:john#candy\",\r\n                            \"urn:ietf:params:qlog:john#goodman\",\r\n                            \"https://example.com/032024/pickle.html#pepper\",\r\n                            \"https://example.com/032024/pickle.html#lilly\",\r\n                            \"https://example.com/032024/pickle.html#rick\",\r\n                          ]\r\n```\r\n\r\nSince it's an example of a JSON serialized qlog file, it should be valid JSON. ",
              "createdAt": "2024-04-02T09:30:52Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            },
            {
              "originalPosition": 107,
              "body": "```suggestion\r\n~~~\r\n{: #additional-event-schema-ex title=\"Example of using the additional-event-schema field\"}\r\n```",
              "createdAt": "2024-04-02T09:32:11Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            },
            {
              "originalPosition": 141,
              "body": "```suggestion\r\n| Extension URI | Category Identifier(s) | Description | Reference |\r\n```",
              "createdAt": "2024-04-02T09:32:45Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            },
            {
              "originalPosition": 86,
              "body": "So here, I'm wondering if we should give guidance to tools on how to actually use the `additional_event_schemas` field? Like, they SHOULD use it to see if they support the listed event categories, but they SHOULD NOT bork on unexpected events (and rather just ignore them). \r\n\r\nput differently: I think we need to make clear that tools/users MUST NOT treat this as a fully qualified list and expect all/none events to be present, but rather more as a hint to further improve operations. ",
              "createdAt": "2024-04-02T09:35:30Z",
              "updatedAt": "2024-04-02T09:44:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M51njZQ",
          "commit": {
            "abbreviatedOid": "889d6d4"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T10:23:16Z",
          "updatedAt": "2024-04-02T10:23:16Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "yeah that makes sense",
              "createdAt": "2024-04-02T10:23:16Z",
              "updatedAt": "2024-04-02T10:23:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M51nkU0",
          "commit": {
            "abbreviatedOid": "889d6d4"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T10:25:03Z",
          "updatedAt": "2024-04-02T10:25:03Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I don't think we need the \"different document\" qualification, there may be no document at all for something like a private extension. The blanket rule is always the same, no extension.",
              "createdAt": "2024-04-02T10:25:03Z",
              "updatedAt": "2024-04-02T10:25:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M51nmVK",
          "commit": {
            "abbreviatedOid": "889d6d4"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T10:27:03Z",
          "updatedAt": "2024-04-02T10:27:03Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "lol, still a hangover from copy/paste. What we should say here is that a schema URI precisely identifies the category name and the event type(s) (the CDDL definition)",
              "createdAt": "2024-04-02T10:27:03Z",
              "updatedAt": "2024-04-02T10:27:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M51nnL9",
          "commit": {
            "abbreviatedOid": "889d6d4"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T10:28:44Z",
          "updatedAt": "2024-04-02T10:28:44Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "This was also a copy/paste. I don't see a good argument for allowing flexibility to be honest. How about we just restrict it to `#`?",
              "createdAt": "2024-04-02T10:28:44Z",
              "updatedAt": "2024-04-02T10:28:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M51nn7_",
          "commit": {
            "abbreviatedOid": "889d6d4"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T10:29:49Z",
          "updatedAt": "2024-04-02T10:29:49Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Yeah that would be good to have.",
              "createdAt": "2024-04-02T10:29:49Z",
              "updatedAt": "2024-04-02T10:29:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M57iAOs",
          "commit": {
            "abbreviatedOid": "2735dea"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-22T22:24:48Z",
          "updatedAt": "2024-05-22T22:24:48Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "how about `urn:ietf:params:qlog:http#h3`? That would make it easy to add support for other HTTP versions or extensions as new catagories",
              "createdAt": "2024-05-22T22:24:48Z",
              "updatedAt": "2024-05-22T22:24:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_pmjZ",
          "commit": {
            "abbreviatedOid": "2735dea"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-26T12:14:39Z",
          "updatedAt": "2024-06-26T12:14:39Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "done",
              "createdAt": "2024-06-26T12:14:39Z",
              "updatedAt": "2024-06-26T12:14:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_rA4q",
          "commit": {
            "abbreviatedOid": "be0ab47"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-26T14:04:20Z",
          "updatedAt": "2024-06-26T14:04:20Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Ah no my suggestion doesn't work because we don't allow category extensions",
              "createdAt": "2024-06-26T14:04:20Z",
              "updatedAt": "2024-06-26T14:04:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_rGT-",
          "commit": {
            "abbreviatedOid": "be0ab47"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-26T14:09:44Z",
          "updatedAt": "2024-06-26T14:09:44Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Actually that's different. So its an open question, should we allow new categories to be added to a schema? \r\n\r\nIn other words if the h3 spec registered `urn:ietf:params:qlog:http` and category `h3`, should we let other documents add categories such as `urn:ietf:params:qlog:http#h2`? I think it is a reasonable thing to do but if so we would need to tweak the registration guidance.",
              "createdAt": "2024-06-26T14:09:44Z",
              "updatedAt": "2024-06-26T14:10:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_rL1N",
          "commit": {
            "abbreviatedOid": "889d6d4"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-26T14:16:10Z",
          "updatedAt": "2024-06-26T14:16:10Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "See new text",
              "createdAt": "2024-06-26T14:16:10Z",
              "updatedAt": "2024-06-26T14:16:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_rL9Y",
          "commit": {
            "abbreviatedOid": "889d6d4"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-26T14:16:21Z",
          "updatedAt": "2024-06-26T14:16:21Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "See new text",
              "createdAt": "2024-06-26T14:16:21Z",
              "updatedAt": "2024-06-26T14:16:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_rUGr",
          "commit": {
            "abbreviatedOid": "be0ab47"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "In general, the direction remains ok, but I think this could do with (a lot) more consistency and clarification... \r\n\r\nI think having a concrete example at the start of the section that can be referred back to by later paragraphs would be a big help (even though that's not super-common in IETF docs, I know). Even if you don't want to move the current example up ,we need an example that clearly indicates what's a schema, a category, an event type (and possibly what's an event identifier, and an \"event\", if you want to keep using those terms). \r\n \r\nI also still have some reservations on (dis)allowing extension of existing categories and schema's, but will post this in a separate comment below. ",
          "createdAt": "2024-06-26T14:28:30Z",
          "updatedAt": "2024-06-26T14:50:54Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nthat have related events. A minimal set of common events is presented in\r\n```",
              "createdAt": "2024-06-26T14:28:30Z",
              "updatedAt": "2024-06-26T14:50:54Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nconsistency measures that make it easier for qlog implementers to support a wide variety\r\n```",
              "createdAt": "2024-06-26T14:31:09Z",
              "updatedAt": "2024-06-26T14:50:54Z"
            },
            {
              "originalPosition": 58,
              "body": "we are being ambiguous as to what exactly an \"event definition\" is.\r\n\r\nAbove, you define it as `per-protocol\r\nevent definitions that specify the name (category + type) and data` while here, it's more correct to say each category contains multiple event types... in the next sentence then, you switch to just the word \"event\".\r\n\r\nIt's not a major issue, but I feel we need consistent naming for these things...\r\n\r\nFor that, I would say `event type` here instead of `event definition` and in the next sentence `Each event type MUST only belong` instead of `Each event MUST`\r\n\r\n\r\nRelated: I think it would really help to have an illustrative example of this at the start of this part",
              "createdAt": "2024-06-26T14:34:26Z",
              "updatedAt": "2024-06-26T14:50:54Z"
            },
            {
              "originalPosition": 62,
              "body": "I understand what you're saying because I have context, and it's an important thing to highlight, BUT it's at the wrong place in the text... new readers don't know why this is important because you haven't talked about the URIs yet (and how event names tie into those).",
              "createdAt": "2024-06-26T14:35:51Z",
              "updatedAt": "2024-06-26T14:50:54Z"
            },
            {
              "originalPosition": 68,
              "body": "```suggestion\r\nhint to tools about the possible event categories (and event types contained therein) that a qlog file might contain. The file\r\n```",
              "createdAt": "2024-06-26T14:36:36Z",
              "updatedAt": "2024-06-26T14:50:54Z"
            },
            {
              "originalPosition": 69,
              "body": "```suggestion\r\nmay contain event types that do not belong to a listed category identifier. Tools\r\n```",
              "createdAt": "2024-06-26T14:36:46Z",
              "updatedAt": "2024-06-26T14:50:54Z"
            },
            {
              "originalPosition": 73,
              "body": "This is inconsistent with how you defined a \"schema\" at the start. There you say:\r\n\r\n> An extension schema defines one or more qlog event categories\r\n\r\nand here 1 schema is named by 1 URI, but that URI then somehow contains a category identifier? So the URI doesn't identify the schema, it instead identifies a single category WITHIN an extension schema. ",
              "createdAt": "2024-06-26T14:38:11Z",
              "updatedAt": "2024-06-26T14:50:54Z"
            },
            {
              "originalPosition": 79,
              "body": "```suggestion\r\nPrivate or non-standard extension schema can use other URI formats. URIs that\r\n```",
              "createdAt": "2024-06-26T14:39:42Z",
              "updatedAt": "2024-06-26T14:50:54Z"
            },
            {
              "originalPosition": 90,
              "body": "As I said above, I think it would REALLY help to have this example (or part of it) at the start of this section, as it makes it much clearer what you mean by schema and category",
              "createdAt": "2024-06-26T14:43:24Z",
              "updatedAt": "2024-06-26T14:50:54Z"
            },
            {
              "originalPosition": 86,
              "body": "it's a bit confusing that here we have 3 schema in a single file... while not impossible, most files will have a single schema (i.e., quic and h3).\r\n\r\nI would rework this to saying that we have a single file with 2 schema (rick and john) and another file with a private extension schema (pickle).",
              "createdAt": "2024-06-26T14:47:48Z",
              "updatedAt": "2024-06-26T14:50:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_rviG",
          "commit": {
            "abbreviatedOid": "be0ab47"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-26T15:05:16Z",
          "updatedAt": "2024-06-26T15:05:16Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "That's specification via example, which is bad. The language needs to be clear enough on its own other wise people only code to the example.",
              "createdAt": "2024-06-26T15:05:16Z",
              "updatedAt": "2024-06-26T15:05:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_rzPY",
          "commit": {
            "abbreviatedOid": "889d6d4"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-26T15:10:32Z",
          "updatedAt": "2024-06-26T15:10:32Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "I think the new text sufficiently covers this indeed. ",
              "createdAt": "2024-06-26T15:10:32Z",
              "updatedAt": "2024-06-26T15:10:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_rzwr",
          "commit": {
            "abbreviatedOid": "889d6d4"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-26T15:11:25Z",
          "updatedAt": "2024-06-26T15:11:25Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I gave my perspective on this in a separate comment below https://github.com/quicwg/qlog/pull/415#issuecomment-2191940230",
              "createdAt": "2024-06-26T15:11:25Z",
              "updatedAt": "2024-06-26T15:11:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_r07I",
          "commit": {
            "abbreviatedOid": "42d9348"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-26T15:13:20Z",
          "updatedAt": "2024-06-26T15:13:20Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "See new comment on this below :) you changed this to \"event definitions\" which is better, but still a bit vague.\r\n\r\nAt least the example currently makes clear that a single document can contain multiple schema, and that event types should belong to categories, which in turn should belong to a schema. \r\n\r\nIn short: I still think this need clarification. ",
              "createdAt": "2024-06-26T15:13:20Z",
              "updatedAt": "2024-06-26T15:13:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_r-k0",
          "commit": {
            "abbreviatedOid": "788f0c9"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-26T15:29:37Z",
          "updatedAt": "2024-06-26T15:29:37Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "This section is all about how to extend qlog with more concrete event types. The URI stuff is ancilliary to that.\r\n\r\nWe need to start with clear requirements on what extensions can and can't do. \r\n\r\nEvents have a name that conveys the category and type. When event names are not unique, ambiguitiy can cause tooling to fail. The language here is normative to avoid that class of problem. This problem exists even if we weren't trying to invent a way to indicate what an endpoint was generating e.g. - if we both invent a foobar:frame_sent event type with wildly different data formats.",
              "createdAt": "2024-06-26T15:29:37Z",
              "updatedAt": "2024-06-26T15:29:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_sAft",
          "commit": {
            "abbreviatedOid": "788f0c9"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-26T15:32:53Z",
          "updatedAt": "2024-06-26T15:32:54Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "agree, are you happier with something like \r\n\r\n```suggestion\r\nEach category identifier in a schema is named by a URI. That URI MUST be absolute and MUST contain a fragment identifier (characters after a \"#\" in the URI) that indicates the category identifier. \r\n```",
              "createdAt": "2024-06-26T15:32:54Z",
              "updatedAt": "2024-06-26T15:32:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_sDt2",
          "commit": {
            "abbreviatedOid": "788f0c9"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-26T15:37:52Z",
          "updatedAt": "2024-06-26T15:37:52Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "I don't think its confusing. For the HTTP/3 qlog I'd generate for quiche, I'm already expecting to do the following based on identifiers in the QUIC and H3 extension schema\r\n\r\n```\r\n~~~\r\n\"additional_event_schemas\": [\r\n                            \"urn:ietf:params:qlog:quic#quic\",\r\n                            \"urn:ietf:params:qlog:quic#security\",\r\n                            \"urn:ietf:params:qlog:quic#recovery\",\r\n                            \"urn:ietf:params:qlog:h3#h3\"\r\n                          ]\r\n~~~\r\n",
              "createdAt": "2024-06-26T15:37:52Z",
              "updatedAt": "2024-06-26T15:37:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_1mJY",
          "commit": {
            "abbreviatedOid": "be0ab47"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-27T09:14:44Z",
          "updatedAt": "2024-06-27T09:14:44Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I agree that we have to have clear requirements. I'm mainly saying that this specific text either needs to move (original suggestion) or needs to be explained better in-place (which seems your suggestion) to really make sense for the reader.\r\n\r\nI'm guessing this will be easily solved if we clearly explain this up front:\r\n\r\nschema namespace > category identifier > event type \r\n\r\nand then it's easier to use that terminology to explain this restriction. ",
              "createdAt": "2024-06-27T09:14:44Z",
              "updatedAt": "2024-06-27T09:14:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_1mdQ",
          "commit": {
            "abbreviatedOid": "be0ab47"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-27T09:15:16Z",
          "updatedAt": "2024-06-27T09:15:16Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "yes, that's much more accurate :) ",
              "createdAt": "2024-06-27T09:15:16Z",
              "updatedAt": "2024-06-27T09:15:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_1orC",
          "commit": {
            "abbreviatedOid": "be0ab47"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-27T09:19:10Z",
          "updatedAt": "2024-06-27T09:19:10Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "I agree that wouldn't be ideal, but then indeed we need to have better text imo :) \r\n\r\nMaybe something more generic up top, like:\r\n\r\n``` \r\n\r\nurn:ietf:params:qlog:<SCHEMA-NAMESPACE>#<CATEGORY-IDENTIFIER> \r\n\r\n...\r\n\r\nFor example, this document defines the \"main\" schema namespace with two category identifiers: \"generic\" and \"simulation\".\r\n\r\n``` \r\n\r\nto help explain how the concepts map to the URIs.\r\n",
              "createdAt": "2024-06-27T09:19:10Z",
              "updatedAt": "2024-06-27T09:19:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_1pd2",
          "commit": {
            "abbreviatedOid": "be0ab47"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-27T09:20:33Z",
          "updatedAt": "2024-06-27T09:20:33Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "No, I mean having 3 schema namespaces defined in a single IETF draft for example, not having many entries in the `additional_event_schemas` (that's obviously fine). ",
              "createdAt": "2024-06-27T09:20:33Z",
              "updatedAt": "2024-06-27T09:20:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 417,
      "id": "PR_kwDOCrLn6M5p9y4P",
      "title": "Add extensibility for all events and official extension points",
      "url": "https://github.com/quicwg/qlog/pull/417",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #379.\r\nAlso closes https://github.com/quicwg/qlog/issues/261, https://github.com/quicwg/qlog/issues/176, https://github.com/quicwg/qlog/issues/170, https://github.com/quicwg/qlog/issues/124, https://github.com/quicwg/qlog/issues/192, https://github.com/quicwg/qlog/issues/297.\r\n\r\nAdds extensibility for all events through the `* $$category-name-ext` pattern first used in #400, now extended to ALL events as discussed in #379.\r\n\r\nMakes all official protocol extension points also extensible in qlog. This was mostly already the case except for a few holdouts ($H3StreamType, $ProtocolType, $TransportError). The full list currently is:\r\n- frames: $QuicFrame and $H3Frame and $H3Datagram\r\n- TPs: $$quic-parametersset-extension and $$quic-parametersrestored-extension \r\n- settings: $$h3-parameters-extension (and inherently H3Setting by the way it's defined)\r\n- H3 stream types: $H3StreamType\r\n- error codes: $ApplicationError, $TransportError\r\n- ALPN (at least qlog-level APLN; the other one is inherent in ALPNInformation): $ProtocolType\r\n\r\nI don't think we need to make QUIC's StreamType extensible (since that's also in the RFC as always just uni- or bidirectional, with no way to change that through IANA (or even wire image, due to looking at the 2 LSBs)). Thoughts on this @LPardue ?\r\n\r\n\r\n",
      "createdAt": "2024-03-18T16:15:56Z",
      "updatedAt": "2024-06-24T13:22:35Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "f0897c957124eede9dee76ab798b1bba99d53558",
      "headRepository": "quicwg/qlog",
      "headRefName": "extend-all-the-things",
      "headRefOid": "191be52b3ea42a30e69f0645284d91952e91de56",
      "closedAt": "2024-06-24T13:22:35Z",
      "mergedAt": "2024-06-24T13:22:35Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "41fec12b56593efaedc1e4eb5d5574bfcef7f612"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "TODO for myself: we also need to make PacketHeader extensible (e.g., to be able to add lossbits, new fields for QUIC v3 etc.). Same for PacketType and PacketNumberSpace (TODO: also double-check others)",
          "createdAt": "2024-03-18T20:42:58Z",
          "updatedAt": "2024-03-18T20:55:55Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Did some final work on this today. Should be ready for final review + merge @LPardue @marten-seemann \r\n\r\nA note: as mentioned in the original PR message, this intentionally does NOT make QUIC Stream Type (uni vs bidi) extensible, since that's not supported by v1 and would require quite a different approach (though not really wire image changes I guess?). So still not sure if we should include this or not... would welcome some thoughts ;) ",
          "createdAt": "2024-06-20T14:35:42Z",
          "updatedAt": "2024-06-20T14:39:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5z8PKK",
          "commit": {
            "abbreviatedOid": "96c78b8"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T04:47:57Z",
          "updatedAt": "2024-03-19T04:47:58Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "can we remove the `text => uint` now that we have $$h3-parameters-extension?",
              "createdAt": "2024-03-19T04:47:57Z",
              "updatedAt": "2024-03-19T04:47:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5z8PkL",
          "commit": {
            "abbreviatedOid": "96c78b8"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T04:49:46Z",
          "updatedAt": "2024-03-19T04:49:46Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Is there any danger that mentioning JSON object here could confusing people about what serialization formats are allowed?",
              "createdAt": "2024-03-19T04:49:46Z",
              "updatedAt": "2024-03-19T04:49:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5z8QIM",
          "commit": {
            "abbreviatedOid": "96c78b8"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T04:52:44Z",
          "updatedAt": "2024-03-19T04:52:44Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "This example makes me realize that qlog event data field order cannot be significant. I don't think we state that anywhere already?",
              "createdAt": "2024-03-19T04:52:44Z",
              "updatedAt": "2024-03-19T04:52:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5z9u14",
          "commit": {
            "abbreviatedOid": "96c78b8"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T08:57:47Z",
          "updatedAt": "2024-03-19T08:57:47Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I thought about it, but I dont' think so... we discuss this in detail in the serialization section and JSON is the main provided option there, so I think it's fine to have it as an example here.",
              "createdAt": "2024-03-19T08:57:47Z",
              "updatedAt": "2024-03-19T08:57:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5z-Gjj",
          "commit": {
            "abbreviatedOid": "96c78b8"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T09:40:01Z",
          "updatedAt": "2024-03-19T09:40:01Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Good point. Tracking that here now: https://github.com/quicwg/qlog/pull/418",
              "createdAt": "2024-03-19T09:40:01Z",
              "updatedAt": "2024-03-19T09:40:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M51m2Ph",
          "commit": {
            "abbreviatedOid": "96c78b8"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T09:08:09Z",
          "updatedAt": "2024-04-02T09:08:09Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "agree",
              "createdAt": "2024-04-02T09:08:09Z",
              "updatedAt": "2024-04-02T09:08:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M5_Bo-N",
          "commit": {
            "abbreviatedOid": "8bf7113"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-20T18:48:56Z",
          "updatedAt": "2024-06-20T18:48:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 418,
      "id": "PR_kwDOCrLn6M5qD-aF",
      "title": "Clarify no-ordering expectation for qlog fields",
      "url": "https://github.com/quicwg/qlog/pull/418",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As noticed by @LPardue [here](https://github.com/quicwg/qlog/pull/417#discussion_r1529706045), we don't actually say anywhere that CDDL field ordering does not matter (it's implied by CDDL and JSON themselves, but probably good to reinforce explicitly).\r\n\r\n Not the biggest fan of current prose... tried to find examples in other RFCs but they're all over the place :) So let me know if you'd like to see it worded differently. \r\n\r\n",
      "createdAt": "2024-03-19T09:32:55Z",
      "updatedAt": "2024-06-10T09:09:31Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "f0897c957124eede9dee76ab798b1bba99d53558",
      "headRepository": "quicwg/qlog",
      "headRefName": "no-order",
      "headRefOid": "b2b962ed32c1600f1eb3b6c3c7b3e6b8ce457f81",
      "closedAt": "2024-06-10T09:09:23Z",
      "mergedAt": "2024-06-10T09:09:23Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "e7e21b4cb00078370aed470df974ebde4d96a2f8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M51mcC6",
          "commit": {
            "abbreviatedOid": "f930191"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T08:25:28Z",
          "updatedAt": "2024-04-02T08:25:28Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I'm not sure this hits the right notes for me. An alternative suggestion is something like \r\n\r\n```suggestion\r\nThe ordering of member fields in qlog CDDL type definitions is not significant.\r\nThe ordering of member field in the serialization formats defined in this\r\ndocument, JSON ({{format-json}}) and JSON Text Sequences ({{format-json-seq}}),\r\nis not significant and qlog tools MUST NOT assume so. Other qlog serialization\r\nformats MAY define field order significance, if they do they MUST define\r\nrequirements for qlog tools supporting those formats.\r\n```",
              "createdAt": "2024-04-02T08:25:28Z",
              "updatedAt": "2024-04-02T08:25:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M51mm9y",
          "commit": {
            "abbreviatedOid": "5811dbd"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T08:43:41Z",
          "updatedAt": "2024-04-02T08:43:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThe ordering of member fields in the serialization formats defined in this\r\n```",
              "createdAt": "2024-04-02T08:43:41Z",
              "updatedAt": "2024-04-02T08:43:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M51mnTu",
          "commit": {
            "abbreviatedOid": "f930191"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T08:44:22Z",
          "updatedAt": "2024-04-02T08:44:22Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Agree that's a much better version :) accepted",
              "createdAt": "2024-04-02T08:44:22Z",
              "updatedAt": "2024-04-02T08:44:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M51mprW",
          "commit": {
            "abbreviatedOid": "b2b962e"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Lgtm :-)",
          "createdAt": "2024-04-02T08:48:51Z",
          "updatedAt": "2024-04-02T08:48:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 419,
      "id": "PR_kwDOCrLn6M5zX1Tr",
      "title": "Make intent of triggers for connection_closed clearer",
      "url": "https://github.com/quicwg/qlog/pull/419",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #410 \r\n\r\n@LPardue PTAL. I still think having an `application` value here is useful (e.g., user force-closed the connection somehow, or application decided to abandon it without waiting for clean shutoff without additional info). But as discussed on #410 the GOAWAY example was probably incorrect. ",
      "createdAt": "2024-06-24T13:59:42Z",
      "updatedAt": "2024-07-08T19:07:30Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "41fec12b56593efaedc1e4eb5d5574bfcef7f612",
      "headRepository": "quicwg/qlog",
      "headRefName": "clarify-close-trigger",
      "headRefOid": "1c8f4507236470506348bfb2eea13a60f03e5d9b",
      "closedAt": "2024-07-08T19:07:30Z",
      "mergedAt": "2024-07-08T19:07:30Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "cfdfb5734f3f089ebee580a8a14af834c5fd7a5c"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed during editors' meeting. Discussion on how useful `clean` is. Discussion on when connection_close should be emitted (before draining or after draining, if there's a draining involved). Marten feels it should be when draining starts, Lucas has no opinion.\r\n\r\nRobin will go back and see what would be most useful and what makes sense with errors logging etc. (i.e., should be emit ConnectionClosed twice or use ConnectionStateUpdated for some things).\r\n\r\nAlso enforce here that triggers are suggestions, and that other triggers are possible based on application. \r\n\r\nRelated to #239 ",
          "createdAt": "2024-06-25T09:38:15Z",
          "updatedAt": "2024-06-25T09:39:54Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, after spending WAY too much time re-reading the connection close stuff in RFC9000 and 9114, I think I now have something that's still a bit vague, but at least correct :)\r\n\r\nThe main problem apparently (and why \"clean\" was needed), is because you have situations where you as a peer receive a CONNECTION_CLOSE where you're not 100% sure what triggered it... (e.g., a transport CONNECTION_CLOSE (0x1c) with transport error code NO_ERROR) is probably clean, but you're not quite sure (could be it was an application-level error on the other end that they simply didn't pipe through correctly).  \r\n\r\nSo I've now renamed that to \"unspecified\" and added text to say you should try to be as specific as possible... hope that is enough :) \r\n\r\nPTAL @LPardue \r\n\r\n\r\n",
          "createdAt": "2024-06-27T14:26:26Z",
          "updatedAt": "2024-06-27T14:26:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5_b_aI",
          "commit": {
            "abbreviatedOid": "858e477"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-25T09:38:24Z",
          "updatedAt": "2024-06-25T09:38:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M5_8CMH",
          "commit": {
            "abbreviatedOid": "471f42b"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-27T20:19:09Z",
          "updatedAt": "2024-06-27T20:19:13Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Should or SHOULD",
              "createdAt": "2024-06-27T20:19:09Z",
              "updatedAt": "2024-06-27T20:19:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6A529q",
          "commit": {
            "abbreviatedOid": "471f42b"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-08T08:39:26Z",
          "updatedAt": "2024-07-08T08:39:26Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Discussed in editors' meeting. Change to `SHOULD`",
              "createdAt": "2024-07-08T08:39:26Z",
              "updatedAt": "2024-07-08T08:39:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6A54T9",
          "commit": {
            "abbreviatedOid": "471f42b"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-08T08:41:15Z",
          "updatedAt": "2024-07-08T08:41:16Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nLoggers SHOULD use the most descriptive trigger for a `connection_closed` event\r\n```",
              "createdAt": "2024-07-08T08:41:15Z",
              "updatedAt": "2024-07-08T08:41:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 420,
      "id": "PR_kwDOCrLn6M5zyZPG",
      "title": "Simplify and clarify connection_state_updated",
      "url": "https://github.com/quicwg/qlog/pull/420",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #239 \r\n\r\nIt's mostly the same as before, but cleaned up / shortened with some better prose surrounding (also more consistent with connection_closed and connection_started now).",
      "createdAt": "2024-06-27T15:08:48Z",
      "updatedAt": "2024-06-28T15:08:46Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "bac3d8e4527e415d955bc9fdd918b0aafef029a4",
      "headRepository": "quicwg/qlog",
      "headRefName": "clarify-connection-states",
      "headRefOid": "5ef6f7743706cac44dbfc44ad7a7cdb4348e204a",
      "closedAt": "2024-06-28T15:08:46Z",
      "mergedAt": "2024-06-28T15:08:46Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "3a92cd452a1fdd4dfe5ed3746726b24a303a94f1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M5_8e_s",
          "commit": {
            "abbreviatedOid": "5ef6f77"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-27T21:41:21Z",
          "updatedAt": "2024-06-27T21:41:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 422,
      "id": "PR_kwDOCrLn6M5z1FEA",
      "title": "Stab at the use cases",
      "url": "https://github.com/quicwg/qlog/pull/422",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-27T23:00:08Z",
      "updatedAt": "2024-07-08T19:24:16Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "b734d43439a29e7ae42702bb715c5391895828f5",
      "headRepository": "quicwg/qlog",
      "headRefName": "security-stuff",
      "headRefOid": "328f7d61d0edfff473eaab585be574f53cd3957f",
      "closedAt": "2024-07-08T19:23:56Z",
      "mergedAt": "2024-07-08T19:23:56Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "41e8667cc01cfc0cec37ab650a1493dfda3d80c8"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not super-happy with the prose, but close enough to merge and see if we get comments on it.",
          "createdAt": "2024-07-08T19:24:15Z",
          "updatedAt": "2024-07-08T19:24:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6AC5ua",
          "commit": {
            "abbreviatedOid": "d724107"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I like the general direction here :) Only that sentence with the \"data requirements\" is a bit vague, but the rest looks good imo!",
          "createdAt": "2024-06-28T14:52:55Z",
          "updatedAt": "2024-06-28T14:57:40Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nqlog permits logging of a broad and detailed range of data. Operators and\r\n```",
              "createdAt": "2024-06-28T14:52:55Z",
              "updatedAt": "2024-06-28T14:57:40Z"
            },
            {
              "originalPosition": 27,
              "body": "\"data requirements\" is a bit vague... which requirements specifically does this refer to? ",
              "createdAt": "2024-06-28T14:55:31Z",
              "updatedAt": "2024-06-28T14:57:40Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\ncollected with the intention for this to be shared in a publication. Conversely, a\r\n```",
              "createdAt": "2024-06-28T14:56:26Z",
              "updatedAt": "2024-06-28T14:57:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6Ah6kb",
          "commit": {
            "abbreviatedOid": "e34779a"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T12:55:21Z",
          "updatedAt": "2024-07-03T12:55:21Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Discussed in editors' meeting.\r\n\r\nGoal is to talk about data requirements of the loggers (so operators and implementers), NOT data requirements of the entities it might be disclosed. \r\n\r\nRobin: split up two concepts (operators+impl plus entities) somehow maybe? or at least make clearer.\r\n\r\nDry solution: \"The data requirements of the operators/implementers, and definition of entities...\"",
              "createdAt": "2024-07-03T12:55:21Z",
              "updatedAt": "2024-07-03T12:55:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6A5t3S",
          "commit": {
            "abbreviatedOid": "d724107"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-08T08:24:00Z",
          "updatedAt": "2024-07-08T08:24:00Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "This is the best I've gotten in 30 minutes... :) \r\n\r\n> Operators and implementers should balance the value of logged data with the\r\npotential risks of voluntary or involuntary disclosure to trusted or untrusted\r\nentities. Importantly, both the comprehensiveness required to make the data useful and the definition of entities depend greatly on the intended use cases. ",
              "createdAt": "2024-07-08T08:24:00Z",
              "updatedAt": "2024-07-08T08:24:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6A6Xpk",
          "commit": {
            "abbreviatedOid": "d724107"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-08T09:31:54Z",
          "updatedAt": "2024-07-08T09:31:54Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Editors' meeting: Lucas doesn't like \"comprehensiveness\": replace with some synonyms :) ",
              "createdAt": "2024-07-08T09:31:54Z",
              "updatedAt": "2024-07-08T09:31:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6A_sXu",
          "commit": {
            "abbreviatedOid": "328f7d6"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-08T19:13:57Z",
          "updatedAt": "2024-07-08T19:13:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 424,
      "id": "PR_kwDOCrLn6M5z8tPD",
      "title": "Behold - schema",
      "url": "https://github.com/quicwg/qlog/pull/424",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This looks like hell to review but a lot of it is moving text around, so a visual diff is probably the most straightforward.\r\n\r\nThe high-level (pun-intended) goal of this PR is to realize the `main-schema` document is not merely a schema. Its the document that defines the core concepts behind its structured logging, methodology, requirements for loggers and tools, AND a few schema. \r\nMoving the document away from referring to its entire self as a schema, makes it easier to isolate the parts we mostly expect people to extend - the event definitions.\r\n\r\nI found it incredibly hard to talk about this with the old terminology of generic event class and specific data. Especially when combined with the concept of \"event definition documents\". That's been reflected into prior attempts at wrangling the extensibility of events. So I've changed that to abstract Event class and concrete event types. I suspect those won't be that popular either but they work for this old OOP survivor. \r\n\r\nThe PR isn't 100% complete but it does implement the schema > category > event structure that we seemed to align on, and ports over a lot more from https://github.com/quicwg/qlog/pull/415. If we think this is a suitable direction, putting the finishing touches like IANA policy and updating QUIC/H3 docs isn't that much more work.",
      "createdAt": "2024-06-29T05:06:18Z",
      "updatedAt": "2024-07-08T20:22:16Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "3a92cd452a1fdd4dfe5ed3746726b24a303a94f1",
      "headRepository": "quicwg/qlog",
      "headRefName": "behold-schema",
      "headRefOid": "f8a71e7524da493b6be2b6cc053d5668ae982355",
      "closedAt": "2024-07-08T20:22:16Z",
      "mergedAt": "2024-07-08T20:22:16Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "4eefbcf7ff239d297c24141caa031cd4667ed1bb"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Final actions to complete (from the editors call)\r\n\r\n- [x] - fix group socket CDDL weirdness\r\n- [x] - change `generic` to `loglevel`, change `std` to `generic`\r\n- [x]  - add \"MAY register a URI in the \"qlog eventschema\" registry but MUST NOT use a URN of the form\" reviewer guidance\r\n- [x] - restore inadvertently deleted H3 text into intro section\r\n~~- [ ] - Open an issue for URI safe schema and category names etc.~~\r\n\r\n- [x]  - state clearly what characters are allowed in identifiers that will go into URIs. ",
          "createdAt": "2024-07-08T09:40:48Z",
          "updatedAt": "2024-07-08T14:52:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6AXydy",
          "commit": {
            "abbreviatedOid": "88763cf"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks @LPardue for this effort :) \r\n\r\nI've tried to stick mostly to the main points for my first pass. In general, I like the new approach, and you've bypassed a lot of the minor issues from the previous version in #415. \r\n\r\nIn general, I think my comments here are not blockers or major issues, just things that could do with further refinement / clarification. Let's discuss these tomorrow in the editors' meeting and then I can do a final \"editorial\" pass to fix some consistency/spelling issues later :) ",
          "createdAt": "2024-07-02T12:54:02Z",
          "updatedAt": "2024-07-02T14:39:33Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nschemas, and two common event schemas. Requirements and guidelines for creating\r\n```\r\nBIKESHED:\r\n\r\n\"main schema\" is a bit weird here in the new setup imo. Better to be a bit more explicit that these are not the \"main\" but rather \"common\" schema, reusable by others (generic and simulation)",
              "createdAt": "2024-07-02T12:54:03Z",
              "updatedAt": "2024-07-02T14:39:33Z"
            },
            {
              "originalPosition": 43,
              "body": "At this point it's very clear that we need to be consistent in how we use `schema` / `schemas`... sometimes it's singular, sometimes it's plural here. Sometimes `schemas` is used explicitly, but often not...\r\n\r\nI'd prefer to consistently use schema = singular, schemas = plural",
              "createdAt": "2024-07-02T12:59:46Z",
              "updatedAt": "2024-07-02T14:39:33Z"
            },
            {
              "originalPosition": 452,
              "body": "This is not entirely how I understood things... categories do not have to be GLOBALLY unique, just within their specific namespace (e.g., you could have  namespaceX:categoryA and also namespaceY:categoryA). As such, the COMBINATION of namespace + category identifier should be globally unique. \r\n\r\nAdditionally: I think it's better to say `Event categories MUST belong to a single event namespace` instead of to a single event `schema`... helps to reinforce the URI structure later. ",
              "createdAt": "2024-07-02T14:23:20Z",
              "updatedAt": "2024-07-02T14:39:33Z"
            },
            {
              "originalPosition": 456,
              "body": "```suggestion\r\nthe form `urn:ietf:params:qlog:<namespace identifier>#<category identifier>`.\r\n```",
              "createdAt": "2024-07-02T14:24:35Z",
              "updatedAt": "2024-07-02T14:39:33Z"
            },
            {
              "originalPosition": 444,
              "body": "```suggestion\r\nEvent schema MUST define a registered non-empty namespace identifier of type `text`.\r\n```",
              "createdAt": "2024-07-02T14:25:50Z",
              "updatedAt": "2024-07-02T14:39:33Z"
            },
            {
              "originalPosition": 470,
              "body": "```suggestion\r\nnon-empty name of type `text`.\r\n```\r\n\r\nsince you later use \"event type identifier\" to indicate just the \"type name\" (second part of the `name`).",
              "createdAt": "2024-07-02T14:27:28Z",
              "updatedAt": "2024-07-02T14:39:33Z"
            },
            {
              "originalPosition": 507,
              "body": "At no point has it been made clear yet how loggers MUST/SHOULD fill the `event_categories` field, nor how tools should handle \"missing\" URIs (i.e., unknown event types). I think this should be explicitly called out. ",
              "createdAt": "2024-07-02T14:35:06Z",
              "updatedAt": "2024-07-02T14:39:33Z"
            },
            {
              "originalPosition": 105,
              "body": "I don't particularly like the \"file schema\" vs \"event schema\" as we currently have it... I understand WHY you're doing it that way, but it seems a bit incongruous/inconsistent (e.g., we don't explain how/why to define new FILE schema, nor have we ways to extend existing FILE schema, in contrast to EVENT schema). \r\n\r\nmaybe this is just me coming from the \"old\" way of using \"schema\", but it doesn't feel completely right semantically to me atm. ",
              "createdAt": "2024-07-02T14:37:52Z",
              "updatedAt": "2024-07-02T14:39:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6Aas8b",
          "commit": {
            "abbreviatedOid": "88763cf"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-02T17:40:32Z",
          "updatedAt": "2024-07-02T17:40:32Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Yeah it felt to me more lime this is stdlib than `main` but I refrained from changing it since the pr was some huge anyway. I'm open to a different value ",
              "createdAt": "2024-07-02T17:40:32Z",
              "updatedAt": "2024-07-02T17:40:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6AatLz",
          "commit": {
            "abbreviatedOid": "88763cf"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-02T17:41:08Z",
          "updatedAt": "2024-07-02T17:41:08Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "This is mostly me having a blind spot for using the correct term no matter how hard I try :D",
              "createdAt": "2024-07-02T17:41:08Z",
              "updatedAt": "2024-07-02T17:41:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6Aazsa",
          "commit": {
            "abbreviatedOid": "88763cf"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-02T17:52:23Z",
          "updatedAt": "2024-07-02T17:52:23Z",
          "comments": [
            {
              "originalPosition": 452,
              "body": "That creates a whole class of problem of ambiguity I'd like to avoid. If events dont self identify the namespace, and we dont make declaration of all schema a MUST, its a recipe for clashes where people add a super generic category like `util` and have an event name like `util:do_common_thing`. \r\n\r\nInstead if we operate the old school C methodology of embedding the unique token in the signature, we don't need to rely on namespace mangling. \r\n\r\nIf we don't want to go this way, that's OK but we need a way to avoid name collisions when the event names could clash",
              "createdAt": "2024-07-02T17:52:23Z",
              "updatedAt": "2024-07-02T17:52:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6AbcUF",
          "commit": {
            "abbreviatedOid": "88763cf"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-02T19:24:11Z",
          "updatedAt": "2024-07-02T19:24:12Z",
          "comments": [
            {
              "originalPosition": 507,
              "body": "Very good poont",
              "createdAt": "2024-07-02T19:24:12Z",
              "updatedAt": "2024-07-02T19:24:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6AhxWT",
          "commit": {
            "abbreviatedOid": "88763cf"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T12:39:23Z",
          "updatedAt": "2024-07-03T12:39:23Z",
          "comments": [
            {
              "originalPosition": 452,
              "body": "Discussed during editors' meeting.\r\n\r\nLucas is in the right here, should be ok as the current text states. Robin was conflating with something else.\r\n\r\nRobin would like us to explicitly call out how things can be extended though:\r\n- CANNOT add new events to existing categories in other documents\r\n- CANNOT create new categories that have the same name as existing categories in other documents (this is basically what the current text above says)\r\n- CAN create new categories in existing NAMESPACES as long as the category names are globally unique\r\n\r\nAnd these should also be supported by a concrete example. \r\n",
              "createdAt": "2024-07-03T12:39:23Z",
              "updatedAt": "2024-07-03T12:39:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6AhzmS",
          "commit": {
            "abbreviatedOid": "88763cf"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T12:43:13Z",
          "updatedAt": "2024-07-03T12:43:13Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "Discussed in editors' meeting. \r\n\r\nMake explicit in new `file_schema` field with its own URI namespace and IANA registration. Allows us to also get rid of `qlog_version` (implicit in file_schema now)\r\n\r\nRename `event_categories` to `event_schemas` maybe for consistency with `file_shema`\r\n\r\n```\r\nurn:ietf:params:qlog:file:\r\nurn:ietf:params:qlog:events:\r\n\r\nfile_schema: \"urn:ietf:params:qlog:file:sequential\",\r\nevent_schemas: [\r\n    \"urn:ietf:params:qlog:events:rick#roll\",\r\n    \"urn:ietf:params:qlog:events:rick#astley\",\r\n    \"urn:ietf:params:qlog:events:rick#moranis\",\r\n    \"urn:ietf:params:qlog:events:john#doe\",\r\n    \"urn:ietf:params:qlog:events:john#candy\",\r\n    \"urn:ietf:params:qlog:events:john#goodman\",\r\n    \"https://example.com/032024/pickle.html#pepper\",\r\n    \"https://example.com/032024/pickle.html#lilly\",\r\n    \"https://example.com/032024/pickle.html#rick\",\r\n]\r\n```\r\n",
              "createdAt": "2024-07-03T12:43:13Z",
              "updatedAt": "2024-07-03T12:43:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6Ah0ow",
          "commit": {
            "abbreviatedOid": "88763cf"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T12:45:09Z",
          "updatedAt": "2024-07-03T12:45:09Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Discussed during editors' meeting. Should be `std` as namespace identifier. ",
              "createdAt": "2024-07-03T12:45:09Z",
              "updatedAt": "2024-07-03T12:45:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6AzxVv",
          "commit": {
            "abbreviatedOid": "1178bdc"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I like the general direction of re-using media types here; feels clean.\r\n\r\nThe rest is also as discussed, minus a few nits which I've listed here, so let's continue in this direction :) ",
          "createdAt": "2024-07-05T17:19:32Z",
          "updatedAt": "2024-07-05T17:31:24Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "should this be `event_schemas` instead (making it implicitly clear there is 1 `file_schema` but multiple `event_schemaS`?",
              "createdAt": "2024-07-05T17:19:32Z",
              "updatedAt": "2024-07-05T17:31:24Z"
            },
            {
              "originalPosition": 45,
              "body": "You probably know this, but this should be something like `$$logfile-extensions` with CDDL",
              "createdAt": "2024-07-05T17:20:38Z",
              "updatedAt": "2024-07-05T17:31:24Z"
            },
            {
              "originalPosition": 39,
              "body": "I think we can probably just leave this as `serialization_format`, since we don't have the `qlog_` prefix anywhere else anymore :) ",
              "createdAt": "2024-07-05T17:21:11Z",
              "updatedAt": "2024-07-05T17:31:24Z"
            },
            {
              "originalPosition": 63,
              "body": "Give a short description here as well about the goal of this field (just so readers get a high-level overview from this section)",
              "createdAt": "2024-07-05T17:23:38Z",
              "updatedAt": "2024-07-05T17:31:24Z"
            },
            {
              "originalPosition": 73,
              "body": "copy-paste whoopsie :) should be `or non-standard log file schemas`",
              "createdAt": "2024-07-05T17:24:34Z",
              "updatedAt": "2024-07-05T17:31:24Z"
            },
            {
              "originalPosition": 71,
              "body": "Should we mention here again/already that this document registers 2 log file schema URNs?",
              "createdAt": "2024-07-05T17:28:12Z",
              "updatedAt": "2024-07-05T17:31:24Z"
            },
            {
              "originalPosition": 69,
              "body": "Log file schemas",
              "createdAt": "2024-07-05T17:28:21Z",
              "updatedAt": "2024-07-05T17:31:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6A1l4U",
          "commit": {
            "abbreviatedOid": "1178bdc"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-06T13:36:30Z",
          "updatedAt": "2024-07-06T13:36:30Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "agreed, done",
              "createdAt": "2024-07-06T13:36:30Z",
              "updatedAt": "2024-07-06T13:36:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6A1l9E",
          "commit": {
            "abbreviatedOid": "1178bdc"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-06T13:39:41Z",
          "updatedAt": "2024-07-06T13:39:41Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "yep, done",
              "createdAt": "2024-07-06T13:39:41Z",
              "updatedAt": "2024-07-06T13:39:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6A1mCU",
          "commit": {
            "abbreviatedOid": "1178bdc"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-06T13:41:39Z",
          "updatedAt": "2024-07-06T13:41:39Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "fixed",
              "createdAt": "2024-07-06T13:41:39Z",
              "updatedAt": "2024-07-06T13:41:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6A1mCm",
          "commit": {
            "abbreviatedOid": "1178bdc"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-06T13:41:46Z",
          "updatedAt": "2024-07-06T13:41:46Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "fixed",
              "createdAt": "2024-07-06T13:41:46Z",
              "updatedAt": "2024-07-06T13:41:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6A1mxN",
          "commit": {
            "abbreviatedOid": "1178bdc"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-06T14:09:40Z",
          "updatedAt": "2024-07-06T14:09:41Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Makes sense but then the concrete log files need to extend that right? I gave it a go, PTAL",
              "createdAt": "2024-07-06T14:09:40Z",
              "updatedAt": "2024-07-06T14:09:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6A135s",
          "commit": {
            "abbreviatedOid": "1178bdc"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-06T20:09:38Z",
          "updatedAt": "2024-07-06T20:09:38Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "done",
              "createdAt": "2024-07-06T20:09:38Z",
              "updatedAt": "2024-07-06T20:09:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6A6M2u",
          "commit": {
            "abbreviatedOid": "88763cf"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-08T09:13:01Z",
          "updatedAt": "2024-07-08T09:13:01Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Discussed during editors' meeting.\r\n\r\nChange to `generic` namespace and make category name `loglevel` instead :) ",
              "createdAt": "2024-07-08T09:13:01Z",
              "updatedAt": "2024-07-08T09:13:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6A6lNU",
          "commit": {
            "abbreviatedOid": "1178bdc"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-08T09:57:22Z",
          "updatedAt": "2024-07-08T09:57:22Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "So turns out my suggestion of using the group socket doesn't actually work :) We need to use the CDDL \"unwrapping operator\" `~` instead. This will \"copy and paste\" all the fields from the operand struct over to this new struct. This way, we CAN define new struct names for QlogFile and QlogFileSeq :) \r\n\r\nSo the correct CDDL definitions for the 3 structs are (note: removed `$$logfile-extensions` from `LogFile`!)\r\n\r\n```\r\n~~~ cddl\r\nLogFile = {\r\n    file_schema: text\r\n    serialization_format: text\r\n    ? title: text\r\n    ? description: text\r\n    event_schemas: [+text]\r\n}\r\n~~~\r\n{: #abstract-logfile-def title=\"LogFile definition\"}\r\n```\r\n\r\n```\r\n~~~ cddl\r\nQlogFile = {\r\n    ~LogFile\r\n    ? traces: [+ Trace /\r\n                TraceError]\r\n}\r\n~~~\r\n{: #qlog-file-def title=\"QlogFile definition\"}\r\n```\r\n\r\n```\r\n~~~ cddl\r\nQlogFileSeq = {\r\n    ~LogFile\r\n    trace: TraceSeq\r\n}\r\n~~~\r\n{: #qlog-file-seq-def title=\"QlogFileSeq definition\"}\r\n```\r\n\r\n\r\nNote that we used this before in H3, but I removed those for clarity. There, I also had some clarifying text (much like we have for the sockets), like this:\r\n\r\n> As a reminder the CDDL unwrap operator (~), see {{?RFC8610}}), copies the fields\r\nfrom the referenced type (H3Parameters) into the target type directly, extending the\r\ntarget with the unwrapped fields.\r\n\r\nMaybe a good idea to add something like that in here as well, to clarify what we're doing (replacing the current text around `$$logfile-extensions`)? \r\n\r\n\r\n\r\n",
              "createdAt": "2024-07-08T09:57:22Z",
              "updatedAt": "2024-07-08T09:57:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 427,
      "id": "PR_kwDOCrLn6M502-EZ",
      "title": "s/protocol_event/protocol_events",
      "url": "https://github.com/quicwg/qlog/pull/427",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #426\r\n",
      "createdAt": "2024-07-09T16:34:11Z",
      "updatedAt": "2024-09-30T09:54:54Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "4eefbcf7ff239d297c24141caa031cd4667ed1bb",
      "headRepository": "quicwg/qlog",
      "headRefName": "protocol_types",
      "headRefOid": "e94bdc647960ff7d605033fff120fa4784c7520d",
      "closedAt": "2024-09-30T09:54:50Z",
      "mergedAt": "2024-09-30T09:54:50Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "88cc7f80e7063527e1f4df16ef5bde5ef9cfb576"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6B7AhK",
          "commit": {
            "abbreviatedOid": "e94bdc6"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-16T09:37:10Z",
          "updatedAt": "2024-07-16T09:37:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 428,
      "id": "PR_kwDOCrLn6M504uTb",
      "title": "Use the common name for HTTP/3 in protocol_type",
      "url": "https://github.com/quicwg/qlog/pull/428",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It's not clear to me why we would want to use an incommon string like \"HTTP3\" instead of \"HTTP/3\", there's no issues with slashes I can think of and saving a single character doesn't seem important",
      "createdAt": "2024-07-09T21:14:21Z",
      "updatedAt": "2024-10-18T00:09:23Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "657d754ceb75598ee5c777510ba493445dc8147d",
      "headRepository": "quicwg/qlog",
      "headRefName": "h3-with-a-slash",
      "headRefOid": "06c3dff885a068753280fa84f8b8ec3a3db021c3",
      "closedAt": "2024-10-18T00:09:20Z",
      "mergedAt": "2024-10-18T00:09:20Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "65c9758f20ef1cf485990cd2db39941820071e21"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6NlKr7",
          "commit": {
            "abbreviatedOid": "d632b91"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-17T13:56:28Z",
          "updatedAt": "2024-10-17T13:56:28Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M6NlOyv",
          "commit": {
            "abbreviatedOid": "d632b91"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-17T14:02:06Z",
          "updatedAt": "2024-10-17T14:02:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 430,
      "id": "PR_kwDOCrLn6M505H55",
      "title": "Move trigger section under concrete data field section",
      "url": "https://github.com/quicwg/qlog/pull/430",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I'm still a bit confused by triggers, hence opening https://github.com/quicwg/qlog/issues/429. \r\n\r\nHowever, all this PR does is moves text as proposed in https://github.com/quicwg/qlog/issues/423.\r\n\r\nCloses https://github.com/quicwg/qlog/issues/423",
      "createdAt": "2024-07-09T22:34:35Z",
      "updatedAt": "2024-10-18T00:03:09Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "74f4f1d1a253a01ba57408097a11403b6444bfde",
      "headRepository": "quicwg/qlog",
      "headRefName": "triggers-wtf",
      "headRefOid": "988b60b740dabddb5bda825bba848903510833ef",
      "closedAt": "2024-10-18T00:03:04Z",
      "mergedAt": "2024-10-18T00:03:04Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "657d754ceb75598ee5c777510ba493445dc8147d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6NlLx6",
          "commit": {
            "abbreviatedOid": "b4df087"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-17T13:58:00Z",
          "updatedAt": "2024-10-17T13:58:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 433,
      "id": "PR_kwDOCrLn6M524SMW",
      "title": "Its about time",
      "url": "https://github.com/quicwg/qlog/pull/433",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Don't look too deeply into the commits on this PR, its basically forking off https://github.com/quicwg/qlog/pull/290 and doing a bunch of changes to reflect one of the suggestions made at IETF 120. \r\n\r\nMore concretely, the observation I made on the flight home is that _all_ of the timestamps are a duration relative to something. Where we use the term \"absolute\" timestamp, it might be reasonable to assume that the value is actually an absolute timestamp, not the millis elapsed since some point in the past that may or may not be unix. So this PR goes nuclear and changes the TimeFormat values to relative_to_epoch, relative_to_epoch_elapsed, and relative_to_last_event. We can bikeshed on these of course.\r\n\r\nWhat I've taken from past discussion and the 120 meeting is the suggestion to declare the used epoch in the log format, together with a human friendly \"wall clock time\" that would be something like an iso 8601 format (but I was offline on the plane so couldn't cite it or give proper examples). \r\n\r\nMonotonic folks can declare a \"monotonic\" epoch, and then relative times to that are completely opaque thing. Its up to the loggers to decide how far off the monotonic epoch they want their times to be. Its recommended they use a wall clock time to help give an indication of when things occurred.",
      "createdAt": "2024-07-30T13:44:22Z",
      "updatedAt": "2024-10-21T19:45:54Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "860ecee350c1d910aee9810b5dd607f310530f2a",
      "headRepository": "quicwg/qlog",
      "headRefName": "define-monotonic-clock-take-2",
      "headRefOid": "1d28a5a17882fb8e632dfdf0b34bfa47c6dd6490",
      "closedAt": "2024-10-21T19:45:48Z",
      "mergedAt": "2024-10-21T19:45:48Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "bedb7916fcc2c32a023e96eff6a9cbc44d3e07ae"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, having read this and the previous issues (mainly #198) etc. I'm wondering if this can just be simplified considerably, as such:\r\n\r\n```\r\nReferenceTime = {\r\n    start: ISO8601Time / \"unknown\" .default \"1970-01-01T00:00:00.000Z\"\r\n    clock_type: \"system\" / \"monotonic\" / text .default \"system\"\r\n    ? wall_clock_time: text\r\n}\r\n\r\n; ISO8601 UTC string at millisecond resolution. i.e., YYYY-MM-DDTHH:mm:ss.sssZ\r\nISO8601Time = string\r\n\r\nTimeFormat = \"relative_to_start\" / \r\n             \"relative_to_previous_event\" .default \"relative_to_start\"\r\n```\r\n\r\nIIUC, the main issue you're trying to solve is that things like [`rust:Instant`](https://doc.rust-lang.org/std/time/struct.Instant.html) and monotonic clocks in general don't necessarily neatly map to \"real time\" and thus can't be transformed into \"clear\" timestamps that can be compared across traces/systems/...\r\n\r\nAnother good point in #198 is that it's not possible to define another epoch besides the Unix epoch against which to start values. \r\n\r\nI believe the above solves both.\r\n\r\n---\r\n\r\nThe current text somewhat conflates what an epoch is in my opinion (i.e., \"monotonic\" doesn't make much sense for an epoch... it's more a `clock_type` than an epoch. A monotonic clock would have an epoch of `unknown` or pedantically `dont_care`). The original intent also wasn't to define an epoch as such, just to identify what the `absolute` and `delta` and `reference_time` timestamps were relative to, and the UNIX epoch was a simple thing to use. \r\n\r\nAs such, I'd rather have a `start` time instead of `epoch`, which also allows us to do away with the `elapsed_time` field and simplifies the `TimeFormat`. If you would have the UNIX epoch in 1970 with an `elapsed_time` of 30 years, you'd just log the ISO8601 timestamp for 2000 in `start` (I don't see much reason not to have the qlogger put the proper ISO8601 timestamp in there while generating the file, rather than having the tools reconstruct it later from epoch + elapsed). If you then have a monotonic clock, or you just don't know the start time, or want to obfuscate it, you just say \"unknown\" (and potentially fill in the `wall_clock_time` text if you do want to give a hint).\r\n\r\n--- \r\n\r\nI would of course still keep in the discussion on monotonic clocks and how to take care when using those. I would also have the new `clock_type` field for people who want to make explicitly clear this is a special kind of clock vs the \"normal\" system timer. But while I feel that's important to discuss in the prose, I don't think that should be key to how the format deals with time.\r\n\r\n---\r\n\r\nA few remarks on the current text (probably better done as direct comments...):\r\n\r\n1. millisecond resolution\r\n\r\n> It is a duration measured from some point in time, in millisecond resolution.\r\n\r\nI'm not sure how this works with the monotonic clocks? with the [rust Instant example](https://doc.rust-lang.org/std/time/struct.Instant.html), it says \r\n\r\n> \"instants are not guaranteed to be steady. In other words, each tick of the underlying clock might not be the same length (e.g. some seconds may be longer than others)\"\r\n\r\nso those milliseconds aren't \"really\" milliseconds? but they ARE ms resolution (probably)? So I don't think this sentence holds for monotonic clocks and should be nuanced?\r\n\r\n2. Structure\r\n\r\nSome of the prose should be grouped/ordered differently in my opinion, but we can discuss that once we have consensus on the general approach. \r\n\r\n\r\nLet's discuss this on Wednesday :) \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2024-10-12T20:32:04Z",
          "updatedAt": "2024-10-12T20:32:04Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Treating you comment in order, I've pushed a commit that\r\n\r\n1. Takes the idea of using an explicit date/time value, but chosen RFC 3339 as an IETF profile of ISO8601.\r\n2. Add the clock_type field as suggested\r\n3. I've kept the term epoch, since that is a term of art for any fixed date/time for use as a reference. It also helps disambiguate it from anything else in scope of a qlog start (like the qlog start :laughing: ).\r\n4. Reduced the timeformat to two types as suggested\r\n5. Highlighted that the time field units are ???\r\n  - The field type is float64, how are people actually supposed to use this? In my implementation I log the duration elapsed between two arbitrary times, using https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f64, which is seconds with fractional nanoseconds. Yet a lot of the old examples used milliseconds with no fractional component. In section 1.2 the document states \"All timestamps and time-related values (e.g., offsets) in qlog are logged as `float64` in the millisecond resolution.\" - should that just be moved here where its most relevant? I think this might address your open questions about the resolution. \r\n\r\nWhile your remark about the implementation detail of the monotoic clock is technically direct, I think its not super relevant for this PR. Depending how we answer (4), the timestamp can represent time in units to the resolution of milliseconds (or even nanos?), whether an implementation used that accurately is tangential. Windows is famous for having a timer resolution of ~16ms  - see https://randomascii.wordpress.com/2020/10/04/windows-timer-resolution-the-great-rule-change/. If you ever looked at logs from these platforms and noticed weird batching, its because the timer resolution != logging time field resolution.\r\n\r\n\r\n",
          "createdAt": "2024-10-21T02:25:43Z",
          "updatedAt": "2024-10-21T02:25:43Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6N7s2C",
          "commit": {
            "abbreviatedOid": "1e3e3b0"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "In general, this looks good :) \r\n\r\nI took a stab at the \"millisecond resolution\" part, but feel free to rework that a bit more if you feel it's needed.\r\n\r\nMost comments here are nits/clarifications; in general this looks ready to! It's about time too ;) \r\n",
          "createdAt": "2024-10-21T08:01:19Z",
          "updatedAt": "2024-10-21T08:15:34Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\noccurred. It is a duration measured from some point in time; its units depend on the type of clock chosen and system used. Typically however, a millisecond resolution is employed.\r\n```",
              "createdAt": "2024-10-21T08:01:19Z",
              "updatedAt": "2024-10-21T08:15:34Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n; RFC 3339 UTC string at millisecond resolution. i.e., YYYY-MM-DDTHH:mm:ss.sssZ\r\nRFC3339DateTime = text\r\n```",
              "createdAt": "2024-10-21T08:01:52Z",
              "updatedAt": "2024-10-21T08:15:34Z"
            },
            {
              "originalPosition": 97,
              "body": "```suggestion\r\ncommonly measured against a chosen or well-known epoch. However, depending on the system, System time can potentially jump forward or back. In contrast, a clock using monotonic time is generally guaranteed to never go backwards. The value \"monotonic\" represents such a clock. \r\n```",
              "createdAt": "2024-10-21T08:04:19Z",
              "updatedAt": "2024-10-21T08:15:34Z"
            },
            {
              "originalPosition": 117,
              "body": "```suggestion\r\ndate/time value that logging commenced at if the epoch value is \"unknown\". It uses\r\n```",
              "createdAt": "2024-10-21T08:05:11Z",
              "updatedAt": "2024-10-21T08:15:34Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nThe reference time governs from which point in time the \"time\" field values are measured and is defined as:\r\n```",
              "createdAt": "2024-10-21T08:07:22Z",
              "updatedAt": "2024-10-21T08:15:34Z"
            },
            {
              "originalPosition": 121,
              "body": "```suggestion\r\nThe time format details how \"time\" values are encoded relative to the reference time and is defined as:\r\n```",
              "createdAt": "2024-10-21T08:07:59Z",
              "updatedAt": "2024-10-21T08:15:34Z"
            },
            {
              "originalPosition": 155,
              "body": "```suggestion\r\nTools SHOULD NOT assume the ability to derive the absolute calendar timestamp of an event\r\n```",
              "createdAt": "2024-10-21T08:11:16Z",
              "updatedAt": "2024-10-21T08:15:34Z"
            },
            {
              "originalPosition": 242,
              "body": "```suggestion\r\n          \"clock_type\": \"monotonic\",\r\n```",
              "createdAt": "2024-10-21T08:12:06Z",
              "updatedAt": "2024-10-21T08:15:34Z"
            },
            {
              "originalPosition": 285,
              "body": "```suggestion\r\n              \"epoch\": \"2019-03-29T:22:55:53.572Z\"\r\n```",
              "createdAt": "2024-10-21T08:13:01Z",
              "updatedAt": "2024-10-21T08:15:34Z"
            },
            {
              "originalPosition": 300,
              "body": "```suggestion\r\n              \"epoch\": \"2019-03-29T:22:55:53.572Z\"\r\n```",
              "createdAt": "2024-10-21T08:13:08Z",
              "updatedAt": "2024-10-21T08:15:34Z"
            },
            {
              "originalPosition": 316,
              "body": "```suggestion\r\n            \"epoch\": \"2019-03-29T:22:55:53.572Z\"\r\n```",
              "createdAt": "2024-10-21T08:13:14Z",
              "updatedAt": "2024-10-21T08:15:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6N_Lnh",
          "commit": {
            "abbreviatedOid": "1e3e3b0"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T13:39:40Z",
          "updatedAt": "2024-10-21T13:39:40Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "I don't think we need this, its profiling the RFC even further, which means we need even more text that I don't think helps this document. ",
              "createdAt": "2024-10-21T13:39:40Z",
              "updatedAt": "2024-10-21T13:40:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6N_SM3",
          "commit": {
            "abbreviatedOid": "1e3e3b0"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T13:48:50Z",
          "updatedAt": "2024-10-21T13:48:50Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I don't understand this bit. If I have a float64 field, and I decide to use it to log \"1.5\" to mean one and a half seconds, but the logger tool thinks I meant one and a half milliseconds, then there's an interop issue. So I think we need to pick one form of \"units of x with fractional Y\", or add a field to articulate the concrete units and precision. ",
              "createdAt": "2024-10-21T13:48:50Z",
              "updatedAt": "2024-10-21T13:48:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 437,
      "id": "PR_kwDOCrLn6M5_CCwW",
      "title": "bump GH actions versions",
      "url": "https://github.com/quicwg/qlog/pull/437",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-17T23:59:55Z",
      "updatedAt": "2024-10-18T00:01:19Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "88cc7f80e7063527e1f4df16ef5bde5ef9cfb576",
      "headRepository": "quicwg/qlog",
      "headRefName": "update-gh-actions",
      "headRefOid": "ffff2464b4b64d1f055dad164f7df421d73772be",
      "closedAt": "2024-10-18T00:01:19Z",
      "mergedAt": "2024-10-18T00:01:19Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "74f4f1d1a253a01ba57408097a11403b6444bfde"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 438,
      "id": "PR_kwDOCrLn6M5_GCKe",
      "title": "Add unknown_parameters field",
      "url": "https://github.com/quicwg/qlog/pull/438",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #436 \r\n\r\nI decided not add something similar to `h3:parameters_set` since it makes more sense to just log it as H3Settings there, and that's already possible. ",
      "createdAt": "2024-10-18T11:54:03Z",
      "updatedAt": "2024-10-21T07:50:14Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "65c9758f20ef1cf485990cd2db39941820071e21",
      "headRepository": "quicwg/qlog",
      "headRefName": "unknown-tp",
      "headRefOid": "d526617a310ac6dccba9d4a553b4205de0f9cafa",
      "closedAt": "2024-10-21T07:50:14Z",
      "mergedAt": "2024-10-21T07:50:14Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "3be48be12256ef4258e739e3b6c27d6d9ed76eb4"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PTAL @hawkinsw @LPardue , I think this covers the load :) ",
          "createdAt": "2024-10-18T11:55:14Z",
          "updatedAt": "2024-10-18T11:55:14Z"
        },
        {
          "author": "hawkinsw",
          "authorAssociation": "NONE",
          "body": "Sorry I was slow getting mine ready. I just added another PR that adds unknown parameters in a few additional places. If you would prefer to keep it to just the `parameters_set`, then that's great. I fixed another small typo in my PR. So, if you do end up accepting this PR rather than mine, I will open another one with just that typo fix. Sorry again for not getting this done sooner. I'm really disappointed in myself.",
          "createdAt": "2024-10-18T18:57:05Z",
          "updatedAt": "2024-10-18T18:57:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6Nvfof",
          "commit": {
            "abbreviatedOid": "43a7878"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-18T13:10:17Z",
          "updatedAt": "2024-10-18T13:10:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 439,
      "id": "PR_kwDOCrLn6M5_G1bE",
      "title": "Remove categories",
      "url": "https://github.com/quicwg/qlog/pull/439",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed during today's editors meeting with @LPardue, I feel it would be better and simpler overall to just remove the notion of event categories and only have event `namespaces` to group event types by. \r\n\r\nThis simplifies handling extensions and schema URIs considerably, while also allowing us to more easily extend existing namespaces with new events (e.g., QUIC extensions can be properly tagged as `quic:my_new_event` instead of `my_quic_extension:my_new_event` which would otherwise have been needed).\r\n\r\nCategories were originally needed because I had the vision of reusable event types across protocols (hence stuff in the `connectivity` or `security` categories would be re-usable across both TPC and QUIC for example). In practice, this has turned out to be a pipe dream and the QUIC document has also moved away from that in all but name (and the HTTP/3 document just had a single category anyway). \r\n\r\n(note: Friday 18 oct 4PM CEST: not fully ready yet; still need to remove the categories notion from QUIC and H3 docs, but the main doc text should be ready for review already)\r\n\r\n",
      "createdAt": "2024-10-18T13:49:10Z",
      "updatedAt": "2024-10-21T19:38:25Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "65c9758f20ef1cf485990cd2db39941820071e21",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-categories",
      "headRefOid": "6471bd78a0e1db59a9ea3f27bf824c0f59c4dc54",
      "closedAt": "2024-10-21T19:37:48Z",
      "mergedAt": "2024-10-21T19:37:48Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "aa0080ada8654b316b478262d1743c7b0adb9ca2"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This PR is now 99% ready (I just need to add the full list of QUIC events to the IANA registration in the QUIC document), so also ready for full review. ",
          "createdAt": "2024-10-18T15:05:30Z",
          "updatedAt": "2024-10-18T15:05:30Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I tried an implementation of this, it reduced code and made it more logical to call. I support the change.\r\n\r\nThe one question I have, is #432 resolved by this? An event schema that only extends existing event types with new fields, will have an empty `Event Types` column in the IANA registration. Should we think about adding a column to make it explicit what the new fields are? That seems a bit tedious to manage, especially since we have many extension points through the documents. \r\n\r\nI think this PR finds the right balance of allowing extension schema identification, while avoiding having to import every detail to IANA.",
          "createdAt": "2024-10-20T20:02:35Z",
          "updatedAt": "2024-10-20T20:02:35Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue thanks for trying it out in actual implementation! Good to know this actually works as intended :) \r\n\r\nI do think this solves #432, as you'd just register the new schema without any concrete Event Types. The reason why the Event Types are now also in IANA is because we can now extend existing namespaces with new events, so we need to make sure new events don't collide with older events of the same name (put differently: now only the concatenation of `namespace:event_type` is globally unique across documents). Since extensions to existing events/data types can't collide with previous definitions, they don't need to be in IANA (imo). \r\n\r\nAs such, I also think this approach indeed strike the right balance between ensuring interop and practicality.\r\n\r\nI've resolved your comments above + added the event_types list in the IANA section. PTAL and let me know if this is ready to merge later today :) \r\n\r\n@marten-seemann if you get a moment today, it would be good to have 1 extra pair of eyes on this, since it's a pretty substantial departure from the previous setup. \r\n\r\n",
          "createdAt": "2024-10-21T07:35:09Z",
          "updatedAt": "2024-10-21T07:35:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6Nv8bg",
          "commit": {
            "abbreviatedOid": "9334071"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-18T13:59:27Z",
          "updatedAt": "2024-10-18T13:59:28Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": " nit: I find the inband examples break up the flow, so perhaps consider an example underneath",
              "createdAt": "2024-10-18T13:59:27Z",
              "updatedAt": "2024-10-18T13:59:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6N2yqT",
          "commit": {
            "abbreviatedOid": "4b73791"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-20T02:51:13Z",
          "updatedAt": "2024-10-20T02:51:14Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nThe event namespace with identifier `quic` is defined; see {{schema-def}}. In\r\n```",
              "createdAt": "2024-10-20T02:51:13Z",
              "updatedAt": "2024-10-20T02:51:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6N5f9A",
          "commit": {
            "abbreviatedOid": "4b73791"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-20T19:38:46Z",
          "updatedAt": "2024-10-20T19:38:47Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "```suggestion\r\nOther examples of event schema define the `quic` {{QLOG-QUIC}} and `http3`\r\n```",
              "createdAt": "2024-10-20T19:38:46Z",
              "updatedAt": "2024-10-20T19:38:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6N_iB7",
          "commit": {
            "abbreviatedOid": "6471bd7"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T14:09:41Z",
          "updatedAt": "2024-10-21T14:09:42Z",
          "comments": [
            {
              "originalPosition": 677,
              "body": "missing the `Description` field",
              "createdAt": "2024-10-21T14:09:41Z",
              "updatedAt": "2024-10-21T14:09:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6N_isy",
          "commit": {
            "abbreviatedOid": "6471bd7"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T14:10:35Z",
          "updatedAt": "2024-10-21T14:10:35Z",
          "comments": [
            {
              "originalPosition": 677,
              "body": "oh it was below, resolved",
              "createdAt": "2024-10-21T14:10:35Z",
              "updatedAt": "2024-10-21T14:10:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6N_kT0",
          "commit": {
            "abbreviatedOid": "6471bd7"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T14:12:52Z",
          "updatedAt": "2024-10-21T14:12:52Z",
          "comments": [
            {
              "originalPosition": 779,
              "body": "This format is hard to eyeball. I suspect we might need to revisit it later but I don't want to block this PR on that. Lets see how IANA or others feel when we go through wider document review.",
              "createdAt": "2024-10-21T14:12:52Z",
              "updatedAt": "2024-10-21T14:12:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6N_kkn",
          "commit": {
            "abbreviatedOid": "6471bd7"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Ship it!",
          "createdAt": "2024-10-21T14:13:15Z",
          "updatedAt": "2024-10-21T14:13:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M6ODA-E",
          "commit": {
            "abbreviatedOid": "6471bd7"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T19:38:25Z",
          "updatedAt": "2024-10-21T19:38:25Z",
          "comments": [
            {
              "originalPosition": 779,
              "body": "Agreed, it's not ideal, but I'm not sure what a typical/better approach is for this type of thing with IANA. Plenty willing to change if there's a better alternative :) ",
              "createdAt": "2024-10-21T19:38:25Z",
              "updatedAt": "2024-10-21T19:38:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 440,
      "id": "PR_kwDOCrLn6M5_Iu2w",
      "title": "Add support for logging unknown parameters",
      "url": "https://github.com/quicwg/qlog/pull/440",
      "state": "CLOSED",
      "author": "hawkinsw",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Add support for logging unknown parameters (including parameters set during connection recovery and parameters restored during 0-RTT).\r\n\r\nCloses #436.",
      "createdAt": "2024-10-18T18:54:41Z",
      "updatedAt": "2024-10-21T07:49:37Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "47c49c346f0c15864f8154c570e0139a3dfd8a49",
      "headRepository": "hawkinsw/qlog",
      "headRefName": "main",
      "headRefOid": "03fb0f883aceccc1cac066c1a0263da37e3a53b0",
      "closedAt": "2024-10-21T07:49:37Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@hawkinsw thanks for this! As you saw, I had already made a stab at this at #438. Yours had some good things in it, so I merged them in my PR and will close this one. \r\n\r\nI also did drop a few things from this though, mostly due to how we do qlog in general + the logic behind restored parameters:\r\n- in qlog, length fields are implicit if the value is logged. So for UnknownParameter, I just have the value as a hexstring, not the separate length field\r\n- Unknown parameters are unlikely (or even impossible?) to restore either as part of 0-RTT or congestion control, seeing as we don't know what to do with them locally and restoration is only for local logic (restored parameters are not communicated to the other endpoint, just used to bootstrap the local one pending updates from the other). So I don't have these in the two events you proposed. \r\n\r\nThanks again for your help on this!",
          "createdAt": "2024-10-21T07:49:37Z",
          "updatedAt": "2024-10-21T07:49:37Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 441,
      "id": "PR_kwDOCrLn6M5_SJJZ",
      "title": "Add additional fields to parameters_restored",
      "url": "https://github.com/quicwg/qlog/pull/441",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #431 ",
      "createdAt": "2024-10-21T08:42:41Z",
      "updatedAt": "2024-10-21T19:42:22Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6ffb5ab9f1aff210b08b925788a9771db8833673",
      "headRepository": "quicwg/qlog",
      "headRefName": "restore-more",
      "headRefOid": "f6698291d629cd739315f573d8e34336cc228e8d",
      "closedAt": "2024-10-21T19:42:22Z",
      "mergedAt": "2024-10-21T19:42:22Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "860ecee350c1d910aee9810b5dd607f310530f2a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6N8VNE",
          "commit": {
            "abbreviatedOid": "70a5938"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T09:07:52Z",
          "updatedAt": "2024-10-21T09:07:58Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Why is client capitalized?",
              "createdAt": "2024-10-21T09:07:52Z",
              "updatedAt": "2024-10-21T09:07:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6N_dXH",
          "commit": {
            "abbreviatedOid": "70a5938"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T14:03:39Z",
          "updatedAt": "2024-10-21T14:03:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M6ODCEP",
          "commit": {
            "abbreviatedOid": "70a5938"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T19:41:09Z",
          "updatedAt": "2024-10-21T19:41:09Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Because I'm stupid :) changed.",
              "createdAt": "2024-10-21T19:41:09Z",
              "updatedAt": "2024-10-21T19:41:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 444,
      "id": "PR_kwDOCrLn6M6A0xjv",
      "title": "Indicate send blocking in data_moved events",
      "url": "https://github.com/quicwg/qlog/pull/444",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #132 (if merged).\r\n\r\nIt struck me that its the \"data_moved\" action that can be blocked, so rather than add\r\na separate event, just add an optional field to an existing event. This helps ensure we\r\ncan represent both stream and datagram data with all relevant fields.\r\n",
      "createdAt": "2024-11-04T16:38:48Z",
      "updatedAt": "2025-03-12T11:53:54Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "926f96f26da604d60ed01975c0233e95fed58472",
      "headRepository": "quicwg/qlog",
      "headRefName": "blocked-reasons",
      "headRefOid": "95826e3e2ed1d1fccaa7a20311de8c226aed1bb7",
      "closedAt": "2025-03-12T11:53:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Conceptually this works, but I don't like the suggestion we'd have to omit logging `length` to indicate the data was actually not moved... in practice, length could be a strong signal that helps understand why exactly something was blocked for that reason (e.g., trying to write a ridiculous amount of data due to a bug).\r\n\r\nIf we keep this approach, I'd rather the guidance for this is \"if there's a `blocked_reason`, that means the data was not actually moved, but a move was attempted, which was blocked due to `blocked_reason`\". That imo also works :)\r\n(that's also somewhat analogous to Nick's approach in the issue, saying \"The lack of any flags means it's unblocked.\") ",
          "createdAt": "2024-11-05T19:51:35Z",
          "updatedAt": "2024-11-05T19:52:18Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Fair comment. For context, the quiche implementation has a stream write operation that takes an arbitrarily large buffer and can return a \"partial write\" result. For example, if the cwnd is 15 KB, and a 20 KB buffer is provided, well return an integer length result of 15 KB, indicating the app was blocked from writing the last 5 KB. \r\n\r\nI was thinking it would be nice to reflect that in the qlog as a stream_data_moved with length 15 KB and blocked_reason of congestion window, etc. \r\n\r\nI didn't think through everything in this proposal and maybe more guidance is useful, but it felt at the time of writing that combing the data in a single event would be more convenient for my use than if I had two separate events. \r\n\r\nAlways happy to hear other opinions or review alternatives though.",
          "createdAt": "2024-11-05T20:18:06Z",
          "updatedAt": "2024-11-05T20:18:06Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Having indications for blocked events is paramount to investigating performance issues.\r\n\r\nTherefore, I think they have to be distinct events, rather than tied to data_moved events. That is because not all QUIC implementations \"move\" data between the layers at the same moment (consider implementations having different size of buffers, or having no buffer at all).",
          "createdAt": "2024-11-06T10:47:25Z",
          "updatedAt": "2024-11-06T10:47:25Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "My personal preference is for separate events. We already have it built this way in msquic.\r\n\r\nAlso, I agree with Kazuho. We don't have any notion of moving data between layers.",
          "createdAt": "2024-11-06T11:21:48Z",
          "updatedAt": "2024-11-06T11:21:48Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Ack. Would someone be willing to help on the alternative proposal? Even if ypu can just frame how the alternative works, we can design the event structure definition around that.",
          "createdAt": "2024-11-06T12:11:07Z",
          "updatedAt": "2024-11-06T12:11:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Conversation moved back to issue",
          "createdAt": "2025-03-12T11:53:53Z",
          "updatedAt": "2025-03-12T11:53:53Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 445,
      "id": "PR_kwDOCrLn6M6NCLwz",
      "title": "Fix lists",
      "url": "https://github.com/quicwg/qlog/pull/445",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Without the new lines, these are not rendered as lists.",
      "createdAt": "2025-03-01T14:16:59Z",
      "updatedAt": "2025-03-03T19:05:50Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "926f96f26da604d60ed01975c0233e95fed58472",
      "headRepository": "mengelbart/qlog-drafts",
      "headRefName": "fix-lists",
      "headRefOid": "6941c00a5f1791bc9110af9e0076a52d710eac6e",
      "closedAt": "2025-03-03T19:05:50Z",
      "mergedAt": "2025-03-03T19:05:50Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "2cab25f65f36feb9a16481e7b7917acb26a1f40f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 446,
      "id": "PR_kwDOCrLn6M6NCMXJ",
      "title": "Add event_schemas to examples",
      "url": "https://github.com/quicwg/qlog/pull/446",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "According to [section 3](https://datatracker.ietf.org/doc/html/draft-ietf-quic-qlog-main-schema-10#section-3), event_schemas is required.",
      "createdAt": "2025-03-01T14:22:36Z",
      "updatedAt": "2025-03-13T14:11:35Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "926f96f26da604d60ed01975c0233e95fed58472",
      "headRepository": "mengelbart/qlog-drafts",
      "headRefName": "add-schemas-to-examples",
      "headRefOid": "6675033523754da5e501c5b4baf29760044fd448",
      "closedAt": "2025-03-13T14:11:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for this @mengelbart!\r\n\r\nThough boy, did you open a can of worms in my head :D (see https://github.com/quicwg/qlog/issues/448).\r\n\r\nFor this specific PR though, I just had 1 thought that I've added as a suggestion above.\r\n\r\n\r\n",
          "createdAt": "2025-03-06T09:47:37Z",
          "updatedAt": "2025-03-06T09:47:37Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Glad I could help :D \r\nI'm going to press \"commit suggestion\", just to make sure, but I assume this one can be closed because it's included in #449, right?",
          "createdAt": "2025-03-10T19:02:13Z",
          "updatedAt": "2025-03-10T19:02:13Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was indeed done in #449, which was now merged with attribution, so I'm closing this PR :) thanks again!",
          "createdAt": "2025-03-13T14:11:35Z",
          "updatedAt": "2025-03-13T14:11:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6ex_5g",
          "commit": {
            "abbreviatedOid": "1cf74ad"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-03-06T09:46:56Z",
          "updatedAt": "2025-03-06T09:47:06Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Since the `protocol_types` field below is for both QUIC and H3, it would make sense for this to also include the HTTP/3 schema URI:\r\n\r\n```suggestion\r\n    \"event_schemas\": [\"urn:ietf:params:qlog:events:quic\", \"urn:ietf:params:qlog:events:http3\"],\r\n```",
              "createdAt": "2025-03-06T09:46:56Z",
              "updatedAt": "2025-03-06T09:47:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 449,
      "id": "PR_kwDOCrLn6M6No8wa",
      "title": "Remove protocol_types and move event_schemas to Trace and TraceSeq",
      "url": "https://github.com/quicwg/qlog/pull/449",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #448.\r\n\r\nCo-authored-by: @mengelbart (subsumes #446)",
      "createdAt": "2025-03-06T13:24:27Z",
      "updatedAt": "2025-03-13T14:10:29Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "2cab25f65f36feb9a16481e7b7917acb26a1f40f",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-protocol-types",
      "headRefOid": "c8edf32617bf7623a092920589b51a1e7e3d3b76",
      "closedAt": "2025-03-13T14:10:28Z",
      "mergedAt": "2025-03-13T14:10:28Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "4506b57c84c8e17afaba503a154637a6a5245328"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6e1pPX",
          "commit": {
            "abbreviatedOid": "c8edf32"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Always good to delete text",
          "createdAt": "2025-03-06T15:44:42Z",
          "updatedAt": "2025-03-06T15:44:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M6foY-v",
          "commit": {
            "abbreviatedOid": "c8edf32"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-12T11:53:10Z",
          "updatedAt": "2025-03-12T11:53:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 450,
      "id": "PR_kwDOCrLn6M6NpsWj",
      "title": "Be consistent in how we allow logging of raw values",
      "url": "https://github.com/quicwg/qlog/pull/450",
      "state": "MERGED",
      "author": "rmarx",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- Use RawInfo instead of separate length/payload_length fields + make sure RawInfo is defined everywhere (fixes #447)\r\n- Make sure that we have a separate `*_bytes` field to log raw values for unknown frames/errors/packet_types/... (fixes #421)\r\n\r\n",
      "createdAt": "2025-03-06T14:50:12Z",
      "updatedAt": "2025-03-13T14:01:52Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "2cab25f65f36feb9a16481e7b7917acb26a1f40f",
      "headRepository": "quicwg/qlog",
      "headRefName": "rawinfo-everything",
      "headRefOid": "25136b9ec29962614d620a0c9dd546e316d7ff35",
      "closedAt": "2025-03-13T14:01:41Z",
      "mergedAt": "2025-03-13T14:01:41Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "2f2baeafba04d47ce24b5b44ce285e61990df573"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6fHUcN",
          "commit": {
            "abbreviatedOid": "25136b9"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-09T18:48:48Z",
          "updatedAt": "2025-03-09T18:48:48Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "So for my library, the QUIC layer is responsible for generating qlog frames and it is not application aware. That means I always just send the numerical code right now in `error_code`. Requiring me to send \"unknown\" will inflate my logs without any real benefit. Can we consider making `error_code` optional if going this route?",
              "createdAt": "2025-03-09T18:48:48Z",
              "updatedAt": "2025-03-09T18:48:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6fHUcs",
          "commit": {
            "abbreviatedOid": "25136b9"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-09T18:49:02Z",
          "updatedAt": "2025-03-09T18:49:02Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Similar comment here as https://github.com/quicwg/qlog/pull/450/files#r1986392613",
              "createdAt": "2025-03-09T18:49:02Z",
              "updatedAt": "2025-03-09T18:49:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6fMnkK",
          "commit": {
            "abbreviatedOid": "25136b9"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-10T13:03:58Z",
          "updatedAt": "2025-03-10T13:03:58Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Gosh, I'm not the biggest fan of this... the main reason to do this type of change (imo) is so it's easier what to look at when parsing a qlog. With this, you can always assume the `error_code` is a string and just use that, and only if the value is `unknown` do you need to maybe look for another field. If you make `error_code` optional and people have to look for the optional presence of `error_code_bytes` as well, then there's not that much benefit to changing this from `$ApplicationError / uint64` to two different fields, imo",
              "createdAt": "2025-03-10T13:03:58Z",
              "updatedAt": "2025-03-10T13:03:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6fM79U",
          "commit": {
            "abbreviatedOid": "25136b9"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-10T13:32:15Z",
          "updatedAt": "2025-03-10T13:32:16Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "What do you mean by \"look at when parsing\"? My parser attempts to parse all the defined fields statelessly. It's autogenerated code that currently can determine the qlog type based on whether its parsing a JSON string or number. Since JSON doesn't require order of fields, to be maintained, I'm not sure how a parser can do much statefully without already having parsed the object.\r\n\r\nIf you mean tools dealoling with the qlog object, then I can follow that argument. However, I just render the fields that are in the log, rather than do any checking or enforcement.\r\n\r\nI can live with the current definition, it's straightforward and avoids weird scenarios where a well known error code is logged simply ad an integer rather than a string claiming \"unknown\", which is confusing IMO.",
              "createdAt": "2025-03-10T13:32:15Z",
              "updatedAt": "2025-03-10T13:32:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6fOb_H",
          "commit": {
            "abbreviatedOid": "25136b9"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-10T15:18:30Z",
          "updatedAt": "2025-03-10T15:18:30Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "I mainly meant `tools dealoling with the qlog object`. Lots of stuff to make qvis more userfriendly (e.g., colors) require having some contextual knowledge rather than just displaying all fields as a flat object. \r\n\r\nWith \"the current definition\" you mean prior to this PR (using `$ApplicationError / uint64`) correct? The reason we're trying to do away with it is because of support for IJSON (if you have a number > 2^53 it would be included as a string, and presumably also parsed as a string in Serde, not a number?), so you'd get weird ambiguities when deciding if something was a number or a string when looking at the `error_code`. \r\n\r\nThis PR is just making that pattern consistent across all the things, instead of just in some instances (e.g., in #383). I'd rather we be consistent/predictable for this situation than ad-hoc solutions myself. ",
              "createdAt": "2025-03-10T15:18:30Z",
              "updatedAt": "2025-03-10T15:18:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6fOkvm",
          "commit": {
            "abbreviatedOid": "25136b9"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-10T15:29:02Z",
          "updatedAt": "2025-03-10T15:29:02Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "In that case, I don't think it's too onerous on a more-capable tool to allow for error_code to be optional. It can just treat an omitted field as the default \"unknown\"",
              "createdAt": "2025-03-10T15:29:02Z",
              "updatedAt": "2025-03-10T15:29:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6f06-i",
          "commit": {
            "abbreviatedOid": "25136b9"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-13T11:02:44Z",
          "updatedAt": "2025-03-13T11:02:44Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "another option would be for me to log an empty string (which I think is inherently allowed) - that doesn't require any change to this PR and lets me shave some unnecessary/mislabelled bytes of `\"unknown\"`\r\n",
              "createdAt": "2025-03-13T11:02:44Z",
              "updatedAt": "2025-03-13T11:02:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6f3NYM",
          "commit": {
            "abbreviatedOid": "25136b9"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-13T14:00:44Z",
          "updatedAt": "2025-03-13T14:00:44Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "If that's ok for you, then that works for me as well :) ",
              "createdAt": "2025-03-13T14:00:44Z",
              "updatedAt": "2025-03-13T14:00:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 451,
      "id": "PR_kwDOCrLn6M6OQdgW",
      "title": "Editorial work of triggers",
      "url": "https://github.com/quicwg/qlog/pull/451",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As discussed on https://github.com/quicwg/qlog/issues/429, it seems like a better option to just RECOMMEND a \"trigger\" field if an event would benefit from an explicit trigger.\r\n\r\nThis change removes the mention of triggers from the parent section (8.2) and puts the normative sugestion in the trigger section (8.2.1)\r\n\r\nCloses https://github.com/quicwg/qlog/issues/429",
      "createdAt": "2025-03-12T01:13:28Z",
      "updatedAt": "2025-03-12T11:47:25Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "2cab25f65f36feb9a16481e7b7917acb26a1f40f",
      "headRepository": "quicwg/qlog",
      "headRefName": "simplify-trigger-text",
      "headRefOid": "b77f2b711523cdbc6ecb3597f40090ae5cda3e82",
      "closedAt": "2025-03-12T11:47:25Z",
      "mergedAt": "2025-03-12T11:47:25Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "7ad61f231de4355260dd7a20502428c26893e1d6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6fnoeG",
          "commit": {
            "abbreviatedOid": "7a74d3e"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Minus the nit, LGTM!",
          "createdAt": "2025-03-12T10:54:03Z",
          "updatedAt": "2025-03-12T10:55:39Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nIt can be useful to understand the cause or trigger of an event. Sometimes,\r\n```",
              "createdAt": "2025-03-12T10:54:03Z",
              "updatedAt": "2025-03-12T10:55:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 452,
      "id": "PR_kwDOCrLn6M6OQkFi",
      "title": "Remove resources related to very old drafts",
      "url": "https://github.com/quicwg/qlog/pull/452",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "These have not been useful for a long time and provide a distraction.\r\n",
      "createdAt": "2025-03-12T01:32:08Z",
      "updatedAt": "2025-03-12T11:45:30Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "2cab25f65f36feb9a16481e7b7917acb26a1f40f",
      "headRepository": "quicwg/qlog",
      "headRefName": "clear-cruft",
      "headRefOid": "690a4be9670066c48d14c7e65bc4beb13b2d3b19",
      "closedAt": "2025-03-12T11:45:26Z",
      "mergedAt": "2025-03-12T11:45:26Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "3100dd2045771436b2b0054a4c6d930047b38f9c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6fnjLb",
          "commit": {
            "abbreviatedOid": "690a4be"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-12T10:46:09Z",
          "updatedAt": "2025-03-12T10:46:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 453,
      "id": "PR_kwDOCrLn6M6OQuX5",
      "title": "Update QUICConnectionStarted event",
      "url": "https://github.com/quicwg/qlog/pull/453",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We've had issue #119 open for over 4 years. It proposed a few options\r\nwith the preference towards option 3, which related to #57 and #79.\r\nBoth of those issues have been fixed. In parallel, we've also got rid\r\nof the notion of generic \"transport\" events and everything is framed\r\nin terms of QUIC now.\r\n\r\nMore to the point, we added the PathEndpointInfo type that contains\r\nall the same sorts of information that's needed, and it has text that\r\ndescribes directionality aspects that #119 was concerned about.\r\nTherefore, I lets just use that.\r\n\r\nAlso remove the `protocol` field now that the event is purely QUIC.\r\n\r\nCloses #119\r\n",
      "createdAt": "2025-03-12T01:55:19Z",
      "updatedAt": "2025-03-13T14:06:48Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "2cab25f65f36feb9a16481e7b7917acb26a1f40f",
      "headRepository": "quicwg/qlog",
      "headRefName": "improve-connection-started-event",
      "headRefOid": "39ffceb8808c928aed8d6b0b3d77046ae3252c41",
      "closedAt": "2025-03-13T14:06:42Z",
      "mergedAt": "2025-03-13T14:06:42Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "de427ea9e9eef55952f67b5d9efee052ab29a309"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I love it when things come together in the end :) Let's merge this!",
          "createdAt": "2025-03-13T13:50:33Z",
          "updatedAt": "2025-03-13T13:50:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6f3DN9",
          "commit": {
            "abbreviatedOid": "39ffceb"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-13T13:50:51Z",
          "updatedAt": "2025-03-13T13:50:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 454,
      "id": "PR_kwDOCrLn6M6OQ7F6",
      "title": "Add aborted connection_close trigger",
      "url": "https://github.com/quicwg/qlog/pull/454",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We talked about this on #147 and there seemed to be agreement to just do it.\r\n\r\n@marten-seemann had an unanswered question on the issue\r\n\r\n> How would an application log more details though? I could image that an application might want to add some more details, like \"lost the race to connection XXX\", but I don't think that's something that we need to standardize.\r\n\r\nMy suggestion is that additional context can be wedged into the existing `reason` field, or just inserted as a new extension field. Particularly if the logs are intended to be consumed by the maintainer of the software that generated the log, they probably have the means to do either and figure out what works best for them.\r\n\r\n\r\nCloses #147",
      "createdAt": "2025-03-12T02:35:23Z",
      "updatedAt": "2025-03-13T14:07:11Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "2cab25f65f36feb9a16481e7b7917acb26a1f40f",
      "headRepository": "quicwg/qlog",
      "headRefName": "connection-closed-aborted-trigger",
      "headRefOid": "997c6a1d6a1842137690867e4cf185a08a2791bb",
      "closedAt": "2025-03-13T14:07:11Z",
      "mergedAt": "2025-03-13T14:07:11Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "38c8a4f6d32028ce8acfa109b8dd82fe2e31f074"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6fndtq",
          "commit": {
            "abbreviatedOid": "997c6a1"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2025-03-12T10:39:48Z",
          "updatedAt": "2025-03-12T10:39:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 455,
      "id": "PR_kwDOCrLn6M6ORBvS",
      "title": "add trigger and reason to H3PriorityUpdated",
      "url": "https://github.com/quicwg/qlog/pull/455",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "implements my latest proposal on #324\r\n\r\nCloses #324",
      "createdAt": "2025-03-12T02:57:22Z",
      "updatedAt": "2025-03-12T11:44:48Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "2cab25f65f36feb9a16481e7b7917acb26a1f40f",
      "headRepository": "quicwg/qlog",
      "headRefName": "priority-updated-reason",
      "headRefOid": "6ecb2800714e5868091ce1121e261e827642a452",
      "closedAt": "2025-03-12T11:44:45Z",
      "mergedAt": "2025-03-12T11:44:45Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "7c6347edf680b7435b1f027372a250c1308333aa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6fnkw7",
          "commit": {
            "abbreviatedOid": "e214c30"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "There's definitely some overlap between the two here which makes it feel less \"clean\". \r\n\r\nHowever, being a Prioritization Enthusiast myself, I can definitely see the value of having a split into two fields, allowing for fine-grained info (especially since the fields are optional). \r\n\r\nMinus the superfluous `The`, LGTM!",
          "createdAt": "2025-03-12T10:48:05Z",
          "updatedAt": "2025-03-12T10:51:36Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\npolicies. The `trigger` and `reason` fields can be used to optionally\r\n```",
              "createdAt": "2025-03-12T10:48:05Z",
              "updatedAt": "2025-03-12T10:51:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 457,
      "id": "PR_kwDOCrLn6M6OanxT",
      "title": "Remove excessive citation of importance level section",
      "url": "https://github.com/quicwg/qlog/pull/457",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I don't think the importance level is _that important_ that we need\r\na deep link into the qlog main schema every time. Its a visual\r\ndistraction. So instead, highlight the convention in the convention\r\nsection and remove all these redundant links.\r\n",
      "createdAt": "2025-03-12T22:34:23Z",
      "updatedAt": "2025-07-07T02:27:37Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6f1026d3512fbb5ef36670860bb1cbbae6ffc864",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-excessive-citation",
      "headRefOid": "fc51a74141f6edbc2aaf78ec685ba2e0f2bc9804",
      "closedAt": "2025-07-07T02:27:33Z",
      "mergedAt": "2025-07-07T02:27:33Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "57bbe989f2cdda9a524f5c30b059874151c88942"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, this was annoying me as well!\r\n\r\nOne questions is if you intentionally not removed this from the events in the main schema as well (e.g., https://quicwg.org/qlog/draft-ietf-quic-qlog-main-schema#section-9.1)? \r\n\r\nI can see an argument for keeping them intact in that doc but not in the others, but if it wasn't intentional, maybe remove them there as well. Otherwise LGTM!",
          "createdAt": "2025-03-13T13:47:12Z",
          "updatedAt": "2025-03-13T13:47:12Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Leaving them in main schema was an accident, I'll fix that up",
          "createdAt": "2025-03-13T14:06:08Z",
          "updatedAt": "2025-03-13T14:06:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6f3Djs",
          "commit": {
            "abbreviatedOid": "eda5ce9"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-13T13:51:10Z",
          "updatedAt": "2025-03-13T13:51:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 458,
      "id": "PR_kwDOCrLn6M6OwQOP",
      "title": "make the IPv4 and IPv6 2-tuple in the PreferredAddress optional",
      "url": "https://github.com/quicwg/qlog/pull/458",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "According to section 18.2 of RFC 9000, the server MAY only send one (valid) address:\r\n> Servers MAY choose to only send a preferred address of one address family by sending an all-zero address and port (0.0.0.0:0 or [::]:0) for the other family. IP addresses are encoded in network byte order.\r\n\r\nIn that case, it should be valid to just not log the invalid address.",
      "createdAt": "2025-03-15T04:54:36Z",
      "updatedAt": "2025-03-17T15:55:05Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "4506b57c84c8e17afaba503a154637a6a5245328",
      "headRepository": "quicwg/qlog",
      "headRefName": "preferred-address-address-families",
      "headRefOid": "2a0c438da3312ce47fed3532a1a129da1ab768a5",
      "closedAt": "2025-03-17T15:55:05Z",
      "mergedAt": "2025-03-17T15:55:04Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "7b824b047058139fe312d2388ca08d9d8c584b7e"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Making it optional seems fine, but can we leave the field order the same for consitency with other events that carry IPs",
          "createdAt": "2025-03-16T03:13:09Z",
          "updatedAt": "2025-03-16T03:13:09Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "body": "> Making it optional seems fine, but can we leave the field order the same for consitency with other events that carry IPs\r\n\r\nFixed for the other ones in #460.",
          "createdAt": "2025-03-16T03:20:24Z",
          "updatedAt": "2025-03-16T03:20:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6gWm2h",
          "commit": {
            "abbreviatedOid": "2a0c438"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-17T12:25:00Z",
          "updatedAt": "2025-03-17T12:25:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 459,
      "id": "PR_kwDOCrLn6M6OzhRq",
      "title": "Remove IPVersion type that is not used",
      "url": "https://github.com/quicwg/qlog/pull/459",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-16T03:15:09Z",
      "updatedAt": "2025-03-17T15:55:20Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "4506b57c84c8e17afaba503a154637a6a5245328",
      "headRepository": "quicwg/qlog",
      "headRefName": "remove-ipversion",
      "headRefOid": "45e2c55cbfd7996e85314e8cb7d23ccc057e9012",
      "closedAt": "2025-03-17T15:55:20Z",
      "mergedAt": "2025-03-17T15:55:20Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "f18cf925f896d041b8e0190f5547735f2013b784"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6gP0mB",
          "commit": {
            "abbreviatedOid": "45e2c55"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-16T03:20:59Z",
          "updatedAt": "2025-03-16T03:20:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCrLn6M6gWlax",
          "commit": {
            "abbreviatedOid": "45e2c55"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-17T12:23:01Z",
          "updatedAt": "2025-03-17T12:23:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 460,
      "id": "PR_kwDOCrLn6M6Ozhm1",
      "title": "reorder IPAddress and port fields",
      "url": "https://github.com/quicwg/qlog/pull/460",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We shouldn't separate IP address and port for IPv4 and IPv6 addresses.\r\n\r\nFor `PreferredAddress`, this is done in #458.",
      "createdAt": "2025-03-16T03:20:05Z",
      "updatedAt": "2025-03-17T15:55:41Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "4506b57c84c8e17afaba503a154637a6a5245328",
      "headRepository": "quicwg/qlog",
      "headRefName": "reorder-ip-address-ports",
      "headRefOid": "bf00acab4b5b5cf309e56dedf9fbea50214c66b7",
      "closedAt": "2025-03-17T15:55:41Z",
      "mergedAt": "2025-03-17T15:55:41Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "0d735b679c3b36d0f4f6b4b759337c71bc9e99e2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 462,
      "id": "PR_kwDOCrLn6M6TPCuh",
      "title": "Added missing events to QuicEventData",
      "url": "https://github.com/quicwg/qlog/pull/462",
      "state": "MERGED",
      "author": "DannyG-1952723",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I noticed that 3 events were missing from `QuicEventData` (`QUICMigrationStateUpdated`, `QUICMarkedForRetransmit`, and `QUICEcnStateUpdated`), so I added these. The security events (`QUICKeyUpdated` and `QUICKeyDiscarded`) were placed above the transport events, while the text has it the other way around, so I moved these so `QuicEventData` has the same order as the text.",
      "createdAt": "2025-04-20T19:37:15Z",
      "updatedAt": "2025-04-24T07:22:14Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "c3af792f6f369325f0829d09f4b2257ef2c6a62e",
      "headRepository": "DannyG-1952723/qlog",
      "headRefName": "quic-event-data-fix",
      "headRefOid": "a205ac63c952f17bfbbb51fa2a2cab79bdc317d9",
      "closedAt": "2025-04-24T07:22:14Z",
      "mergedAt": "2025-04-24T07:22:14Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "6f1026d3512fbb5ef36670860bb1cbbae6ffc864"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6l8oGv",
          "commit": {
            "abbreviatedOid": "74dc174"
          },
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks @DannyG-1952723 for catching this (not sure why we didn't... :))\r\n\r\nJust a small nit for consistency and then I think this can be merged. ",
          "createdAt": "2025-04-22T13:32:39Z",
          "updatedAt": "2025-04-22T13:33:47Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n                QUICECNStateUpdated\r\n```\r\n\r\nFor better or worse, we're capitalising this in the other part of the doc, so let's stay consistent :) ",
              "createdAt": "2025-04-22T13:32:39Z",
              "updatedAt": "2025-04-22T13:33:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCrLn6M6l83ox",
          "commit": {
            "abbreviatedOid": "74dc174"
          },
          "author": "DannyG-1952723",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-22T13:51:12Z",
          "updatedAt": "2025-04-22T13:51:12Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Oh yeah, my bad :)",
              "createdAt": "2025-04-22T13:51:12Z",
              "updatedAt": "2025-04-22T13:51:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 463,
      "id": "PR_kwDOCrLn6M6dq2Z0",
      "title": "Remove references to stale concrete examples",
      "url": "https://github.com/quicwg/qlog/pull/463",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Although this in included in a note for the RFC editor to remove,\r\nthere seems little point in directing anyone else in the meantime\r\nto stale stuff. So lets remove the pointers.\r\n",
      "createdAt": "2025-07-07T01:48:26Z",
      "updatedAt": "2025-07-07T12:17:02Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6f1026d3512fbb5ef36670860bb1cbbae6ffc864",
      "headRepository": "quicwg/qlog",
      "headRefName": "lucas/remove-links-to-outdated-schema",
      "headRefOid": "6bff2b55f2d915a0592d439d766ec64eec386869",
      "closedAt": "2025-07-07T12:17:02Z",
      "mergedAt": "2025-07-07T12:17:02Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "ac0fb1afbbf1e6d10930da4c9edc530c8f3b3b2a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 464,
      "id": "PR_kwDOCrLn6M6dq507",
      "title": "Add pointer to IANA section that creates event schema URIs registry",
      "url": "https://github.com/quicwg/qlog/pull/464",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "closes #443 ",
      "createdAt": "2025-07-07T01:56:53Z",
      "updatedAt": "2025-07-07T12:19:58Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6f1026d3512fbb5ef36670860bb1cbbae6ffc864",
      "headRepository": "quicwg/qlog",
      "headRefName": "lucas/IANA-pointers",
      "headRefOid": "09a9a73bf49a30ab47832796a894c9c8d0cab6f2",
      "closedAt": "2025-07-07T12:19:57Z",
      "mergedAt": "2025-07-07T12:19:57Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "899db22c3ebca158b4efaa90f390f068d0e84a90"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 465,
      "id": "PR_kwDOCrLn6M6dq_DP",
      "title": "Run make update-files",
      "url": "https://github.com/quicwg/qlog/pull/465",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "- **Automatic update of .gitignore**\r\n- **Automatic update of Makefile**\r\n- **Automatic update of README.md**\r\n- **Automatic update of .github/workflows/ghpages.yml**\r\n- **Automatic update of .github/workflows/publish.yml**\r\n- **Automatic update of .github/workflows/archive.yml**\r\n- **Automatic update of .github/workflows/update.yml**\r\n",
      "createdAt": "2025-07-07T02:13:03Z",
      "updatedAt": "2025-07-07T12:37:33Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6f1026d3512fbb5ef36670860bb1cbbae6ffc864",
      "headRepository": "quicwg/qlog",
      "headRefName": "update-gh-things",
      "headRefOid": "138e8b909ed4970c8cd77f84ab406dc9a358836f",
      "closedAt": "2025-07-07T12:37:33Z",
      "mergedAt": "2025-07-07T12:37:33Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "b5cff3360ee54ca6498b5da778c5914177a4cd4c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 466,
      "id": "PR_kwDOCrLn6M6drCP7",
      "title": "More precisely define time units",
      "url": "https://github.com/quicwg/qlog/pull/466",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This builds on the prior vagueness but channels the discussion in\r\nto represent 1 millisecond and 500 microseconds. That could equally\r\nbe represented as \"1.500\" too but I want to avoid the rabbithole\r\nof talking about string representation and trailing leading/trailing\r\nzeroes.\r\n\r\ncloses #442 ",
      "createdAt": "2025-07-07T02:24:58Z",
      "updatedAt": "2025-07-07T12:24:54Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "6f1026d3512fbb5ef36670860bb1cbbae6ffc864",
      "headRepository": "quicwg/qlog",
      "headRefName": "timeunits",
      "headRefOid": "9a1d75b4cc7cd213d58d93e6373bfb127cce9f29",
      "closedAt": "2025-07-07T12:24:53Z",
      "mergedAt": "2025-07-07T12:24:53Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "d55aa5e79e9803c4e9920a2cec251c086bee53ac"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 467,
      "id": "PR_kwDOCrLn6M6drJ2z",
      "title": "Add x_data_blocked_updated events",
      "url": "https://github.com/quicwg/qlog/pull/467",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Implements @rmarx suggestion in https://github.com/quicwg/qlog/issues/132#issuecomment-2721313789\r\n\r\nWe can bikeshed the names but otherwise I think this is the most agreeable design approach. My preference would be to land this sooner that later though.\r\n\r\nCloses #132 ",
      "createdAt": "2025-07-07T02:52:41Z",
      "updatedAt": "2025-07-07T14:25:58Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "57bbe989f2cdda9a524f5c30b059874151c88942",
      "headRepository": "quicwg/qlog",
      "headRefName": "lucas/blocked-unblocked",
      "headRefOid": "05e793f4041dca55efa3da8776e059cce85cbe1e",
      "closedAt": "2025-07-07T14:25:58Z",
      "mergedAt": "2025-07-07T14:25:58Z",
      "mergedBy": "rmarx",
      "mergeCommit": {
        "oid": "06690b1b3f66df98bdd633d6a04fe755158551be"
      },
      "comments": [
        {
          "author": "rmarx",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Made a few minor changes (prose, making the `BlockedState` extensible) but primarily made sure the events were mentioned in the TOC/event list and listings had a name. \r\n\r\nThis seems GTG to me so I decided to just merge it so I can include it in the new drafts; we can always change it later if there are issues. ",
          "createdAt": "2025-07-07T14:25:39Z",
          "updatedAt": "2025-07-07T14:25:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 468,
      "id": "PR_kwDOCrLn6M6d7PKP",
      "title": "Tweak stream_state_updated",
      "url": "https://github.com/quicwg/qlog/pull/468",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This implements my suggestions from #374, adding a new optional\r\ninitiator field to supplement the stream_type field, along with\r\nmaking the stream_side field mandatory.\r\n\r\nHaving just implemented a prototype pcap to qlog tool, that tool\r\nneeds to try and build an understanding of who is a QUIC server\r\nand client, and in what direction messages are flowing. So even\r\nan observer vantage point can determine and log `stream_side`.\r\n\r\nCloses #374\r\n",
      "createdAt": "2025-07-08T11:24:55Z",
      "updatedAt": "2025-07-08T14:58:22Z",
      "baseRepository": "quicwg/qlog",
      "baseRefName": "main",
      "baseRefOid": "06690b1b3f66df98bdd633d6a04fe755158551be",
      "headRepository": "quicwg/qlog",
      "headRefName": "lucas/stream-state-event-tweaks",
      "headRefOid": "e7c897c1e1647b40d31db84280ca94c2af5f38cf",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Note I am not a strong advocate for things here, just trying to drive the issue to a close :)\r\n\r\nThe spec is a bit strange, it pushes people towards using coarse events:\r\n\r\n> QUIC implementations SHOULD mainly log the simplified (HTTP/2-alike) BaseStreamStates instead of the more fine-grained GranularStreamStates.\r\n\r\nIf we removed `stream_side`, there's a risk that an event like `stream_id=0, new=closed\" is too generic to express the actual QUIC protocol stream state. \r\n\r\nAn alternative might be to ditch the granular stream states, push implementations to log the fine-grained states that encode the QUIC protocol machinery in their labels, and then drop the redundant fields like `stream_side` and `stream_type` (and don't add an `initiator` like we do here). That seems a reasonable alternative to me I could support. Especially since a future extension could add additional fields if they turn out to be needed by someone,",
          "createdAt": "2025-07-08T14:58:22Z",
          "updatedAt": "2025-07-08T14:58:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCrLn6M6ysFvL",
          "commit": {
            "abbreviatedOid": "e7c897c"
          },
          "author": "marten-seemann",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Isn't this duplicate now? For example, if we're a client, and we're dealing with a client-initiated uni-directional stream, we know for a fact that it's a send stream.\r\n\r\nMy preference would be for removing `stream_side` altogether.",
          "createdAt": "2025-07-08T14:24:23Z",
          "updatedAt": "2025-07-08T14:24:23Z",
          "comments": []
        }
      ]
    }
  ]
}